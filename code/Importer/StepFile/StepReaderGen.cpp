/*
Open Asset Import Library (ASSIMP)
----------------------------------------------------------------------

Copyright (c) 2006-2018, ASSIMP Development Team
All rights reserved.

Redistribution and use of this software in source and binary forms, 
with or without modification, are permitted provided that the 
following conditions are met:

* Redistributions of source code must retain the above
  copyright notice, this list of conditions and the
  following disclaimer.

* Redistributions in binary form must reproduce the above
  copyright notice, this list of conditions and the
  following disclaimer in the documentation and/or other
  materials provided with the distribution.

* Neither the name of the ASSIMP team, nor the names of its
  contributors may be used to endorse or promote products
  derived from this software without specific prior
  written permission of the ASSIMP Development Team.

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 
"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT 
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT 
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT 
LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY 
THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT 
(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE 
OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

----------------------------------------------------------------------
*/

/** MACHINE-GENERATED by scripts/ICFImporter/CppGenerator.py */

#ifndef ASSIMP_BUILD_NO_STEPFILE_IMPORTER

#include "code/Importer/StepFile/StepReaderGen.h"

namespace Assimp {
using namespace StepFile;

namespace {

	typedef EXPRESS::ConversionSchema::SchemaEntry SchemaEntry;
	const SchemaEntry schema_raw[] =  {
		SchemaEntry("absorbed_dose_measure",NULL )
,		SchemaEntry("acceleration_measure",NULL )
,		SchemaEntry("action_items",NULL )
,		SchemaEntry("action_method_items",NULL )
,		SchemaEntry("action_request_item",NULL )
,		SchemaEntry("ahead_or_behind",NULL )
,		SchemaEntry("amount_of_substance_measure",NULL )
,		SchemaEntry("angle_direction_reference_select",NULL )
,		SchemaEntry("angle_direction_reference_with_a2p3d_select",NULL )
,		SchemaEntry("angle_relator",NULL )
,		SchemaEntry("annotation_plane_element",NULL )
,		SchemaEntry("annotation_representation_select",NULL )
,		SchemaEntry("annotation_symbol_occurrence_item",NULL )
,		SchemaEntry("annotation_text_occurrence_item",NULL )
,		SchemaEntry("approval_item",NULL )
,		SchemaEntry("approved_item",NULL )
,		SchemaEntry("area_measure",NULL )
,		SchemaEntry("area_or_view",NULL )
,		SchemaEntry("attribute_classification_item",NULL )
,		SchemaEntry("attribute_language_item",NULL )
,		SchemaEntry("attribute_type",NULL )
,		SchemaEntry("axis2_placement",NULL )
,		SchemaEntry("b_spline_curve_form",NULL )
,		SchemaEntry("b_spline_surface_form",NULL )
,		SchemaEntry("base_solid_select",NULL )
,		SchemaEntry("blend_end_condition_select",NULL )
,		SchemaEntry("blend_radius_variation_type",NULL )
,		SchemaEntry("boolean_operand",NULL )
,		SchemaEntry("boolean_operator",NULL )
,		SchemaEntry("box_characteristic_select",NULL )
,		SchemaEntry("box_height",NULL )
,		SchemaEntry("box_rotate_angle",NULL )
,		SchemaEntry("box_slant_angle",NULL )
,		SchemaEntry("box_width",NULL )
,		SchemaEntry("camera_model_d3_multi_clipping_interection_select",NULL )
,		SchemaEntry("camera_model_d3_multi_clipping_union_select",NULL )
,		SchemaEntry("capacitance_measure",NULL )
,		SchemaEntry("category_usage_item",NULL )
,		SchemaEntry("cc_classified_item",NULL )
,		SchemaEntry("cc_person_organization_item",NULL )
,		SchemaEntry("cc_specified_item",NULL )
,		SchemaEntry("celsius_temperature_measure",NULL )
,		SchemaEntry("central_or_parallel",NULL )
,		SchemaEntry("certification_item",NULL )
,		SchemaEntry("certified_item",NULL )
,		SchemaEntry("change_request_item",NULL )
,		SchemaEntry("character_spacing_select",NULL )
,		SchemaEntry("character_style_select",NULL )
,		SchemaEntry("characterized_action_definition",NULL )
,		SchemaEntry("characterized_definition",NULL )
,		SchemaEntry("characterized_material_property",NULL )
,		SchemaEntry("characterized_product_composition_value",NULL )
,		SchemaEntry("characterized_product_definition",NULL )
,		SchemaEntry("class_usage_effectivity_context_item",NULL )
,		SchemaEntry("classification_item",NULL )
,		SchemaEntry("classified_item",NULL )
,		SchemaEntry("compound_item_definition",NULL )
,		SchemaEntry("conductance_measure",NULL )
,		SchemaEntry("configuration_design_item",NULL )
,		SchemaEntry("configured_effectivity_context_item",NULL )
,		SchemaEntry("configured_effectivity_item",NULL )
,		SchemaEntry("constructive_geometry_representation_or_shape_represenation",NULL )
,		SchemaEntry("context_dependent_measure",NULL )
,		SchemaEntry("contract_item",NULL )
,		SchemaEntry("contracted_item",NULL )
,		SchemaEntry("count_measure",NULL )
,		SchemaEntry("csg_primitive",NULL )
,		SchemaEntry("csg_select",NULL )
,		SchemaEntry("curve_font_or_scaled_curve_font_select",NULL )
,		SchemaEntry("curve_on_surface",NULL )
,		SchemaEntry("curve_or_annotation_curve_occurrence",NULL )
,		SchemaEntry("curve_or_render",NULL )
,		SchemaEntry("curve_style_font_select",NULL )
,		SchemaEntry("date_and_time_item",NULL )
,		SchemaEntry("date_item",NULL )
,		SchemaEntry("date_time_item",NULL )
,		SchemaEntry("date_time_or_event_occurrence",NULL )
,		SchemaEntry("date_time_select",NULL )
,		SchemaEntry("day_in_month_number",NULL )
,		SchemaEntry("day_in_week_number",NULL )
,		SchemaEntry("day_in_year_number",NULL )
,		SchemaEntry("defined_symbol_select",NULL )
,		SchemaEntry("derived_property_select",NULL )
,		SchemaEntry("description_attribute_select",NULL )
,		SchemaEntry("descriptive_measure",NULL )
,		SchemaEntry("dimension_count",NULL )
,		SchemaEntry("dimension_extent_usage",NULL )
,		SchemaEntry("dimensional_characteristic",NULL )
,		SchemaEntry("direction_count_select",NULL )
,		SchemaEntry("document_identifier_assigned_item",NULL )
,		SchemaEntry("document_reference_item",NULL )
,		SchemaEntry("dose_equivalent_measure",NULL )
,		SchemaEntry("draughting_callout_element",NULL )
,		SchemaEntry("draughting_model_item_association_select",NULL )
,		SchemaEntry("draughting_model_item_select",NULL )
,		SchemaEntry("draughting_titled_item",NULL )
,		SchemaEntry("effectivity_item",NULL )
,		SchemaEntry("electric_charge_measure",NULL )
,		SchemaEntry("electric_current_measure",NULL )
,		SchemaEntry("electric_potential_measure",NULL )
,		SchemaEntry("energy_measure",NULL )
,		SchemaEntry("event_occurrence_item",NULL )
,		SchemaEntry("external_identification_item",NULL )
,		SchemaEntry("fill_area_style_tile_shape_select",NULL )
,		SchemaEntry("fill_style_select",NULL )
,		SchemaEntry("font_select",NULL )
,		SchemaEntry("force_measure",NULL )
,		SchemaEntry("founded_item_select",NULL )
,		SchemaEntry("frequency_measure",NULL )
,		SchemaEntry("generalized_surface_select",NULL )
,		SchemaEntry("geometric_item_specific_usage_select",NULL )
,		SchemaEntry("geometric_set_select",NULL )
,		SchemaEntry("groupable_item",NULL )
,		SchemaEntry("hour_in_day",NULL )
,		SchemaEntry("id_attribute_select",NULL )
,		SchemaEntry("identification_item",NULL )
,		SchemaEntry("identifier",NULL )
,		SchemaEntry("illuminance_measure",NULL )
,		SchemaEntry("inductance_measure",NULL )
,		SchemaEntry("instance_usage_context_select",NULL )
,		SchemaEntry("invisibility_context",NULL )
,		SchemaEntry("invisible_item",NULL )
,		SchemaEntry("ir_usage_item",NULL )
,		SchemaEntry("knot_type",NULL )
,		SchemaEntry("label",NULL )
,		SchemaEntry("layered_item",NULL )
,		SchemaEntry("length_measure",NULL )
,		SchemaEntry("limit_condition",NULL )
,		SchemaEntry("list_of_reversible_topology_item",NULL )
,		SchemaEntry("list_representation_item",NULL )
,		SchemaEntry("luminous_flux_measure",NULL )
,		SchemaEntry("luminous_intensity_measure",NULL )
,		SchemaEntry("magnetic_flux_density_measure",NULL )
,		SchemaEntry("magnetic_flux_measure",NULL )
,		SchemaEntry("marker_select",NULL )
,		SchemaEntry("marker_type",NULL )
,		SchemaEntry("mass_measure",NULL )
,		SchemaEntry("measure_value",NULL )
,		SchemaEntry("mechanical_design_and_draughting_relationship_select",NULL )
,		SchemaEntry("mechanical_design_geometric_presentation_area_items",NULL )
,		SchemaEntry("mechanical_design_geometric_presentation_representation_items",NULL )
,		SchemaEntry("message",NULL )
,		SchemaEntry("minute_in_hour",NULL )
,		SchemaEntry("month_in_year_number",NULL )
,		SchemaEntry("multi_language_attribute_item",NULL )
,		SchemaEntry("name_attribute_select",NULL )
,		SchemaEntry("name_item",NULL )
,		SchemaEntry("non_negative_length_measure",NULL )
,		SchemaEntry("nonnegative_integer",NULL )
,		SchemaEntry("null_style",NULL )
,		SchemaEntry("numeric_measure",NULL )
,		SchemaEntry("organization_item",NULL )
,		SchemaEntry("orientation_basis_select",NULL )
,		SchemaEntry("parameter_value",NULL )
,		SchemaEntry("pcurve_or_surface",NULL )
,		SchemaEntry("person_and_organization_item",NULL )
,		SchemaEntry("person_organization_select",NULL )
,		SchemaEntry("picture_representation_item_select",NULL )
,		SchemaEntry("plane_angle_measure",NULL )
,		SchemaEntry("plane_or_planar_box",NULL )
,		SchemaEntry("point_and_vector_member",NULL )
,		SchemaEntry("point_and_vector_members",NULL )
,		SchemaEntry("point_path_members",NULL )
,		SchemaEntry("positive_integer",NULL )
,		SchemaEntry("positive_length_measure",NULL )
,		SchemaEntry("positive_plane_angle_measure",NULL )
,		SchemaEntry("positive_ratio_measure",NULL )
,		SchemaEntry("power_measure",NULL )
,		SchemaEntry("preferred_surface_curve_representation",NULL )
,		SchemaEntry("presentable_text",NULL )
,		SchemaEntry("presentation_representation_select",NULL )
,		SchemaEntry("presentation_size_assignment_select",NULL )
,		SchemaEntry("presentation_style_select",NULL )
,		SchemaEntry("presented_item_select",NULL )
,		SchemaEntry("pressure_measure",NULL )
,		SchemaEntry("product_definition_or_assembly_relationship",NULL )
,		SchemaEntry("product_definition_or_breakdown_element_usage",NULL )
,		SchemaEntry("product_definition_or_product_definition_relationship",NULL )
,		SchemaEntry("product_or_formation_or_definition",NULL )
,		SchemaEntry("project_item",NULL )
,		SchemaEntry("radioactivity_measure",NULL )
,		SchemaEntry("ratio_measure",NULL )
,		SchemaEntry("rendering_properties_select",NULL )
,		SchemaEntry("represented_definition",NULL )
,		SchemaEntry("requirement_assigned_item",NULL )
,		SchemaEntry("requirement_satisfaction_item",NULL )
,		SchemaEntry("requirement_source_item",NULL )
,		SchemaEntry("resistance_measure",NULL )
,		SchemaEntry("reversible_topology",NULL )
,		SchemaEntry("reversible_topology_item",NULL )
,		SchemaEntry("role_select",NULL )
,		SchemaEntry("rule_superseded_item",NULL )
,		SchemaEntry("second_in_minute",NULL )
,		SchemaEntry("security_classification_item",NULL )
,		SchemaEntry("set_of_reversible_topology_item",NULL )
,		SchemaEntry("set_representation_item",NULL )
,		SchemaEntry("shading_curve_method",NULL )
,		SchemaEntry("shading_surface_method",NULL )
,		SchemaEntry("shape_definition",NULL )
,		SchemaEntry("shell",NULL )
,		SchemaEntry("si_prefix",NULL )
,		SchemaEntry("si_unit_name",NULL )
,		SchemaEntry("size_select",NULL )
,		SchemaEntry("sketch_basis_select",NULL )
,		SchemaEntry("solid_angle_measure",NULL )
,		SchemaEntry("source",NULL )
,		SchemaEntry("source_item",NULL )
,		SchemaEntry("start_request_item",NULL )
,		SchemaEntry("string_representation_item_select",NULL )
,		SchemaEntry("style_context_select",NULL )
,		SchemaEntry("surface_side",NULL )
,		SchemaEntry("surface_side_style_select",NULL )
,		SchemaEntry("surface_style_element_select",NULL )
,		SchemaEntry("symbol_style_select",NULL )
,		SchemaEntry("text",NULL )
,		SchemaEntry("text_alignment",NULL )
,		SchemaEntry("text_delineation",NULL )
,		SchemaEntry("text_or_character",NULL )
,		SchemaEntry("text_path",NULL )
,		SchemaEntry("text_string_representation_item",NULL )
,		SchemaEntry("thermodynamic_temperature_measure",NULL )
,		SchemaEntry("time_interval_item",NULL )
,		SchemaEntry("time_measure",NULL )
,		SchemaEntry("tolerance_method_definition",NULL )
,		SchemaEntry("transformation",NULL )
,		SchemaEntry("transition_code",NULL )
,		SchemaEntry("trim_condition_select",NULL )
,		SchemaEntry("trim_intent",NULL )
,		SchemaEntry("trimming_preference",NULL )
,		SchemaEntry("trimming_select",NULL )
,		SchemaEntry("u_direction_count",NULL )
,		SchemaEntry("unit",NULL )
,		SchemaEntry("v_direction_count",NULL )
,		SchemaEntry("value_qualifier",NULL )
,		SchemaEntry("vector_or_direction",NULL )
,		SchemaEntry("velocity_measure",NULL )
,		SchemaEntry("volume_measure",NULL )
,		SchemaEntry("week_in_year_number",NULL )
,		SchemaEntry("work_item",NULL )
,		SchemaEntry("year_number",NULL )
,		SchemaEntry("measure_with_unit",&STEP::ObjectHelper<measure_with_unit,2>::Construct )
,		SchemaEntry("absorbed_dose_measure_with_unit",&STEP::ObjectHelper<absorbed_dose_measure_with_unit,0>::Construct )
,		SchemaEntry("derived_unit",&STEP::ObjectHelper<derived_unit,1>::Construct )
,		SchemaEntry("absorbed_dose_unit",&STEP::ObjectHelper<absorbed_dose_unit,0>::Construct )
,		SchemaEntry("abstract_variable",&STEP::ObjectHelper<abstract_variable,0>::Construct )
,		SchemaEntry("acceleration_measure_with_unit",&STEP::ObjectHelper<acceleration_measure_with_unit,0>::Construct )
,		SchemaEntry("acceleration_unit",&STEP::ObjectHelper<acceleration_unit,0>::Construct )
,		SchemaEntry("action",&STEP::ObjectHelper<action,3>::Construct )
,		SchemaEntry("action_assignment",&STEP::ObjectHelper<action_assignment,1>::Construct )
,		SchemaEntry("action_directive",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("action_method",&STEP::ObjectHelper<action_method,4>::Construct )
,		SchemaEntry("action_method_assignment",&STEP::ObjectHelper<action_method_assignment,2>::Construct )
,		SchemaEntry("action_method_relationship",&STEP::ObjectHelper<action_method_relationship,4>::Construct )
,		SchemaEntry("action_method_role",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("action_property",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("action_property_representation",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("action_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("action_request_assignment",&STEP::ObjectHelper<action_request_assignment,1>::Construct )
,		SchemaEntry("action_request_solution",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("action_request_status",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("action_status",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("address",&STEP::ObjectHelper<address,12>::Construct )
,		SchemaEntry("representation",&STEP::ObjectHelper<representation,3>::Construct )
,		SchemaEntry("shape_representation",&STEP::ObjectHelper<shape_representation,0>::Construct )
,		SchemaEntry("advanced_brep_shape_representation",&STEP::ObjectHelper<advanced_brep_shape_representation,0>::Construct )
,		SchemaEntry("face_surface",&STEP::ObjectHelper<face_surface,2>::Construct )
,		SchemaEntry("advanced_face",&STEP::ObjectHelper<advanced_face,0>::Construct )
,		SchemaEntry("alternate_product_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("amount_of_substance_measure_with_unit",&STEP::ObjectHelper<amount_of_substance_measure_with_unit,0>::Construct )
,		SchemaEntry("named_unit",&STEP::ObjectHelper<named_unit,1>::Construct )
,		SchemaEntry("amount_of_substance_unit",&STEP::ObjectHelper<amount_of_substance_unit,0>::Construct )
,		SchemaEntry("angle_direction_reference",&STEP::ObjectHelper<angle_direction_reference,0>::Construct )
,		SchemaEntry("representation_item",&STEP::ObjectHelper<representation_item,1>::Construct )
,		SchemaEntry("geometric_representation_item",&STEP::ObjectHelper<geometric_representation_item,0>::Construct )
,		SchemaEntry("draughting_callout",&STEP::ObjectHelper<draughting_callout,1>::Construct )
,		SchemaEntry("dimension_curve_directed_callout",&STEP::ObjectHelper<dimension_curve_directed_callout,0>::Construct )
,		SchemaEntry("angular_dimension",&STEP::ObjectHelper<angular_dimension,0>::Construct )
,		SchemaEntry("shape_aspect_relationship",&STEP::ObjectHelper<shape_aspect_relationship,4>::Construct )
,		SchemaEntry("dimensional_location",&STEP::ObjectHelper<dimensional_location,0>::Construct )
,		SchemaEntry("angular_location",&STEP::ObjectHelper<angular_location,1>::Construct )
,		SchemaEntry("dimensional_size",&STEP::ObjectHelper<dimensional_size,2>::Construct )
,		SchemaEntry("angular_size",&STEP::ObjectHelper<angular_size,1>::Construct )
,		SchemaEntry("geometric_tolerance",&STEP::ObjectHelper<geometric_tolerance,4>::Construct )
,		SchemaEntry("geometric_tolerance_with_datum_reference",&STEP::ObjectHelper<geometric_tolerance_with_datum_reference,1>::Construct )
,		SchemaEntry("angularity_tolerance",&STEP::ObjectHelper<angularity_tolerance,0>::Construct )
,		SchemaEntry("styled_item",&STEP::ObjectHelper<styled_item,2>::Construct )
,		SchemaEntry("annotation_occurrence",&STEP::ObjectHelper<annotation_occurrence,0>::Construct )
,		SchemaEntry("annotation_curve_occurrence",&STEP::ObjectHelper<annotation_curve_occurrence,0>::Construct )
,		SchemaEntry("annotation_fill_area",&STEP::ObjectHelper<annotation_fill_area,1>::Construct )
,		SchemaEntry("annotation_fill_area_occurrence",&STEP::ObjectHelper<annotation_fill_area_occurrence,1>::Construct )
,		SchemaEntry("annotation_occurrence_relationship",&STEP::ObjectHelper<annotation_occurrence_relationship,4>::Construct )
,		SchemaEntry("annotation_occurrence_associativity",&STEP::ObjectHelper<annotation_occurrence_associativity,0>::Construct )
,		SchemaEntry("annotation_plane",&STEP::ObjectHelper<annotation_plane,1>::Construct )
,		SchemaEntry("annotation_symbol_occurrence",&STEP::ObjectHelper<annotation_symbol_occurrence,0>::Construct )
,		SchemaEntry("annotation_subfigure_occurrence",&STEP::ObjectHelper<annotation_subfigure_occurrence,0>::Construct )
,		SchemaEntry("mapped_item",&STEP::ObjectHelper<mapped_item,2>::Construct )
,		SchemaEntry("annotation_symbol",&STEP::ObjectHelper<annotation_symbol,0>::Construct )
,		SchemaEntry("annotation_text",&STEP::ObjectHelper<annotation_text,0>::Construct )
,		SchemaEntry("annotation_text_character",&STEP::ObjectHelper<annotation_text_character,1>::Construct )
,		SchemaEntry("annotation_text_occurrence",&STEP::ObjectHelper<annotation_text_occurrence,0>::Construct )
,		SchemaEntry("shape_aspect",&STEP::ObjectHelper<shape_aspect,4>::Construct )
,		SchemaEntry("derived_shape_aspect",&STEP::ObjectHelper<derived_shape_aspect,0>::Construct )
,		SchemaEntry("apex",&STEP::ObjectHelper<apex,0>::Construct )
,		SchemaEntry("application_context",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("application_context_element",&STEP::ObjectHelper<application_context_element,2>::Construct )
,		SchemaEntry("application_protocol_definition",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("applied_action_assignment",&STEP::ObjectHelper<applied_action_assignment,1>::Construct )
,		SchemaEntry("applied_action_method_assignment",&STEP::ObjectHelper<applied_action_method_assignment,1>::Construct )
,		SchemaEntry("applied_action_request_assignment",&STEP::ObjectHelper<applied_action_request_assignment,1>::Construct )
,		SchemaEntry("approval_assignment",&STEP::ObjectHelper<approval_assignment,1>::Construct )
,		SchemaEntry("applied_approval_assignment",&STEP::ObjectHelper<applied_approval_assignment,1>::Construct )
,		SchemaEntry("attribute_classification_assignment",&STEP::ObjectHelper<attribute_classification_assignment,3>::Construct )
,		SchemaEntry("applied_attribute_classification_assignment",&STEP::ObjectHelper<applied_attribute_classification_assignment,1>::Construct )
,		SchemaEntry("certification_assignment",&STEP::ObjectHelper<certification_assignment,1>::Construct )
,		SchemaEntry("applied_certification_assignment",&STEP::ObjectHelper<applied_certification_assignment,1>::Construct )
,		SchemaEntry("classification_assignment",&STEP::ObjectHelper<classification_assignment,2>::Construct )
,		SchemaEntry("applied_classification_assignment",&STEP::ObjectHelper<applied_classification_assignment,1>::Construct )
,		SchemaEntry("contract_assignment",&STEP::ObjectHelper<contract_assignment,1>::Construct )
,		SchemaEntry("applied_contract_assignment",&STEP::ObjectHelper<applied_contract_assignment,1>::Construct )
,		SchemaEntry("date_and_time_assignment",&STEP::ObjectHelper<date_and_time_assignment,2>::Construct )
,		SchemaEntry("applied_date_and_time_assignment",&STEP::ObjectHelper<applied_date_and_time_assignment,1>::Construct )
,		SchemaEntry("date_assignment",&STEP::ObjectHelper<date_assignment,2>::Construct )
,		SchemaEntry("applied_date_assignment",&STEP::ObjectHelper<applied_date_assignment,1>::Construct )
,		SchemaEntry("document_reference",&STEP::ObjectHelper<document_reference,2>::Construct )
,		SchemaEntry("applied_document_reference",&STEP::ObjectHelper<applied_document_reference,1>::Construct )
,		SchemaEntry("document_usage_constraint_assignment",&STEP::ObjectHelper<document_usage_constraint_assignment,2>::Construct )
,		SchemaEntry("applied_document_usage_constraint_assignment",&STEP::ObjectHelper<applied_document_usage_constraint_assignment,1>::Construct )
,		SchemaEntry("effectivity_assignment",&STEP::ObjectHelper<effectivity_assignment,1>::Construct )
,		SchemaEntry("applied_effectivity_assignment",&STEP::ObjectHelper<applied_effectivity_assignment,1>::Construct )
,		SchemaEntry("event_occurrence_assignment",&STEP::ObjectHelper<event_occurrence_assignment,2>::Construct )
,		SchemaEntry("applied_event_occurrence_assignment",&STEP::ObjectHelper<applied_event_occurrence_assignment,1>::Construct )
,		SchemaEntry("identification_assignment",&STEP::ObjectHelper<identification_assignment,2>::Construct )
,		SchemaEntry("external_identification_assignment",&STEP::ObjectHelper<external_identification_assignment,1>::Construct )
,		SchemaEntry("applied_external_identification_assignment",&STEP::ObjectHelper<applied_external_identification_assignment,1>::Construct )
,		SchemaEntry("group_assignment",&STEP::ObjectHelper<group_assignment,1>::Construct )
,		SchemaEntry("applied_group_assignment",&STEP::ObjectHelper<applied_group_assignment,1>::Construct )
,		SchemaEntry("applied_identification_assignment",&STEP::ObjectHelper<applied_identification_assignment,1>::Construct )
,		SchemaEntry("name_assignment",&STEP::ObjectHelper<name_assignment,1>::Construct )
,		SchemaEntry("applied_name_assignment",&STEP::ObjectHelper<applied_name_assignment,1>::Construct )
,		SchemaEntry("organization_assignment",&STEP::ObjectHelper<organization_assignment,2>::Construct )
,		SchemaEntry("applied_organization_assignment",&STEP::ObjectHelper<applied_organization_assignment,1>::Construct )
,		SchemaEntry("organizational_project_assignment",&STEP::ObjectHelper<organizational_project_assignment,2>::Construct )
,		SchemaEntry("applied_organizational_project_assignment",&STEP::ObjectHelper<applied_organizational_project_assignment,1>::Construct )
,		SchemaEntry("person_and_organization_assignment",&STEP::ObjectHelper<person_and_organization_assignment,2>::Construct )
,		SchemaEntry("applied_person_and_organization_assignment",&STEP::ObjectHelper<applied_person_and_organization_assignment,1>::Construct )
,		SchemaEntry("presented_item",&STEP::ObjectHelper<presented_item,0>::Construct )
,		SchemaEntry("applied_presented_item",&STEP::ObjectHelper<applied_presented_item,1>::Construct )
,		SchemaEntry("security_classification_assignment",&STEP::ObjectHelper<security_classification_assignment,1>::Construct )
,		SchemaEntry("applied_security_classification_assignment",&STEP::ObjectHelper<applied_security_classification_assignment,1>::Construct )
,		SchemaEntry("time_interval_assignment",&STEP::ObjectHelper<time_interval_assignment,2>::Construct )
,		SchemaEntry("applied_time_interval_assignment",&STEP::ObjectHelper<applied_time_interval_assignment,1>::Construct )
,		SchemaEntry("applied_usage_right",&STEP::ObjectHelper<applied_usage_right,0>::Construct )
,		SchemaEntry("approval",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("approval_date_time",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("approval_person_organization",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("approval_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("approval_role",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("approval_status",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("area_in_set",&STEP::ObjectHelper<area_in_set,2>::Construct )
,		SchemaEntry("area_measure_with_unit",&STEP::ObjectHelper<area_measure_with_unit,0>::Construct )
,		SchemaEntry("area_unit",&STEP::ObjectHelper<area_unit,0>::Construct )
,		SchemaEntry("product_definition_relationship",&STEP::ObjectHelper<product_definition_relationship,5>::Construct )
,		SchemaEntry("product_definition_usage",&STEP::ObjectHelper<product_definition_usage,0>::Construct )
,		SchemaEntry("assembly_component_usage",&STEP::ObjectHelper<assembly_component_usage,1>::Construct )
,		SchemaEntry("assembly_component_usage_substitute",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("assigned_requirement",&STEP::ObjectHelper<assigned_requirement,1>::Construct )
,		SchemaEntry("compound_representation_item",&STEP::ObjectHelper<compound_representation_item,1>::Construct )
,		SchemaEntry("atomic_formula",&STEP::ObjectHelper<atomic_formula,0>::Construct )
,		SchemaEntry("attribute_assertion",&STEP::ObjectHelper<attribute_assertion,0>::Construct )
,		SchemaEntry("attribute_language_assignment",&STEP::ObjectHelper<attribute_language_assignment,1>::Construct )
,		SchemaEntry("attribute_value_assignment",&STEP::ObjectHelper<attribute_value_assignment,3>::Construct )
,		SchemaEntry("attribute_value_role",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("auxiliary_geometric_representation_item",&STEP::ObjectHelper<auxiliary_geometric_representation_item,0>::Construct )
,		SchemaEntry("placement",&STEP::ObjectHelper<placement,1>::Construct )
,		SchemaEntry("axis1_placement",&STEP::ObjectHelper<axis1_placement,1>::Construct )
,		SchemaEntry("axis2_placement_2d",&STEP::ObjectHelper<axis2_placement_2d,1>::Construct )
,		SchemaEntry("axis2_placement_3d",&STEP::ObjectHelper<axis2_placement_3d,2>::Construct )
,		SchemaEntry("curve",&STEP::ObjectHelper<curve,0>::Construct )
,		SchemaEntry("bounded_curve",&STEP::ObjectHelper<bounded_curve,0>::Construct )
,		SchemaEntry("b_spline_curve",&STEP::ObjectHelper<b_spline_curve,5>::Construct )
,		SchemaEntry("b_spline_curve_with_knots",&STEP::ObjectHelper<b_spline_curve_with_knots,3>::Construct )
,		SchemaEntry("surface",&STEP::ObjectHelper<surface,0>::Construct )
,		SchemaEntry("bounded_surface",&STEP::ObjectHelper<bounded_surface,0>::Construct )
,		SchemaEntry("b_spline_surface",&STEP::ObjectHelper<b_spline_surface,6>::Construct )
,		SchemaEntry("b_spline_surface_with_knots",&STEP::ObjectHelper<b_spline_surface_with_knots,5>::Construct )
,		SchemaEntry("product_definition",&STEP::ObjectHelper<product_definition,4>::Construct )
,		SchemaEntry("rule_software_definition",&STEP::ObjectHelper<rule_software_definition,0>::Construct )
,		SchemaEntry("rule_definition",&STEP::ObjectHelper<rule_definition,0>::Construct )
,		SchemaEntry("back_chaining_rule",&STEP::ObjectHelper<back_chaining_rule,0>::Construct )
,		SchemaEntry("back_chaining_rule_body",&STEP::ObjectHelper<back_chaining_rule_body,0>::Construct )
,		SchemaEntry("colour",&STEP::ObjectHelper<colour,0>::Construct )
,		SchemaEntry("background_colour",&STEP::ObjectHelper<background_colour,1>::Construct )
,		SchemaEntry("beveled_sheet_representation",&STEP::ObjectHelper<beveled_sheet_representation,0>::Construct )
,		SchemaEntry("bezier_curve",&STEP::ObjectHelper<bezier_curve,0>::Construct )
,		SchemaEntry("bezier_surface",&STEP::ObjectHelper<bezier_surface,0>::Construct )
,		SchemaEntry("generic_expression",&STEP::ObjectHelper<generic_expression,0>::Construct )
,		SchemaEntry("binary_generic_expression",&STEP::ObjectHelper<binary_generic_expression,1>::Construct )
,		SchemaEntry("binary_numeric_expression",&STEP::ObjectHelper<binary_numeric_expression,0>::Construct )
,		SchemaEntry("binary_representation_item",&STEP::ObjectHelper<binary_representation_item,1>::Construct )
,		SchemaEntry("block",&STEP::ObjectHelper<block,4>::Construct )
,		SchemaEntry("expression",&STEP::ObjectHelper<expression,0>::Construct )
,		SchemaEntry("boolean_expression",&STEP::ObjectHelper<boolean_expression,0>::Construct )
,		SchemaEntry("boolean_literal",&STEP::ObjectHelper<boolean_literal,1>::Construct )
,		SchemaEntry("boolean_representation_item",&STEP::ObjectHelper<boolean_representation_item,0>::Construct )
,		SchemaEntry("boolean_result",&STEP::ObjectHelper<boolean_result,3>::Construct )
,		SchemaEntry("composite_curve",&STEP::ObjectHelper<composite_curve,2>::Construct )
,		SchemaEntry("composite_curve_on_surface",&STEP::ObjectHelper<composite_curve_on_surface,0>::Construct )
,		SchemaEntry("boundary_curve",&STEP::ObjectHelper<boundary_curve,0>::Construct )
,		SchemaEntry("bounded_pcurve",&STEP::ObjectHelper<bounded_pcurve,0>::Construct )
,		SchemaEntry("bounded_surface_curve",&STEP::ObjectHelper<bounded_surface_curve,0>::Construct )
,		SchemaEntry("founded_item",&STEP::ObjectHelper<founded_item,0>::Construct )
,		SchemaEntry("box_domain",&STEP::ObjectHelper<box_domain,4>::Construct )
,		SchemaEntry("half_space_solid",&STEP::ObjectHelper<half_space_solid,2>::Construct )
,		SchemaEntry("boxed_half_space",&STEP::ObjectHelper<boxed_half_space,1>::Construct )
,		SchemaEntry("breakdown_context",&STEP::ObjectHelper<breakdown_context,0>::Construct )
,		SchemaEntry("breakdown_element_group_assignment",&STEP::ObjectHelper<breakdown_element_group_assignment,1>::Construct )
,		SchemaEntry("breakdown_element_realization",&STEP::ObjectHelper<breakdown_element_realization,0>::Construct )
,		SchemaEntry("breakdown_element_usage",&STEP::ObjectHelper<breakdown_element_usage,0>::Construct )
,		SchemaEntry("breakdown_of",&STEP::ObjectHelper<breakdown_of,0>::Construct )
,		SchemaEntry("solid_model",&STEP::ObjectHelper<solid_model,0>::Construct )
,		SchemaEntry("manifold_solid_brep",&STEP::ObjectHelper<manifold_solid_brep,1>::Construct )
,		SchemaEntry("brep_with_voids",&STEP::ObjectHelper<brep_with_voids,1>::Construct )
,		SchemaEntry("bytes_representation_item",&STEP::ObjectHelper<bytes_representation_item,0>::Construct )
,		SchemaEntry("date",&STEP::ObjectHelper<date,1>::Construct )
,		SchemaEntry("calendar_date",&STEP::ObjectHelper<calendar_date,2>::Construct )
,		SchemaEntry("camera_image",&STEP::ObjectHelper<camera_image,0>::Construct )
,		SchemaEntry("camera_image_3d_with_scale",&STEP::ObjectHelper<camera_image_3d_with_scale,0>::Construct )
,		SchemaEntry("camera_model",&STEP::ObjectHelper<camera_model,0>::Construct )
,		SchemaEntry("camera_model_d3",&STEP::ObjectHelper<camera_model_d3,2>::Construct )
,		SchemaEntry("camera_model_d3_multi_clipping",&STEP::ObjectHelper<camera_model_d3_multi_clipping,1>::Construct )
,		SchemaEntry("camera_model_d3_multi_clipping_intersection",&STEP::ObjectHelper<camera_model_d3_multi_clipping_intersection,1>::Construct )
,		SchemaEntry("camera_model_d3_multi_clipping_union",&STEP::ObjectHelper<camera_model_d3_multi_clipping_union,1>::Construct )
,		SchemaEntry("camera_model_d3_with_hlhsr",&STEP::ObjectHelper<camera_model_d3_with_hlhsr,1>::Construct )
,		SchemaEntry("camera_model_with_light_sources",&STEP::ObjectHelper<camera_model_with_light_sources,1>::Construct )
,		SchemaEntry("representation_map",&STEP::ObjectHelper<representation_map,2>::Construct )
,		SchemaEntry("camera_usage",&STEP::ObjectHelper<camera_usage,0>::Construct )
,		SchemaEntry("capacitance_measure_with_unit",&STEP::ObjectHelper<capacitance_measure_with_unit,0>::Construct )
,		SchemaEntry("capacitance_unit",&STEP::ObjectHelper<capacitance_unit,0>::Construct )
,		SchemaEntry("point",&STEP::ObjectHelper<point,0>::Construct )
,		SchemaEntry("cartesian_point",&STEP::ObjectHelper<cartesian_point,1>::Construct )
,		SchemaEntry("cartesian_transformation_operator",&STEP::ObjectHelper<cartesian_transformation_operator,4>::Construct )
,		SchemaEntry("cartesian_transformation_operator_2d",&STEP::ObjectHelper<cartesian_transformation_operator_2d,0>::Construct )
,		SchemaEntry("cartesian_transformation_operator_3d",&STEP::ObjectHelper<cartesian_transformation_operator_3d,1>::Construct )
,		SchemaEntry("cc_design_approval",&STEP::ObjectHelper<cc_design_approval,1>::Construct )
,		SchemaEntry("cc_design_certification",&STEP::ObjectHelper<cc_design_certification,1>::Construct )
,		SchemaEntry("cc_design_contract",&STEP::ObjectHelper<cc_design_contract,1>::Construct )
,		SchemaEntry("cc_design_date_and_time_assignment",&STEP::ObjectHelper<cc_design_date_and_time_assignment,1>::Construct )
,		SchemaEntry("cc_design_person_and_organization_assignment",&STEP::ObjectHelper<cc_design_person_and_organization_assignment,1>::Construct )
,		SchemaEntry("cc_design_security_classification",&STEP::ObjectHelper<cc_design_security_classification,1>::Construct )
,		SchemaEntry("cc_design_specification_reference",&STEP::ObjectHelper<cc_design_specification_reference,1>::Construct )
,		SchemaEntry("celsius_temperature_measure_with_unit",&STEP::ObjectHelper<celsius_temperature_measure_with_unit,0>::Construct )
,		SchemaEntry("centre_of_symmetry",&STEP::ObjectHelper<centre_of_symmetry,0>::Construct )
,		SchemaEntry("certification",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("certification_type",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("change",&STEP::ObjectHelper<change,1>::Construct )
,		SchemaEntry("change_request",&STEP::ObjectHelper<change_request,1>::Construct )
,		SchemaEntry("character_glyph_font_usage",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("character_glyph_style_outline",&STEP::ObjectHelper<character_glyph_style_outline,1>::Construct )
,		SchemaEntry("character_glyph_style_stroke",&STEP::ObjectHelper<character_glyph_style_stroke,1>::Construct )
,		SchemaEntry("symbol_representation",&STEP::ObjectHelper<symbol_representation,0>::Construct )
,		SchemaEntry("generic_character_glyph_symbol",&STEP::ObjectHelper<generic_character_glyph_symbol,0>::Construct )
,		SchemaEntry("character_glyph_symbol",&STEP::ObjectHelper<character_glyph_symbol,2>::Construct )
,		SchemaEntry("character_glyph_symbol_outline",&STEP::ObjectHelper<character_glyph_symbol_outline,1>::Construct )
,		SchemaEntry("character_glyph_symbol_stroke",&STEP::ObjectHelper<character_glyph_symbol_stroke,1>::Construct )
,		SchemaEntry("general_property",&STEP::ObjectHelper<general_property,3>::Construct )
,		SchemaEntry("characteristic_data_column_header",&STEP::ObjectHelper<characteristic_data_column_header,0>::Construct )
,		SchemaEntry("general_property_relationship",&STEP::ObjectHelper<general_property_relationship,4>::Construct )
,		SchemaEntry("characteristic_data_column_header_link",&STEP::ObjectHelper<characteristic_data_column_header_link,0>::Construct )
,		SchemaEntry("characteristic_data_table_header",&STEP::ObjectHelper<characteristic_data_table_header,0>::Construct )
,		SchemaEntry("characteristic_data_table_header_decomposition",&STEP::ObjectHelper<characteristic_data_table_header_decomposition,0>::Construct )
,		SchemaEntry("group",&STEP::ObjectHelper<group,2>::Construct )
,		SchemaEntry("characteristic_type",&STEP::ObjectHelper<characteristic_type,0>::Construct )
,		SchemaEntry("characterized_class",&STEP::ObjectHelper<characterized_class,0>::Construct )
,		SchemaEntry("characterized_object",&STEP::ObjectHelper<characterized_object,2>::Construct )
,		SchemaEntry("conic",&STEP::ObjectHelper<conic,1>::Construct )
,		SchemaEntry("circle",&STEP::ObjectHelper<circle,1>::Construct )
,		SchemaEntry("circular_runout_tolerance",&STEP::ObjectHelper<circular_runout_tolerance,0>::Construct )
,		SchemaEntry("class_t",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("class_by_extension",&STEP::ObjectHelper<class_by_extension,0>::Construct )
,		SchemaEntry("class_by_intension",&STEP::ObjectHelper<class_by_intension,0>::Construct )
,		SchemaEntry("class_system",&STEP::ObjectHelper<class_system,0>::Construct )
,		SchemaEntry("effectivity_context_assignment",&STEP::ObjectHelper<effectivity_context_assignment,2>::Construct )
,		SchemaEntry("class_usage_effectivity_context_assignment",&STEP::ObjectHelper<class_usage_effectivity_context_assignment,1>::Construct )
,		SchemaEntry("classification_role",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("topological_representation_item",&STEP::ObjectHelper<topological_representation_item,0>::Construct )
,		SchemaEntry("connected_face_set",&STEP::ObjectHelper<connected_face_set,1>::Construct )
,		SchemaEntry("closed_shell",&STEP::ObjectHelper<closed_shell,0>::Construct )
,		SchemaEntry("coaxiality_tolerance",&STEP::ObjectHelper<coaxiality_tolerance,0>::Construct )
,		SchemaEntry("colour_specification",&STEP::ObjectHelper<colour_specification,1>::Construct )
,		SchemaEntry("colour_rgb",&STEP::ObjectHelper<colour_rgb,3>::Construct )
,		SchemaEntry("common_datum",&STEP::ObjectHelper<common_datum,0>::Construct )
,		SchemaEntry("comparison_expression",&STEP::ObjectHelper<comparison_expression,0>::Construct )
,		SchemaEntry("complex_clause",&STEP::ObjectHelper<complex_clause,0>::Construct )
,		SchemaEntry("complex_conjunctive_clause",&STEP::ObjectHelper<complex_conjunctive_clause,0>::Construct )
,		SchemaEntry("complex_disjunctive_clause",&STEP::ObjectHelper<complex_disjunctive_clause,0>::Construct )
,		SchemaEntry("modified_solid",&STEP::ObjectHelper<modified_solid,2>::Construct )
,		SchemaEntry("shelled_solid",&STEP::ObjectHelper<shelled_solid,2>::Construct )
,		SchemaEntry("complex_shelled_solid",&STEP::ObjectHelper<complex_shelled_solid,1>::Construct )
,		SchemaEntry("composite_assembly_definition",&STEP::ObjectHelper<composite_assembly_definition,0>::Construct )
,		SchemaEntry("composite_assembly_sequence_definition",&STEP::ObjectHelper<composite_assembly_sequence_definition,0>::Construct )
,		SchemaEntry("laminate_table",&STEP::ObjectHelper<laminate_table,0>::Construct )
,		SchemaEntry("part_laminate_table",&STEP::ObjectHelper<part_laminate_table,0>::Construct )
,		SchemaEntry("composite_assembly_table",&STEP::ObjectHelper<composite_assembly_table,0>::Construct )
,		SchemaEntry("composite_curve_segment",&STEP::ObjectHelper<composite_curve_segment,3>::Construct )
,		SchemaEntry("material_designation",&STEP::ObjectHelper<material_designation,2>::Construct )
,		SchemaEntry("composite_material_designation",&STEP::ObjectHelper<composite_material_designation,0>::Construct )
,		SchemaEntry("composite_shape_aspect",&STEP::ObjectHelper<composite_shape_aspect,0>::Construct )
,		SchemaEntry("composite_sheet_representation",&STEP::ObjectHelper<composite_sheet_representation,0>::Construct )
,		SchemaEntry("composite_text",&STEP::ObjectHelper<composite_text,1>::Construct )
,		SchemaEntry("composite_text_with_associated_curves",&STEP::ObjectHelper<composite_text_with_associated_curves,1>::Construct )
,		SchemaEntry("composite_text_with_blanking_box",&STEP::ObjectHelper<composite_text_with_blanking_box,1>::Construct )
,		SchemaEntry("composite_text_with_delineation",&STEP::ObjectHelper<composite_text_with_delineation,1>::Construct )
,		SchemaEntry("composite_text_with_extent",&STEP::ObjectHelper<composite_text_with_extent,1>::Construct )
,		SchemaEntry("compound_shape_representation",&STEP::ObjectHelper<compound_shape_representation,0>::Construct )
,		SchemaEntry("concentricity_tolerance",&STEP::ObjectHelper<concentricity_tolerance,0>::Construct )
,		SchemaEntry("concept_feature_operator",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("concept_feature_relationship",&STEP::ObjectHelper<concept_feature_relationship,4>::Construct )
,		SchemaEntry("concept_feature_relationship_with_condition",&STEP::ObjectHelper<concept_feature_relationship_with_condition,1>::Construct )
,		SchemaEntry("product_concept_feature",&STEP::ObjectHelper<product_concept_feature,3>::Construct )
,		SchemaEntry("conditional_concept_feature",&STEP::ObjectHelper<conditional_concept_feature,1>::Construct )
,		SchemaEntry("conductance_measure_with_unit",&STEP::ObjectHelper<conductance_measure_with_unit,0>::Construct )
,		SchemaEntry("conductance_unit",&STEP::ObjectHelper<conductance_unit,0>::Construct )
,		SchemaEntry("configuration_item",&STEP::ObjectHelper<configuration_item,5>::Construct )
,		SchemaEntry("configurable_item",&STEP::ObjectHelper<configurable_item,1>::Construct )
,		SchemaEntry("configuration_design",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("effectivity",&STEP::ObjectHelper<effectivity,1>::Construct )
,		SchemaEntry("product_definition_effectivity",&STEP::ObjectHelper<product_definition_effectivity,1>::Construct )
,		SchemaEntry("configuration_effectivity",&STEP::ObjectHelper<configuration_effectivity,1>::Construct )
,		SchemaEntry("configuration_item_relationship",&STEP::ObjectHelper<configuration_item_relationship,4>::Construct )
,		SchemaEntry("configuration_item_hierarchical_relationship",&STEP::ObjectHelper<configuration_item_hierarchical_relationship,0>::Construct )
,		SchemaEntry("configuration_item_revision_sequence",&STEP::ObjectHelper<configuration_item_revision_sequence,0>::Construct )
,		SchemaEntry("configured_effectivity_assignment",&STEP::ObjectHelper<configured_effectivity_assignment,1>::Construct )
,		SchemaEntry("configured_effectivity_context_assignment",&STEP::ObjectHelper<configured_effectivity_context_assignment,1>::Construct )
,		SchemaEntry("conical_stepped_hole_transition",&STEP::ObjectHelper<conical_stepped_hole_transition,3>::Construct )
,		SchemaEntry("elementary_surface",&STEP::ObjectHelper<elementary_surface,1>::Construct )
,		SchemaEntry("conical_surface",&STEP::ObjectHelper<conical_surface,2>::Construct )
,		SchemaEntry("connected_edge_set",&STEP::ObjectHelper<connected_edge_set,1>::Construct )
,		SchemaEntry("connected_face_sub_set",&STEP::ObjectHelper<connected_face_sub_set,1>::Construct )
,		SchemaEntry("constructive_geometry_representation",&STEP::ObjectHelper<constructive_geometry_representation,0>::Construct )
,		SchemaEntry("representation_relationship",&STEP::ObjectHelper<representation_relationship,4>::Construct )
,		SchemaEntry("constructive_geometry_representation_relationship",&STEP::ObjectHelper<constructive_geometry_representation_relationship,0>::Construct )
,		SchemaEntry("contact_ratio_representation",&STEP::ObjectHelper<contact_ratio_representation,0>::Construct )
,		SchemaEntry("invisibility",&STEP::ObjectHelper<invisibility,1>::Construct )
,		SchemaEntry("context_dependent_invisibility",&STEP::ObjectHelper<context_dependent_invisibility,1>::Construct )
,		SchemaEntry("over_riding_styled_item",&STEP::ObjectHelper<over_riding_styled_item,1>::Construct )
,		SchemaEntry("context_dependent_over_riding_styled_item",&STEP::ObjectHelper<context_dependent_over_riding_styled_item,1>::Construct )
,		SchemaEntry("context_dependent_shape_representation",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("context_dependent_unit",&STEP::ObjectHelper<context_dependent_unit,1>::Construct )
,		SchemaEntry("contract",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("contract_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("contract_type",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("conversion_based_unit",&STEP::ObjectHelper<conversion_based_unit,2>::Construct )
,		SchemaEntry("coordinated_universal_time_offset",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("csg_shape_representation",&STEP::ObjectHelper<csg_shape_representation,0>::Construct )
,		SchemaEntry("csg_solid",&STEP::ObjectHelper<csg_solid,1>::Construct )
,		SchemaEntry("currency",&STEP::ObjectHelper<currency,0>::Construct )
,		SchemaEntry("currency_measure_with_unit",&STEP::ObjectHelper<currency_measure_with_unit,0>::Construct )
,		SchemaEntry("curve_bounded_surface",&STEP::ObjectHelper<curve_bounded_surface,3>::Construct )
,		SchemaEntry("curve_dimension",&STEP::ObjectHelper<curve_dimension,0>::Construct )
,		SchemaEntry("curve_replica",&STEP::ObjectHelper<curve_replica,2>::Construct )
,		SchemaEntry("curve_style",&STEP::ObjectHelper<curve_style,4>::Construct )
,		SchemaEntry("curve_style_font",&STEP::ObjectHelper<curve_style_font,2>::Construct )
,		SchemaEntry("curve_style_font_and_scaling",&STEP::ObjectHelper<curve_style_font_and_scaling,3>::Construct )
,		SchemaEntry("curve_style_font_pattern",&STEP::ObjectHelper<curve_style_font_pattern,2>::Construct )
,		SchemaEntry("curve_style_rendering",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("curve_swept_solid_shape_representation",&STEP::ObjectHelper<curve_swept_solid_shape_representation,0>::Construct )
,		SchemaEntry("cylindrical_surface",&STEP::ObjectHelper<cylindrical_surface,1>::Construct )
,		SchemaEntry("cylindricity_tolerance",&STEP::ObjectHelper<cylindricity_tolerance,0>::Construct )
,		SchemaEntry("data_environment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("date_and_time",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("date_representation_item",&STEP::ObjectHelper<date_representation_item,0>::Construct )
,		SchemaEntry("date_role",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("date_time_representation_item",&STEP::ObjectHelper<date_time_representation_item,0>::Construct )
,		SchemaEntry("date_time_role",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("dated_effectivity",&STEP::ObjectHelper<dated_effectivity,2>::Construct )
,		SchemaEntry("datum",&STEP::ObjectHelper<datum,1>::Construct )
,		SchemaEntry("datum_feature",&STEP::ObjectHelper<datum_feature,0>::Construct )
,		SchemaEntry("datum_feature_callout",&STEP::ObjectHelper<datum_feature_callout,0>::Construct )
,		SchemaEntry("datum_reference",&STEP::ObjectHelper<datum_reference,2>::Construct )
,		SchemaEntry("datum_target",&STEP::ObjectHelper<datum_target,1>::Construct )
,		SchemaEntry("datum_target_callout",&STEP::ObjectHelper<datum_target_callout,0>::Construct )
,		SchemaEntry("default_tolerance_table",&STEP::ObjectHelper<default_tolerance_table,0>::Construct )
,		SchemaEntry("default_tolerance_table_cell",&STEP::ObjectHelper<default_tolerance_table_cell,0>::Construct )
,		SchemaEntry("defined_symbol",&STEP::ObjectHelper<defined_symbol,2>::Construct )
,		SchemaEntry("definitional_representation",&STEP::ObjectHelper<definitional_representation,0>::Construct )
,		SchemaEntry("definitional_representation_relationship",&STEP::ObjectHelper<definitional_representation_relationship,0>::Construct )
,		SchemaEntry("definitional_representation_relationship_with_same_context",&STEP::ObjectHelper<definitional_representation_relationship_with_same_context,0>::Construct )
,		SchemaEntry("degenerate_pcurve",&STEP::ObjectHelper<degenerate_pcurve,2>::Construct )
,		SchemaEntry("toroidal_surface",&STEP::ObjectHelper<toroidal_surface,2>::Construct )
,		SchemaEntry("degenerate_toroidal_surface",&STEP::ObjectHelper<degenerate_toroidal_surface,1>::Construct )
,		SchemaEntry("derived_unit_element",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("description_attribute",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("descriptive_representation_item",&STEP::ObjectHelper<descriptive_representation_item,1>::Construct )
,		SchemaEntry("product_definition_context",&STEP::ObjectHelper<product_definition_context,1>::Construct )
,		SchemaEntry("design_context",&STEP::ObjectHelper<design_context,0>::Construct )
,		SchemaEntry("design_make_from_relationship",&STEP::ObjectHelper<design_make_from_relationship,0>::Construct )
,		SchemaEntry("diameter_dimension",&STEP::ObjectHelper<diameter_dimension,0>::Construct )
,		SchemaEntry("ratio_measure_with_unit",&STEP::ObjectHelper<ratio_measure_with_unit,0>::Construct )
,		SchemaEntry("dielectric_constant_measure_with_unit",&STEP::ObjectHelper<dielectric_constant_measure_with_unit,0>::Construct )
,		SchemaEntry("dimension_callout",&STEP::ObjectHelper<dimension_callout,0>::Construct )
,		SchemaEntry("draughting_callout_relationship",&STEP::ObjectHelper<draughting_callout_relationship,4>::Construct )
,		SchemaEntry("dimension_callout_component_relationship",&STEP::ObjectHelper<dimension_callout_component_relationship,0>::Construct )
,		SchemaEntry("dimension_callout_relationship",&STEP::ObjectHelper<dimension_callout_relationship,0>::Construct )
,		SchemaEntry("dimension_curve",&STEP::ObjectHelper<dimension_curve,0>::Construct )
,		SchemaEntry("terminator_symbol",&STEP::ObjectHelper<terminator_symbol,1>::Construct )
,		SchemaEntry("dimension_curve_terminator",&STEP::ObjectHelper<dimension_curve_terminator,1>::Construct )
,		SchemaEntry("dimension_curve_terminator_to_projection_curve_associativity",&STEP::ObjectHelper<dimension_curve_terminator_to_projection_curve_associativity,0>::Construct )
,		SchemaEntry("dimension_pair",&STEP::ObjectHelper<dimension_pair,0>::Construct )
,		SchemaEntry("dimension_related_tolerance_zone_element",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("dimension_text_associativity",&STEP::ObjectHelper<dimension_text_associativity,0>::Construct )
,		SchemaEntry("dimensional_characteristic_representation",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("dimensional_exponents",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("dimensional_location_with_path",&STEP::ObjectHelper<dimensional_location_with_path,1>::Construct )
,		SchemaEntry("dimensional_size_with_path",&STEP::ObjectHelper<dimensional_size_with_path,1>::Construct )
,		SchemaEntry("executed_action",&STEP::ObjectHelper<executed_action,0>::Construct )
,		SchemaEntry("directed_action",&STEP::ObjectHelper<directed_action,1>::Construct )
,		SchemaEntry("directed_dimensional_location",&STEP::ObjectHelper<directed_dimensional_location,0>::Construct )
,		SchemaEntry("direction",&STEP::ObjectHelper<direction,1>::Construct )
,		SchemaEntry("document",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("document_file",&STEP::ObjectHelper<document_file,0>::Construct )
,		SchemaEntry("document_identifier",&STEP::ObjectHelper<document_identifier,0>::Construct )
,		SchemaEntry("document_identifier_assignment",&STEP::ObjectHelper<document_identifier_assignment,1>::Construct )
,		SchemaEntry("document_product_association",&STEP::ObjectHelper<document_product_association,4>::Construct )
,		SchemaEntry("document_product_equivalence",&STEP::ObjectHelper<document_product_equivalence,0>::Construct )
,		SchemaEntry("document_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("document_representation_type",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("document_type",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("document_usage_constraint",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("document_usage_role",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("dose_equivalent_measure_with_unit",&STEP::ObjectHelper<dose_equivalent_measure_with_unit,0>::Construct )
,		SchemaEntry("dose_equivalent_unit",&STEP::ObjectHelper<dose_equivalent_unit,0>::Construct )
,		SchemaEntry("double_offset_shelled_solid",&STEP::ObjectHelper<double_offset_shelled_solid,1>::Construct )
,		SchemaEntry("item_defined_transformation",&STEP::ObjectHelper<item_defined_transformation,4>::Construct )
,		SchemaEntry("transformation_with_derived_angle",&STEP::ObjectHelper<transformation_with_derived_angle,0>::Construct )
,		SchemaEntry("draped_defined_transformation",&STEP::ObjectHelper<draped_defined_transformation,0>::Construct )
,		SchemaEntry("draughting_annotation_occurrence",&STEP::ObjectHelper<draughting_annotation_occurrence,0>::Construct )
,		SchemaEntry("draughting_elements",&STEP::ObjectHelper<draughting_elements,0>::Construct )
,		SchemaEntry("draughting_model",&STEP::ObjectHelper<draughting_model,0>::Construct )
,		SchemaEntry("item_identified_representation_usage",&STEP::ObjectHelper<item_identified_representation_usage,5>::Construct )
,		SchemaEntry("draughting_model_item_association",&STEP::ObjectHelper<draughting_model_item_association,0>::Construct )
,		SchemaEntry("pre_defined_colour",&STEP::ObjectHelper<pre_defined_colour,0>::Construct )
,		SchemaEntry("draughting_pre_defined_colour",&STEP::ObjectHelper<draughting_pre_defined_colour,0>::Construct )
,		SchemaEntry("pre_defined_item",&STEP::ObjectHelper<pre_defined_item,1>::Construct )
,		SchemaEntry("pre_defined_curve_font",&STEP::ObjectHelper<pre_defined_curve_font,0>::Construct )
,		SchemaEntry("draughting_pre_defined_curve_font",&STEP::ObjectHelper<draughting_pre_defined_curve_font,0>::Construct )
,		SchemaEntry("pre_defined_text_font",&STEP::ObjectHelper<pre_defined_text_font,0>::Construct )
,		SchemaEntry("draughting_pre_defined_text_font",&STEP::ObjectHelper<draughting_pre_defined_text_font,0>::Construct )
,		SchemaEntry("draughting_subfigure_representation",&STEP::ObjectHelper<draughting_subfigure_representation,0>::Construct )
,		SchemaEntry("draughting_symbol_representation",&STEP::ObjectHelper<draughting_symbol_representation,0>::Construct )
,		SchemaEntry("text_literal",&STEP::ObjectHelper<text_literal,5>::Construct )
,		SchemaEntry("text_literal_with_delineation",&STEP::ObjectHelper<text_literal_with_delineation,1>::Construct )
,		SchemaEntry("draughting_text_literal_with_delineation",&STEP::ObjectHelper<draughting_text_literal_with_delineation,0>::Construct )
,		SchemaEntry("draughting_title",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("drawing_definition",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("presentation_set",&STEP::ObjectHelper<presentation_set,0>::Construct )
,		SchemaEntry("drawing_revision",&STEP::ObjectHelper<drawing_revision,3>::Construct )
,		SchemaEntry("drawing_revision_sequence",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("presentation_representation",&STEP::ObjectHelper<presentation_representation,0>::Construct )
,		SchemaEntry("presentation_area",&STEP::ObjectHelper<presentation_area,0>::Construct )
,		SchemaEntry("drawing_sheet_revision",&STEP::ObjectHelper<drawing_sheet_revision,1>::Construct )
,		SchemaEntry("drawing_sheet_revision_sequence",&STEP::ObjectHelper<drawing_sheet_revision_sequence,0>::Construct )
,		SchemaEntry("drawing_sheet_revision_usage",&STEP::ObjectHelper<drawing_sheet_revision_usage,1>::Construct )
,		SchemaEntry("edge",&STEP::ObjectHelper<edge,2>::Construct )
,		SchemaEntry("edge_based_wireframe_model",&STEP::ObjectHelper<edge_based_wireframe_model,1>::Construct )
,		SchemaEntry("edge_based_wireframe_shape_representation",&STEP::ObjectHelper<edge_based_wireframe_shape_representation,0>::Construct )
,		SchemaEntry("edge_blended_solid",&STEP::ObjectHelper<edge_blended_solid,1>::Construct )
,		SchemaEntry("edge_curve",&STEP::ObjectHelper<edge_curve,2>::Construct )
,		SchemaEntry("edge_loop",&STEP::ObjectHelper<edge_loop,0>::Construct )
,		SchemaEntry("effectivity_context_role",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("effectivity_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("electric_charge_measure_with_unit",&STEP::ObjectHelper<electric_charge_measure_with_unit,0>::Construct )
,		SchemaEntry("electric_charge_unit",&STEP::ObjectHelper<electric_charge_unit,0>::Construct )
,		SchemaEntry("electric_current_measure_with_unit",&STEP::ObjectHelper<electric_current_measure_with_unit,0>::Construct )
,		SchemaEntry("electric_current_unit",&STEP::ObjectHelper<electric_current_unit,0>::Construct )
,		SchemaEntry("electric_potential_measure_with_unit",&STEP::ObjectHelper<electric_potential_measure_with_unit,0>::Construct )
,		SchemaEntry("electric_potential_unit",&STEP::ObjectHelper<electric_potential_unit,0>::Construct )
,		SchemaEntry("elementary_brep_shape_representation",&STEP::ObjectHelper<elementary_brep_shape_representation,0>::Construct )
,		SchemaEntry("ellipse",&STEP::ObjectHelper<ellipse,2>::Construct )
,		SchemaEntry("energy_measure_with_unit",&STEP::ObjectHelper<energy_measure_with_unit,0>::Construct )
,		SchemaEntry("energy_unit",&STEP::ObjectHelper<energy_unit,0>::Construct )
,		SchemaEntry("property_definition",&STEP::ObjectHelper<property_definition,3>::Construct )
,		SchemaEntry("fact_type",&STEP::ObjectHelper<fact_type,0>::Construct )
,		SchemaEntry("entity_assertion",&STEP::ObjectHelper<entity_assertion,0>::Construct )
,		SchemaEntry("enum_reference_prefix",&STEP::ObjectHelper<enum_reference_prefix,0>::Construct )
,		SchemaEntry("environment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("evaluated_characteristic",&STEP::ObjectHelper<evaluated_characteristic,0>::Construct )
,		SchemaEntry("evaluated_degenerate_pcurve",&STEP::ObjectHelper<evaluated_degenerate_pcurve,1>::Construct )
,		SchemaEntry("evaluation_product_definition",&STEP::ObjectHelper<evaluation_product_definition,0>::Construct )
,		SchemaEntry("event_occurrence",&STEP::ObjectHelper<event_occurrence,3>::Construct )
,		SchemaEntry("event_occurrence_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("event_occurrence_role",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("product_concept_feature_category",&STEP::ObjectHelper<product_concept_feature_category,0>::Construct )
,		SchemaEntry("exclusive_product_concept_feature_category",&STEP::ObjectHelper<exclusive_product_concept_feature_category,0>::Construct )
,		SchemaEntry("uncertainty_qualifier",&STEP::ObjectHelper<uncertainty_qualifier,2>::Construct )
,		SchemaEntry("standard_uncertainty",&STEP::ObjectHelper<standard_uncertainty,1>::Construct )
,		SchemaEntry("expanded_uncertainty",&STEP::ObjectHelper<expanded_uncertainty,1>::Construct )
,		SchemaEntry("representation_item_relationship",&STEP::ObjectHelper<representation_item_relationship,4>::Construct )
,		SchemaEntry("explicit_procedural_representation_item_relationship",&STEP::ObjectHelper<explicit_procedural_representation_item_relationship,0>::Construct )
,		SchemaEntry("explicit_procedural_geometric_representation_item_relationship",&STEP::ObjectHelper<explicit_procedural_geometric_representation_item_relationship,0>::Construct )
,		SchemaEntry("explicit_procedural_representation_relationship",&STEP::ObjectHelper<explicit_procedural_representation_relationship,0>::Construct )
,		SchemaEntry("explicit_procedural_shape_representation_relationship",&STEP::ObjectHelper<explicit_procedural_shape_representation_relationship,0>::Construct )
,		SchemaEntry("expression_conversion_based_unit",&STEP::ObjectHelper<expression_conversion_based_unit,0>::Construct )
,		SchemaEntry("extension",&STEP::ObjectHelper<extension,0>::Construct )
,		SchemaEntry("extent",&STEP::ObjectHelper<extent,0>::Construct )
,		SchemaEntry("external_source",&STEP::ObjectHelper<external_source,1>::Construct )
,		SchemaEntry("external_class_library",&STEP::ObjectHelper<external_class_library,0>::Construct )
,		SchemaEntry("external_source_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("externally_defined_class",&STEP::ObjectHelper<externally_defined_class,0>::Construct )
,		SchemaEntry("externally_defined_colour",&STEP::ObjectHelper<externally_defined_colour,0>::Construct )
,		SchemaEntry("externally_defined_context_dependent_unit",&STEP::ObjectHelper<externally_defined_context_dependent_unit,0>::Construct )
,		SchemaEntry("externally_defined_conversion_based_unit",&STEP::ObjectHelper<externally_defined_conversion_based_unit,0>::Construct )
,		SchemaEntry("externally_defined_currency",&STEP::ObjectHelper<externally_defined_currency,0>::Construct )
,		SchemaEntry("externally_defined_item",&STEP::ObjectHelper<externally_defined_item,2>::Construct )
,		SchemaEntry("externally_defined_curve_font",&STEP::ObjectHelper<externally_defined_curve_font,0>::Construct )
,		SchemaEntry("externally_defined_dimension_definition",&STEP::ObjectHelper<externally_defined_dimension_definition,0>::Construct )
,		SchemaEntry("externally_defined_general_property",&STEP::ObjectHelper<externally_defined_general_property,0>::Construct )
,		SchemaEntry("externally_defined_hatch_style",&STEP::ObjectHelper<externally_defined_hatch_style,0>::Construct )
,		SchemaEntry("externally_defined_item_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("externally_defined_marker",&STEP::ObjectHelper<externally_defined_marker,0>::Construct )
,		SchemaEntry("picture_representation_item",&STEP::ObjectHelper<picture_representation_item,0>::Construct )
,		SchemaEntry("externally_defined_picture_representation_item",&STEP::ObjectHelper<externally_defined_picture_representation_item,0>::Construct )
,		SchemaEntry("externally_defined_representation_item",&STEP::ObjectHelper<externally_defined_representation_item,0>::Construct )
,		SchemaEntry("externally_defined_string",&STEP::ObjectHelper<externally_defined_string,0>::Construct )
,		SchemaEntry("externally_defined_symbol",&STEP::ObjectHelper<externally_defined_symbol,0>::Construct )
,		SchemaEntry("externally_defined_terminator_symbol",&STEP::ObjectHelper<externally_defined_terminator_symbol,0>::Construct )
,		SchemaEntry("externally_defined_text_font",&STEP::ObjectHelper<externally_defined_text_font,0>::Construct )
,		SchemaEntry("externally_defined_tile",&STEP::ObjectHelper<externally_defined_tile,0>::Construct )
,		SchemaEntry("externally_defined_tile_style",&STEP::ObjectHelper<externally_defined_tile_style,0>::Construct )
,		SchemaEntry("swept_area_solid",&STEP::ObjectHelper<swept_area_solid,1>::Construct )
,		SchemaEntry("extruded_area_solid",&STEP::ObjectHelper<extruded_area_solid,2>::Construct )
,		SchemaEntry("swept_face_solid",&STEP::ObjectHelper<swept_face_solid,1>::Construct )
,		SchemaEntry("extruded_face_solid",&STEP::ObjectHelper<extruded_face_solid,2>::Construct )
,		SchemaEntry("extruded_face_solid_with_trim_conditions",&STEP::ObjectHelper<extruded_face_solid_with_trim_conditions,6>::Construct )
,		SchemaEntry("extruded_face_solid_with_draft_angle",&STEP::ObjectHelper<extruded_face_solid_with_draft_angle,1>::Construct )
,		SchemaEntry("extruded_face_solid_with_multiple_draft_angles",&STEP::ObjectHelper<extruded_face_solid_with_multiple_draft_angles,1>::Construct )
,		SchemaEntry("face",&STEP::ObjectHelper<face,1>::Construct )
,		SchemaEntry("face_based_surface_model",&STEP::ObjectHelper<face_based_surface_model,1>::Construct )
,		SchemaEntry("face_bound",&STEP::ObjectHelper<face_bound,2>::Construct )
,		SchemaEntry("face_outer_bound",&STEP::ObjectHelper<face_outer_bound,0>::Construct )
,		SchemaEntry("faceted_brep",&STEP::ObjectHelper<faceted_brep,0>::Construct )
,		SchemaEntry("faceted_brep_shape_representation",&STEP::ObjectHelper<faceted_brep_shape_representation,0>::Construct )
,		SchemaEntry("fill_area_style",&STEP::ObjectHelper<fill_area_style,2>::Construct )
,		SchemaEntry("fill_area_style_colour",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("fill_area_style_hatching",&STEP::ObjectHelper<fill_area_style_hatching,5>::Construct )
,		SchemaEntry("fill_area_style_tile_coloured_region",&STEP::ObjectHelper<fill_area_style_tile_coloured_region,2>::Construct )
,		SchemaEntry("fill_area_style_tile_curve_with_style",&STEP::ObjectHelper<fill_area_style_tile_curve_with_style,1>::Construct )
,		SchemaEntry("fill_area_style_tile_symbol_with_style",&STEP::ObjectHelper<fill_area_style_tile_symbol_with_style,1>::Construct )
,		SchemaEntry("fill_area_style_tiles",&STEP::ObjectHelper<fill_area_style_tiles,3>::Construct )
,		SchemaEntry("shape_representation_relationship",&STEP::ObjectHelper<shape_representation_relationship,0>::Construct )
,		SchemaEntry("flat_pattern_ply_representation_relationship",&STEP::ObjectHelper<flat_pattern_ply_representation_relationship,0>::Construct )
,		SchemaEntry("flatness_tolerance",&STEP::ObjectHelper<flatness_tolerance,0>::Construct )
,		SchemaEntry("force_measure_with_unit",&STEP::ObjectHelper<force_measure_with_unit,0>::Construct )
,		SchemaEntry("force_unit",&STEP::ObjectHelper<force_unit,0>::Construct )
,		SchemaEntry("forward_chaining_rule",&STEP::ObjectHelper<forward_chaining_rule,0>::Construct )
,		SchemaEntry("forward_chaining_rule_premise",&STEP::ObjectHelper<forward_chaining_rule_premise,0>::Construct )
,		SchemaEntry("frequency_measure_with_unit",&STEP::ObjectHelper<frequency_measure_with_unit,0>::Construct )
,		SchemaEntry("frequency_unit",&STEP::ObjectHelper<frequency_unit,0>::Construct )
,		SchemaEntry("func",&STEP::ObjectHelper<func,0>::Construct )
,		SchemaEntry("functional_breakdown_context",&STEP::ObjectHelper<functional_breakdown_context,0>::Construct )
,		SchemaEntry("functional_element_usage",&STEP::ObjectHelper<functional_element_usage,0>::Construct )
,		SchemaEntry("functionally_defined_transformation",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("general_material_property",&STEP::ObjectHelper<general_material_property,0>::Construct )
,		SchemaEntry("general_property_association",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("simple_generic_expression",&STEP::ObjectHelper<simple_generic_expression,0>::Construct )
,		SchemaEntry("generic_literal",&STEP::ObjectHelper<generic_literal,0>::Construct )
,		SchemaEntry("generic_variable",&STEP::ObjectHelper<generic_variable,0>::Construct )
,		SchemaEntry("geometric_alignment",&STEP::ObjectHelper<geometric_alignment,0>::Construct )
,		SchemaEntry("geometric_set",&STEP::ObjectHelper<geometric_set,1>::Construct )
,		SchemaEntry("geometric_curve_set",&STEP::ObjectHelper<geometric_curve_set,0>::Construct )
,		SchemaEntry("geometric_intersection",&STEP::ObjectHelper<geometric_intersection,0>::Construct )
,		SchemaEntry("geometric_item_specific_usage",&STEP::ObjectHelper<geometric_item_specific_usage,0>::Construct )
,		SchemaEntry("geometric_model_element_relationship",&STEP::ObjectHelper<geometric_model_element_relationship,0>::Construct )
,		SchemaEntry("representation_context",&STEP::ObjectHelper<representation_context,2>::Construct )
,		SchemaEntry("geometric_representation_context",&STEP::ObjectHelper<geometric_representation_context,1>::Construct )
,		SchemaEntry("geometric_tolerance_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("geometric_tolerance_with_defined_unit",&STEP::ObjectHelper<geometric_tolerance_with_defined_unit,1>::Construct )
,		SchemaEntry("geometrical_tolerance_callout",&STEP::ObjectHelper<geometrical_tolerance_callout,0>::Construct )
,		SchemaEntry("geometrically_bounded_2d_wireframe_representation",&STEP::ObjectHelper<geometrically_bounded_2d_wireframe_representation,0>::Construct )
,		SchemaEntry("geometrically_bounded_surface_shape_representation",&STEP::ObjectHelper<geometrically_bounded_surface_shape_representation,0>::Construct )
,		SchemaEntry("geometrically_bounded_wireframe_shape_representation",&STEP::ObjectHelper<geometrically_bounded_wireframe_shape_representation,0>::Construct )
,		SchemaEntry("global_assignment",&STEP::ObjectHelper<global_assignment,0>::Construct )
,		SchemaEntry("global_uncertainty_assigned_context",&STEP::ObjectHelper<global_uncertainty_assigned_context,1>::Construct )
,		SchemaEntry("global_unit_assigned_context",&STEP::ObjectHelper<global_unit_assigned_context,1>::Construct )
,		SchemaEntry("ground_fact",&STEP::ObjectHelper<ground_fact,0>::Construct )
,		SchemaEntry("group_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("hardness_representation",&STEP::ObjectHelper<hardness_representation,0>::Construct )
,		SchemaEntry("hidden_element_over_riding_styled_item",&STEP::ObjectHelper<hidden_element_over_riding_styled_item,0>::Construct )
,		SchemaEntry("hyperbola",&STEP::ObjectHelper<hyperbola,2>::Construct )
,		SchemaEntry("id_attribute",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("identification_role",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("illuminance_measure_with_unit",&STEP::ObjectHelper<illuminance_measure_with_unit,0>::Construct )
,		SchemaEntry("illuminance_unit",&STEP::ObjectHelper<illuminance_unit,0>::Construct )
,		SchemaEntry("included_text_block",&STEP::ObjectHelper<included_text_block,0>::Construct )
,		SchemaEntry("inclusion_product_concept_feature",&STEP::ObjectHelper<inclusion_product_concept_feature,0>::Construct )
,		SchemaEntry("user_selected_elements",&STEP::ObjectHelper<user_selected_elements,1>::Construct )
,		SchemaEntry("indirectly_selected_elements",&STEP::ObjectHelper<indirectly_selected_elements,1>::Construct )
,		SchemaEntry("indirectly_selected_shape_elements",&STEP::ObjectHelper<indirectly_selected_shape_elements,0>::Construct )
,		SchemaEntry("inductance_measure_with_unit",&STEP::ObjectHelper<inductance_measure_with_unit,0>::Construct )
,		SchemaEntry("inductance_unit",&STEP::ObjectHelper<inductance_unit,0>::Construct )
,		SchemaEntry("information_right",&STEP::ObjectHelper<information_right,0>::Construct )
,		SchemaEntry("information_usage_right",&STEP::ObjectHelper<information_usage_right,0>::Construct )
,		SchemaEntry("instance_usage_context_assignment",&STEP::ObjectHelper<instance_usage_context_assignment,1>::Construct )
,		SchemaEntry("instanced_feature",&STEP::ObjectHelper<instanced_feature,0>::Construct )
,		SchemaEntry("literal_number",&STEP::ObjectHelper<literal_number,1>::Construct )
,		SchemaEntry("int_literal",&STEP::ObjectHelper<int_literal,0>::Construct )
,		SchemaEntry("integer_representation_item",&STEP::ObjectHelper<integer_representation_item,0>::Construct )
,		SchemaEntry("surface_curve",&STEP::ObjectHelper<surface_curve,3>::Construct )
,		SchemaEntry("intersection_curve",&STEP::ObjectHelper<intersection_curve,0>::Construct )
,		SchemaEntry("interval_expression",&STEP::ObjectHelper<interval_expression,0>::Construct )
,		SchemaEntry("iso4217_currency",&STEP::ObjectHelper<iso4217_currency,0>::Construct )
,		SchemaEntry("known_source",&STEP::ObjectHelper<known_source,0>::Construct )
,		SchemaEntry("laid_defined_transformation",&STEP::ObjectHelper<laid_defined_transformation,0>::Construct )
,		SchemaEntry("language",&STEP::ObjectHelper<language,0>::Construct )
,		SchemaEntry("leader_curve",&STEP::ObjectHelper<leader_curve,0>::Construct )
,		SchemaEntry("leader_directed_callout",&STEP::ObjectHelper<leader_directed_callout,0>::Construct )
,		SchemaEntry("leader_directed_dimension",&STEP::ObjectHelper<leader_directed_dimension,0>::Construct )
,		SchemaEntry("leader_terminator",&STEP::ObjectHelper<leader_terminator,0>::Construct )
,		SchemaEntry("length_measure_with_unit",&STEP::ObjectHelper<length_measure_with_unit,0>::Construct )
,		SchemaEntry("length_unit",&STEP::ObjectHelper<length_unit,0>::Construct )
,		SchemaEntry("light_source",&STEP::ObjectHelper<light_source,1>::Construct )
,		SchemaEntry("light_source_ambient",&STEP::ObjectHelper<light_source_ambient,0>::Construct )
,		SchemaEntry("light_source_directional",&STEP::ObjectHelper<light_source_directional,1>::Construct )
,		SchemaEntry("light_source_positional",&STEP::ObjectHelper<light_source_positional,3>::Construct )
,		SchemaEntry("light_source_spot",&STEP::ObjectHelper<light_source_spot,6>::Construct )
,		SchemaEntry("limits_and_fits",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("line",&STEP::ObjectHelper<line,2>::Construct )
,		SchemaEntry("line_profile_tolerance",&STEP::ObjectHelper<line_profile_tolerance,0>::Construct )
,		SchemaEntry("linear_dimension",&STEP::ObjectHelper<linear_dimension,0>::Construct )
,		SchemaEntry("simple_clause",&STEP::ObjectHelper<simple_clause,0>::Construct )
,		SchemaEntry("literal_conjunction",&STEP::ObjectHelper<literal_conjunction,0>::Construct )
,		SchemaEntry("literal_disjunction",&STEP::ObjectHelper<literal_disjunction,0>::Construct )
,		SchemaEntry("local_time",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("logical_literal",&STEP::ObjectHelper<logical_literal,1>::Construct )
,		SchemaEntry("logical_representation_item",&STEP::ObjectHelper<logical_representation_item,0>::Construct )
,		SchemaEntry("loop",&STEP::ObjectHelper<loop,0>::Construct )
,		SchemaEntry("loss_tangent_measure_with_unit",&STEP::ObjectHelper<loss_tangent_measure_with_unit,0>::Construct )
,		SchemaEntry("lot_effectivity",&STEP::ObjectHelper<lot_effectivity,2>::Construct )
,		SchemaEntry("luminous_flux_measure_with_unit",&STEP::ObjectHelper<luminous_flux_measure_with_unit,0>::Construct )
,		SchemaEntry("luminous_flux_unit",&STEP::ObjectHelper<luminous_flux_unit,0>::Construct )
,		SchemaEntry("luminous_intensity_measure_with_unit",&STEP::ObjectHelper<luminous_intensity_measure_with_unit,0>::Construct )
,		SchemaEntry("luminous_intensity_unit",&STEP::ObjectHelper<luminous_intensity_unit,0>::Construct )
,		SchemaEntry("magnetic_flux_density_measure_with_unit",&STEP::ObjectHelper<magnetic_flux_density_measure_with_unit,0>::Construct )
,		SchemaEntry("magnetic_flux_density_unit",&STEP::ObjectHelper<magnetic_flux_density_unit,0>::Construct )
,		SchemaEntry("magnetic_flux_measure_with_unit",&STEP::ObjectHelper<magnetic_flux_measure_with_unit,0>::Construct )
,		SchemaEntry("magnetic_flux_unit",&STEP::ObjectHelper<magnetic_flux_unit,0>::Construct )
,		SchemaEntry("make_from_usage_option",&STEP::ObjectHelper<make_from_usage_option,3>::Construct )
,		SchemaEntry("manifold_subsurface_shape_representation",&STEP::ObjectHelper<manifold_subsurface_shape_representation,0>::Construct )
,		SchemaEntry("manifold_surface_shape_representation",&STEP::ObjectHelper<manifold_surface_shape_representation,0>::Construct )
,		SchemaEntry("mass_measure_with_unit",&STEP::ObjectHelper<mass_measure_with_unit,0>::Construct )
,		SchemaEntry("mass_unit",&STEP::ObjectHelper<mass_unit,0>::Construct )
,		SchemaEntry("material_designation_characterization",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("material_property",&STEP::ObjectHelper<material_property,0>::Construct )
,		SchemaEntry("property_definition_representation",&STEP::ObjectHelper<property_definition_representation,2>::Construct )
,		SchemaEntry("material_property_representation",&STEP::ObjectHelper<material_property_representation,1>::Construct )
,		SchemaEntry("measure_qualification",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("measure_representation_item",&STEP::ObjectHelper<measure_representation_item,0>::Construct )
,		SchemaEntry("product_context",&STEP::ObjectHelper<product_context,1>::Construct )
,		SchemaEntry("mechanical_context",&STEP::ObjectHelper<mechanical_context,0>::Construct )
,		SchemaEntry("mechanical_design_and_draughting_relationship",&STEP::ObjectHelper<mechanical_design_and_draughting_relationship,0>::Construct )
,		SchemaEntry("mechanical_design_geometric_presentation_area",&STEP::ObjectHelper<mechanical_design_geometric_presentation_area,0>::Construct )
,		SchemaEntry("mechanical_design_geometric_presentation_representation",&STEP::ObjectHelper<mechanical_design_geometric_presentation_representation,0>::Construct )
,		SchemaEntry("mechanical_design_presentation_representation_with_draughting",&STEP::ObjectHelper<mechanical_design_presentation_representation_with_draughting,0>::Construct )
,		SchemaEntry("mechanical_design_shaded_presentation_area",&STEP::ObjectHelper<mechanical_design_shaded_presentation_area,0>::Construct )
,		SchemaEntry("mechanical_design_shaded_presentation_representation",&STEP::ObjectHelper<mechanical_design_shaded_presentation_representation,0>::Construct )
,		SchemaEntry("min_and_major_ply_orientation_basis",&STEP::ObjectHelper<min_and_major_ply_orientation_basis,0>::Construct )
,		SchemaEntry("modified_geometric_tolerance",&STEP::ObjectHelper<modified_geometric_tolerance,1>::Construct )
,		SchemaEntry("modified_solid_with_placed_configuration",&STEP::ObjectHelper<modified_solid_with_placed_configuration,1>::Construct )
,		SchemaEntry("moments_of_inertia_representation",&STEP::ObjectHelper<moments_of_inertia_representation,0>::Construct )
,		SchemaEntry("multi_language_attribute_assignment",&STEP::ObjectHelper<multi_language_attribute_assignment,1>::Construct )
,		SchemaEntry("multiple_arity_boolean_expression",&STEP::ObjectHelper<multiple_arity_boolean_expression,0>::Construct )
,		SchemaEntry("multiple_arity_generic_expression",&STEP::ObjectHelper<multiple_arity_generic_expression,1>::Construct )
,		SchemaEntry("multiple_arity_numeric_expression",&STEP::ObjectHelper<multiple_arity_numeric_expression,0>::Construct )
,		SchemaEntry("name_attribute",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("next_assembly_usage_occurrence",&STEP::ObjectHelper<next_assembly_usage_occurrence,0>::Construct )
,		SchemaEntry("non_manifold_surface_shape_representation",&STEP::ObjectHelper<non_manifold_surface_shape_representation,0>::Construct )
,		SchemaEntry("null_representation_item",&STEP::ObjectHelper<null_representation_item,0>::Construct )
,		SchemaEntry("numeric_expression",&STEP::ObjectHelper<numeric_expression,0>::Construct )
,		SchemaEntry("object_role",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("offset_curve_2d",&STEP::ObjectHelper<offset_curve_2d,3>::Construct )
,		SchemaEntry("offset_curve_3d",&STEP::ObjectHelper<offset_curve_3d,4>::Construct )
,		SchemaEntry("offset_surface",&STEP::ObjectHelper<offset_surface,3>::Construct )
,		SchemaEntry("one_direction_repeat_factor",&STEP::ObjectHelper<one_direction_repeat_factor,1>::Construct )
,		SchemaEntry("open_shell",&STEP::ObjectHelper<open_shell,0>::Construct )
,		SchemaEntry("ordinal_date",&STEP::ObjectHelper<ordinal_date,1>::Construct )
,		SchemaEntry("projection_directed_callout",&STEP::ObjectHelper<projection_directed_callout,0>::Construct )
,		SchemaEntry("ordinate_dimension",&STEP::ObjectHelper<ordinate_dimension,0>::Construct )
,		SchemaEntry("organization",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("organization_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("organization_role",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("organizational_address",&STEP::ObjectHelper<organizational_address,2>::Construct )
,		SchemaEntry("organizational_project",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("organizational_project_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("organizational_project_role",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("oriented_closed_shell",&STEP::ObjectHelper<oriented_closed_shell,2>::Construct )
,		SchemaEntry("oriented_edge",&STEP::ObjectHelper<oriented_edge,2>::Construct )
,		SchemaEntry("oriented_face",&STEP::ObjectHelper<oriented_face,2>::Construct )
,		SchemaEntry("oriented_open_shell",&STEP::ObjectHelper<oriented_open_shell,2>::Construct )
,		SchemaEntry("path",&STEP::ObjectHelper<path,1>::Construct )
,		SchemaEntry("oriented_path",&STEP::ObjectHelper<oriented_path,2>::Construct )
,		SchemaEntry("oriented_surface",&STEP::ObjectHelper<oriented_surface,1>::Construct )
,		SchemaEntry("outer_boundary_curve",&STEP::ObjectHelper<outer_boundary_curve,0>::Construct )
,		SchemaEntry("package_product_concept_feature",&STEP::ObjectHelper<package_product_concept_feature,0>::Construct )
,		SchemaEntry("parabola",&STEP::ObjectHelper<parabola,1>::Construct )
,		SchemaEntry("parallel_offset",&STEP::ObjectHelper<parallel_offset,1>::Construct )
,		SchemaEntry("parallelism_tolerance",&STEP::ObjectHelper<parallelism_tolerance,0>::Construct )
,		SchemaEntry("parametric_representation_context",&STEP::ObjectHelper<parametric_representation_context,0>::Construct )
,		SchemaEntry("partial_document_with_structured_text_representation_assignment",&STEP::ObjectHelper<partial_document_with_structured_text_representation_assignment,0>::Construct )
,		SchemaEntry("pcurve",&STEP::ObjectHelper<pcurve,2>::Construct )
,		SchemaEntry("percentage_laminate_definition",&STEP::ObjectHelper<percentage_laminate_definition,0>::Construct )
,		SchemaEntry("zone_structural_makeup",&STEP::ObjectHelper<zone_structural_makeup,0>::Construct )
,		SchemaEntry("percentage_laminate_table",&STEP::ObjectHelper<percentage_laminate_table,0>::Construct )
,		SchemaEntry("percentage_ply_definition",&STEP::ObjectHelper<percentage_ply_definition,0>::Construct )
,		SchemaEntry("perpendicular_to",&STEP::ObjectHelper<perpendicular_to,0>::Construct )
,		SchemaEntry("perpendicularity_tolerance",&STEP::ObjectHelper<perpendicularity_tolerance,0>::Construct )
,		SchemaEntry("person",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("person_and_organization",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("person_and_organization_address",&STEP::ObjectHelper<person_and_organization_address,0>::Construct )
,		SchemaEntry("person_and_organization_role",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("personal_address",&STEP::ObjectHelper<personal_address,2>::Construct )
,		SchemaEntry("physical_breakdown_context",&STEP::ObjectHelper<physical_breakdown_context,0>::Construct )
,		SchemaEntry("physical_element_usage",&STEP::ObjectHelper<physical_element_usage,0>::Construct )
,		SchemaEntry("presentation_view",&STEP::ObjectHelper<presentation_view,0>::Construct )
,		SchemaEntry("picture_representation",&STEP::ObjectHelper<picture_representation,0>::Construct )
,		SchemaEntry("placed_datum_target_feature",&STEP::ObjectHelper<placed_datum_target_feature,0>::Construct )
,		SchemaEntry("placed_feature",&STEP::ObjectHelper<placed_feature,0>::Construct )
,		SchemaEntry("planar_extent",&STEP::ObjectHelper<planar_extent,2>::Construct )
,		SchemaEntry("planar_box",&STEP::ObjectHelper<planar_box,1>::Construct )
,		SchemaEntry("plane",&STEP::ObjectHelper<plane,0>::Construct )
,		SchemaEntry("plane_angle_measure_with_unit",&STEP::ObjectHelper<plane_angle_measure_with_unit,0>::Construct )
,		SchemaEntry("plane_angle_unit",&STEP::ObjectHelper<plane_angle_unit,0>::Construct )
,		SchemaEntry("plus_minus_tolerance",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("ply_laminate_definition",&STEP::ObjectHelper<ply_laminate_definition,0>::Construct )
,		SchemaEntry("ply_laminate_sequence_definition",&STEP::ObjectHelper<ply_laminate_sequence_definition,0>::Construct )
,		SchemaEntry("ply_laminate_table",&STEP::ObjectHelper<ply_laminate_table,0>::Construct )
,		SchemaEntry("point_and_vector",&STEP::ObjectHelper<point_and_vector,0>::Construct )
,		SchemaEntry("point_on_curve",&STEP::ObjectHelper<point_on_curve,2>::Construct )
,		SchemaEntry("point_on_surface",&STEP::ObjectHelper<point_on_surface,3>::Construct )
,		SchemaEntry("point_path",&STEP::ObjectHelper<point_path,0>::Construct )
,		SchemaEntry("point_replica",&STEP::ObjectHelper<point_replica,2>::Construct )
,		SchemaEntry("point_style",&STEP::ObjectHelper<point_style,4>::Construct )
,		SchemaEntry("polar_complex_number_literal",&STEP::ObjectHelper<polar_complex_number_literal,2>::Construct )
,		SchemaEntry("poly_loop",&STEP::ObjectHelper<poly_loop,1>::Construct )
,		SchemaEntry("polyline",&STEP::ObjectHelper<polyline,1>::Construct )
,		SchemaEntry("position_tolerance",&STEP::ObjectHelper<position_tolerance,0>::Construct )
,		SchemaEntry("positioned_sketch",&STEP::ObjectHelper<positioned_sketch,2>::Construct )
,		SchemaEntry("power_measure_with_unit",&STEP::ObjectHelper<power_measure_with_unit,0>::Construct )
,		SchemaEntry("power_unit",&STEP::ObjectHelper<power_unit,0>::Construct )
,		SchemaEntry("pre_defined_symbol",&STEP::ObjectHelper<pre_defined_symbol,0>::Construct )
,		SchemaEntry("pre_defined_dimension_symbol",&STEP::ObjectHelper<pre_defined_dimension_symbol,0>::Construct )
,		SchemaEntry("pre_defined_geometrical_tolerance_symbol",&STEP::ObjectHelper<pre_defined_geometrical_tolerance_symbol,0>::Construct )
,		SchemaEntry("pre_defined_marker",&STEP::ObjectHelper<pre_defined_marker,0>::Construct )
,		SchemaEntry("pre_defined_point_marker_symbol",&STEP::ObjectHelper<pre_defined_point_marker_symbol,0>::Construct )
,		SchemaEntry("pre_defined_surface_condition_symbol",&STEP::ObjectHelper<pre_defined_surface_condition_symbol,0>::Construct )
,		SchemaEntry("pre_defined_surface_side_style",&STEP::ObjectHelper<pre_defined_surface_side_style,0>::Construct )
,		SchemaEntry("pre_defined_terminator_symbol",&STEP::ObjectHelper<pre_defined_terminator_symbol,0>::Construct )
,		SchemaEntry("pre_defined_tile",&STEP::ObjectHelper<pre_defined_tile,0>::Construct )
,		SchemaEntry("precision_qualifier",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("predefined_picture_representation_item",&STEP::ObjectHelper<predefined_picture_representation_item,0>::Construct )
,		SchemaEntry("presentation_layer_assignment",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("presentation_size",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("presentation_style_assignment",&STEP::ObjectHelper<presentation_style_assignment,1>::Construct )
,		SchemaEntry("presentation_style_by_context",&STEP::ObjectHelper<presentation_style_by_context,1>::Construct )
,		SchemaEntry("presented_item_representation",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("pressure_measure_with_unit",&STEP::ObjectHelper<pressure_measure_with_unit,0>::Construct )
,		SchemaEntry("pressure_unit",&STEP::ObjectHelper<pressure_unit,0>::Construct )
,		SchemaEntry("procedural_representation",&STEP::ObjectHelper<procedural_representation,0>::Construct )
,		SchemaEntry("procedural_representation_sequence",&STEP::ObjectHelper<procedural_representation_sequence,3>::Construct )
,		SchemaEntry("procedural_shape_representation",&STEP::ObjectHelper<procedural_shape_representation,0>::Construct )
,		SchemaEntry("procedural_shape_representation_sequence",&STEP::ObjectHelper<procedural_shape_representation_sequence,0>::Construct )
,		SchemaEntry("product",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("product_category",&STEP::ObjectHelper<product_category,2>::Construct )
,		SchemaEntry("product_class",&STEP::ObjectHelper<product_class,0>::Construct )
,		SchemaEntry("product_concept",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("product_concept_context",&STEP::ObjectHelper<product_concept_context,1>::Construct )
,		SchemaEntry("product_concept_feature_association",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("product_concept_feature_category_usage",&STEP::ObjectHelper<product_concept_feature_category_usage,1>::Construct )
,		SchemaEntry("product_concept_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("product_definition_context_association",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("product_definition_context_role",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("product_definition_element_relationship",&STEP::ObjectHelper<product_definition_element_relationship,0>::Construct )
,		SchemaEntry("product_definition_formation",&STEP::ObjectHelper<product_definition_formation,3>::Construct )
,		SchemaEntry("product_definition_formation_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("product_definition_formation_with_specified_source",&STEP::ObjectHelper<product_definition_formation_with_specified_source,1>::Construct )
,		SchemaEntry("product_definition_group_assignment",&STEP::ObjectHelper<product_definition_group_assignment,1>::Construct )
,		SchemaEntry("product_definition_occurrence_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("product_definition_shape",&STEP::ObjectHelper<product_definition_shape,0>::Construct )
,		SchemaEntry("product_definition_substitute",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("product_definition_with_associated_documents",&STEP::ObjectHelper<product_definition_with_associated_documents,1>::Construct )
,		SchemaEntry("product_identification",&STEP::ObjectHelper<product_identification,0>::Construct )
,		SchemaEntry("product_material_composition_relationship",&STEP::ObjectHelper<product_material_composition_relationship,4>::Construct )
,		SchemaEntry("product_related_product_category",&STEP::ObjectHelper<product_related_product_category,1>::Construct )
,		SchemaEntry("product_specification",&STEP::ObjectHelper<product_specification,0>::Construct )
,		SchemaEntry("tolerance_zone_definition",&STEP::ObjectHelper<tolerance_zone_definition,2>::Construct )
,		SchemaEntry("projected_zone_definition",&STEP::ObjectHelper<projected_zone_definition,2>::Construct )
,		SchemaEntry("projection_curve",&STEP::ObjectHelper<projection_curve,0>::Construct )
,		SchemaEntry("promissory_usage_occurrence",&STEP::ObjectHelper<promissory_usage_occurrence,0>::Construct )
,		SchemaEntry("property_definition_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("qualified_representation_item",&STEP::ObjectHelper<qualified_representation_item,1>::Construct )
,		SchemaEntry("qualitative_uncertainty",&STEP::ObjectHelper<qualitative_uncertainty,1>::Construct )
,		SchemaEntry("quantified_assembly_component_usage",&STEP::ObjectHelper<quantified_assembly_component_usage,1>::Construct )
,		SchemaEntry("quasi_uniform_curve",&STEP::ObjectHelper<quasi_uniform_curve,0>::Construct )
,		SchemaEntry("quasi_uniform_surface",&STEP::ObjectHelper<quasi_uniform_surface,0>::Construct )
,		SchemaEntry("radioactivity_measure_with_unit",&STEP::ObjectHelper<radioactivity_measure_with_unit,0>::Construct )
,		SchemaEntry("radioactivity_unit",&STEP::ObjectHelper<radioactivity_unit,0>::Construct )
,		SchemaEntry("radius_dimension",&STEP::ObjectHelper<radius_dimension,0>::Construct )
,		SchemaEntry("range_characteristic",&STEP::ObjectHelper<range_characteristic,0>::Construct )
,		SchemaEntry("ratio_unit",&STEP::ObjectHelper<ratio_unit,0>::Construct )
,		SchemaEntry("rational_b_spline_curve",&STEP::ObjectHelper<rational_b_spline_curve,1>::Construct )
,		SchemaEntry("rational_b_spline_surface",&STEP::ObjectHelper<rational_b_spline_surface,0>::Construct )
,		SchemaEntry("rational_representation_item",&STEP::ObjectHelper<rational_representation_item,0>::Construct )
,		SchemaEntry("real_literal",&STEP::ObjectHelper<real_literal,0>::Construct )
,		SchemaEntry("real_representation_item",&STEP::ObjectHelper<real_representation_item,0>::Construct )
,		SchemaEntry("rectangular_composite_surface",&STEP::ObjectHelper<rectangular_composite_surface,0>::Construct )
,		SchemaEntry("rectangular_trimmed_surface",&STEP::ObjectHelper<rectangular_trimmed_surface,7>::Construct )
,		SchemaEntry("referenced_modified_datum",&STEP::ObjectHelper<referenced_modified_datum,1>::Construct )
,		SchemaEntry("relative_event_occurrence",&STEP::ObjectHelper<relative_event_occurrence,2>::Construct )
,		SchemaEntry("rep_item_group",&STEP::ObjectHelper<rep_item_group,0>::Construct )
,		SchemaEntry("reparametrised_composite_curve_segment",&STEP::ObjectHelper<reparametrised_composite_curve_segment,1>::Construct )
,		SchemaEntry("representation_relationship_with_transformation",&STEP::ObjectHelper<representation_relationship_with_transformation,1>::Construct )
,		SchemaEntry("requirement_assigned_object",&STEP::ObjectHelper<requirement_assigned_object,1>::Construct )
,		SchemaEntry("requirement_assignment",&STEP::ObjectHelper<requirement_assignment,0>::Construct )
,		SchemaEntry("requirement_source",&STEP::ObjectHelper<requirement_source,0>::Construct )
,		SchemaEntry("requirement_view_definition_relationship",&STEP::ObjectHelper<requirement_view_definition_relationship,0>::Construct )
,		SchemaEntry("resistance_measure_with_unit",&STEP::ObjectHelper<resistance_measure_with_unit,0>::Construct )
,		SchemaEntry("resistance_unit",&STEP::ObjectHelper<resistance_unit,0>::Construct )
,		SchemaEntry("revolved_area_solid",&STEP::ObjectHelper<revolved_area_solid,2>::Construct )
,		SchemaEntry("revolved_face_solid",&STEP::ObjectHelper<revolved_face_solid,2>::Construct )
,		SchemaEntry("revolved_face_solid_with_trim_conditions",&STEP::ObjectHelper<revolved_face_solid_with_trim_conditions,2>::Construct )
,		SchemaEntry("right_angular_wedge",&STEP::ObjectHelper<right_angular_wedge,5>::Construct )
,		SchemaEntry("right_circular_cone",&STEP::ObjectHelper<right_circular_cone,4>::Construct )
,		SchemaEntry("right_circular_cylinder",&STEP::ObjectHelper<right_circular_cylinder,3>::Construct )
,		SchemaEntry("right_to_usage_association",&STEP::ObjectHelper<right_to_usage_association,0>::Construct )
,		SchemaEntry("role_association",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("roundness_tolerance",&STEP::ObjectHelper<roundness_tolerance,0>::Construct )
,		SchemaEntry("row_representation_item",&STEP::ObjectHelper<row_representation_item,0>::Construct )
,		SchemaEntry("row_value",&STEP::ObjectHelper<row_value,0>::Construct )
,		SchemaEntry("row_variable",&STEP::ObjectHelper<row_variable,0>::Construct )
,		SchemaEntry("rule_action",&STEP::ObjectHelper<rule_action,0>::Construct )
,		SchemaEntry("rule_condition",&STEP::ObjectHelper<rule_condition,0>::Construct )
,		SchemaEntry("rule_set",&STEP::ObjectHelper<rule_set,0>::Construct )
,		SchemaEntry("rule_set_group",&STEP::ObjectHelper<rule_set_group,0>::Construct )
,		SchemaEntry("rule_superseded_assignment",&STEP::ObjectHelper<rule_superseded_assignment,1>::Construct )
,		SchemaEntry("rule_supersedence",&STEP::ObjectHelper<rule_supersedence,0>::Construct )
,		SchemaEntry("surface_curve_swept_area_solid",&STEP::ObjectHelper<surface_curve_swept_area_solid,4>::Construct )
,		SchemaEntry("ruled_surface_swept_area_solid",&STEP::ObjectHelper<ruled_surface_swept_area_solid,0>::Construct )
,		SchemaEntry("runout_zone_definition",&STEP::ObjectHelper<runout_zone_definition,1>::Construct )
,		SchemaEntry("runout_zone_orientation",&STEP::ObjectHelper<runout_zone_orientation,1>::Construct )
,		SchemaEntry("runout_zone_orientation_reference_direction",&STEP::ObjectHelper<runout_zone_orientation_reference_direction,1>::Construct )
,		SchemaEntry("satisfied_requirement",&STEP::ObjectHelper<satisfied_requirement,1>::Construct )
,		SchemaEntry("satisfies_requirement",&STEP::ObjectHelper<satisfies_requirement,0>::Construct )
,		SchemaEntry("satisfying_item",&STEP::ObjectHelper<satisfying_item,1>::Construct )
,		SchemaEntry("scalar_variable",&STEP::ObjectHelper<scalar_variable,0>::Construct )
,		SchemaEntry("scattering_parameter",&STEP::ObjectHelper<scattering_parameter,0>::Construct )
,		SchemaEntry("sculptured_solid",&STEP::ObjectHelper<sculptured_solid,2>::Construct )
,		SchemaEntry("seam_curve",&STEP::ObjectHelper<seam_curve,0>::Construct )
,		SchemaEntry("security_classification",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("security_classification_level",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("serial_numbered_effectivity",&STEP::ObjectHelper<serial_numbered_effectivity,2>::Construct )
,		SchemaEntry("shape_aspect_associativity",&STEP::ObjectHelper<shape_aspect_associativity,0>::Construct )
,		SchemaEntry("shape_aspect_deriving_relationship",&STEP::ObjectHelper<shape_aspect_deriving_relationship,0>::Construct )
,		SchemaEntry("shape_definition_representation",&STEP::ObjectHelper<shape_definition_representation,0>::Construct )
,		SchemaEntry("shape_dimension_representation",&STEP::ObjectHelper<shape_dimension_representation,0>::Construct )
,		SchemaEntry("shape_feature_definition",&STEP::ObjectHelper<shape_feature_definition,0>::Construct )
,		SchemaEntry("shape_representation_with_parameters",&STEP::ObjectHelper<shape_representation_with_parameters,0>::Construct )
,		SchemaEntry("shell_based_surface_model",&STEP::ObjectHelper<shell_based_surface_model,1>::Construct )
,		SchemaEntry("shell_based_wireframe_model",&STEP::ObjectHelper<shell_based_wireframe_model,1>::Construct )
,		SchemaEntry("shell_based_wireframe_shape_representation",&STEP::ObjectHelper<shell_based_wireframe_shape_representation,0>::Construct )
,		SchemaEntry("si_absorbed_dose_unit",&STEP::ObjectHelper<si_absorbed_dose_unit,0>::Construct )
,		SchemaEntry("si_capacitance_unit",&STEP::ObjectHelper<si_capacitance_unit,0>::Construct )
,		SchemaEntry("si_conductance_unit",&STEP::ObjectHelper<si_conductance_unit,0>::Construct )
,		SchemaEntry("si_dose_equivalent_unit",&STEP::ObjectHelper<si_dose_equivalent_unit,0>::Construct )
,		SchemaEntry("si_electric_charge_unit",&STEP::ObjectHelper<si_electric_charge_unit,0>::Construct )
,		SchemaEntry("si_electric_potential_unit",&STEP::ObjectHelper<si_electric_potential_unit,0>::Construct )
,		SchemaEntry("si_energy_unit",&STEP::ObjectHelper<si_energy_unit,0>::Construct )
,		SchemaEntry("si_force_unit",&STEP::ObjectHelper<si_force_unit,0>::Construct )
,		SchemaEntry("si_frequency_unit",&STEP::ObjectHelper<si_frequency_unit,0>::Construct )
,		SchemaEntry("si_illuminance_unit",&STEP::ObjectHelper<si_illuminance_unit,0>::Construct )
,		SchemaEntry("si_inductance_unit",&STEP::ObjectHelper<si_inductance_unit,0>::Construct )
,		SchemaEntry("si_magnetic_flux_density_unit",&STEP::ObjectHelper<si_magnetic_flux_density_unit,0>::Construct )
,		SchemaEntry("si_magnetic_flux_unit",&STEP::ObjectHelper<si_magnetic_flux_unit,0>::Construct )
,		SchemaEntry("si_power_unit",&STEP::ObjectHelper<si_power_unit,0>::Construct )
,		SchemaEntry("si_pressure_unit",&STEP::ObjectHelper<si_pressure_unit,0>::Construct )
,		SchemaEntry("si_radioactivity_unit",&STEP::ObjectHelper<si_radioactivity_unit,0>::Construct )
,		SchemaEntry("si_resistance_unit",&STEP::ObjectHelper<si_resistance_unit,0>::Construct )
,		SchemaEntry("si_unit",&STEP::ObjectHelper<si_unit,2>::Construct )
,		SchemaEntry("simple_boolean_expression",&STEP::ObjectHelper<simple_boolean_expression,0>::Construct )
,		SchemaEntry("simple_numeric_expression",&STEP::ObjectHelper<simple_numeric_expression,0>::Construct )
,		SchemaEntry("slash_expression",&STEP::ObjectHelper<slash_expression,0>::Construct )
,		SchemaEntry("smeared_material_definition",&STEP::ObjectHelper<smeared_material_definition,0>::Construct )
,		SchemaEntry("solid_angle_measure_with_unit",&STEP::ObjectHelper<solid_angle_measure_with_unit,0>::Construct )
,		SchemaEntry("solid_angle_unit",&STEP::ObjectHelper<solid_angle_unit,0>::Construct )
,		SchemaEntry("solid_curve_font",&STEP::ObjectHelper<solid_curve_font,0>::Construct )
,		SchemaEntry("solid_replica",&STEP::ObjectHelper<solid_replica,2>::Construct )
,		SchemaEntry("solid_with_chamfered_edges",&STEP::ObjectHelper<solid_with_chamfered_edges,0>::Construct )
,		SchemaEntry("solid_with_angle_based_chamfer",&STEP::ObjectHelper<solid_with_angle_based_chamfer,3>::Construct )
,		SchemaEntry("solid_with_shape_element_pattern",&STEP::ObjectHelper<solid_with_shape_element_pattern,1>::Construct )
,		SchemaEntry("solid_with_circular_pattern",&STEP::ObjectHelper<solid_with_circular_pattern,4>::Construct )
,		SchemaEntry("solid_with_depression",&STEP::ObjectHelper<solid_with_depression,1>::Construct )
,		SchemaEntry("solid_with_pocket",&STEP::ObjectHelper<solid_with_pocket,2>::Construct )
,		SchemaEntry("solid_with_circular_pocket",&STEP::ObjectHelper<solid_with_circular_pocket,1>::Construct )
,		SchemaEntry("solid_with_protrusion",&STEP::ObjectHelper<solid_with_protrusion,2>::Construct )
,		SchemaEntry("solid_with_circular_protrusion",&STEP::ObjectHelper<solid_with_circular_protrusion,1>::Construct )
,		SchemaEntry("solid_with_hole",&STEP::ObjectHelper<solid_with_hole,0>::Construct )
,		SchemaEntry("solid_with_stepped_round_hole",&STEP::ObjectHelper<solid_with_stepped_round_hole,1>::Construct )
,		SchemaEntry("solid_with_conical_bottom_round_hole",&STEP::ObjectHelper<solid_with_conical_bottom_round_hole,2>::Construct )
,		SchemaEntry("solid_with_constant_radius_edge_blend",&STEP::ObjectHelper<solid_with_constant_radius_edge_blend,1>::Construct )
,		SchemaEntry("solid_with_slot",&STEP::ObjectHelper<solid_with_slot,2>::Construct )
,		SchemaEntry("solid_with_curved_slot",&STEP::ObjectHelper<solid_with_curved_slot,1>::Construct )
,		SchemaEntry("solid_with_double_offset_chamfer",&STEP::ObjectHelper<solid_with_double_offset_chamfer,2>::Construct )
,		SchemaEntry("solid_with_flat_bottom_round_hole",&STEP::ObjectHelper<solid_with_flat_bottom_round_hole,1>::Construct )
,		SchemaEntry("solid_with_general_pocket",&STEP::ObjectHelper<solid_with_general_pocket,2>::Construct )
,		SchemaEntry("solid_with_general_protrusion",&STEP::ObjectHelper<solid_with_general_protrusion,2>::Construct )
,		SchemaEntry("solid_with_groove",&STEP::ObjectHelper<solid_with_groove,5>::Construct )
,		SchemaEntry("solid_with_incomplete_circular_pattern",&STEP::ObjectHelper<solid_with_incomplete_circular_pattern,1>::Construct )
,		SchemaEntry("solid_with_rectangular_pattern",&STEP::ObjectHelper<solid_with_rectangular_pattern,4>::Construct )
,		SchemaEntry("solid_with_incomplete_rectangular_pattern",&STEP::ObjectHelper<solid_with_incomplete_rectangular_pattern,0>::Construct )
,		SchemaEntry("solid_with_rectangular_pocket",&STEP::ObjectHelper<solid_with_rectangular_pocket,3>::Construct )
,		SchemaEntry("solid_with_rectangular_protrusion",&STEP::ObjectHelper<solid_with_rectangular_protrusion,3>::Construct )
,		SchemaEntry("solid_with_single_offset_chamfer",&STEP::ObjectHelper<solid_with_single_offset_chamfer,1>::Construct )
,		SchemaEntry("solid_with_spherical_bottom_round_hole",&STEP::ObjectHelper<solid_with_spherical_bottom_round_hole,1>::Construct )
,		SchemaEntry("solid_with_stepped_round_hole_and_conical_transitions",&STEP::ObjectHelper<solid_with_stepped_round_hole_and_conical_transitions,1>::Construct )
,		SchemaEntry("solid_with_straight_slot",&STEP::ObjectHelper<solid_with_straight_slot,1>::Construct )
,		SchemaEntry("solid_with_tee_section_slot",&STEP::ObjectHelper<solid_with_tee_section_slot,2>::Construct )
,		SchemaEntry("solid_with_through_depression",&STEP::ObjectHelper<solid_with_through_depression,1>::Construct )
,		SchemaEntry("solid_with_trapezoidal_section_slot",&STEP::ObjectHelper<solid_with_trapezoidal_section_slot,2>::Construct )
,		SchemaEntry("solid_with_variable_radius_edge_blend",&STEP::ObjectHelper<solid_with_variable_radius_edge_blend,3>::Construct )
,		SchemaEntry("source_for_requirement",&STEP::ObjectHelper<source_for_requirement,1>::Construct )
,		SchemaEntry("sourced_requirement",&STEP::ObjectHelper<sourced_requirement,1>::Construct )
,		SchemaEntry("specification_definition",&STEP::ObjectHelper<specification_definition,0>::Construct )
,		SchemaEntry("specified_higher_usage_occurrence",&STEP::ObjectHelper<specified_higher_usage_occurrence,2>::Construct )
,		SchemaEntry("sphere",&STEP::ObjectHelper<sphere,2>::Construct )
,		SchemaEntry("spherical_surface",&STEP::ObjectHelper<spherical_surface,1>::Construct )
,		SchemaEntry("start_request",&STEP::ObjectHelper<start_request,1>::Construct )
,		SchemaEntry("start_work",&STEP::ObjectHelper<start_work,1>::Construct )
,		SchemaEntry("straightness_tolerance",&STEP::ObjectHelper<straightness_tolerance,0>::Construct )
,		SchemaEntry("structured_dimension_callout",&STEP::ObjectHelper<structured_dimension_callout,0>::Construct )
,		SchemaEntry("structured_text_composition",&STEP::ObjectHelper<structured_text_composition,0>::Construct )
,		SchemaEntry("structured_text_representation",&STEP::ObjectHelper<structured_text_representation,0>::Construct )
,		SchemaEntry("subedge",&STEP::ObjectHelper<subedge,1>::Construct )
,		SchemaEntry("subface",&STEP::ObjectHelper<subface,1>::Construct )
,		SchemaEntry("supplied_part_relationship",&STEP::ObjectHelper<supplied_part_relationship,0>::Construct )
,		SchemaEntry("surface_condition_callout",&STEP::ObjectHelper<surface_condition_callout,0>::Construct )
,		SchemaEntry("swept_surface",&STEP::ObjectHelper<swept_surface,1>::Construct )
,		SchemaEntry("surface_of_linear_extrusion",&STEP::ObjectHelper<surface_of_linear_extrusion,1>::Construct )
,		SchemaEntry("surface_of_revolution",&STEP::ObjectHelper<surface_of_revolution,1>::Construct )
,		SchemaEntry("surface_patch",&STEP::ObjectHelper<surface_patch,5>::Construct )
,		SchemaEntry("surface_profile_tolerance",&STEP::ObjectHelper<surface_profile_tolerance,0>::Construct )
,		SchemaEntry("surface_rendering_properties",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("surface_replica",&STEP::ObjectHelper<surface_replica,2>::Construct )
,		SchemaEntry("surface_side_style",&STEP::ObjectHelper<surface_side_style,2>::Construct )
,		SchemaEntry("surface_style_boundary",&STEP::ObjectHelper<surface_style_boundary,1>::Construct )
,		SchemaEntry("surface_style_control_grid",&STEP::ObjectHelper<surface_style_control_grid,1>::Construct )
,		SchemaEntry("surface_style_fill_area",&STEP::ObjectHelper<surface_style_fill_area,1>::Construct )
,		SchemaEntry("surface_style_parameter_line",&STEP::ObjectHelper<surface_style_parameter_line,2>::Construct )
,		SchemaEntry("surface_style_reflectance_ambient",&STEP::ObjectHelper<surface_style_reflectance_ambient,1>::Construct )
,		SchemaEntry("surface_style_reflectance_ambient_diffuse",&STEP::ObjectHelper<surface_style_reflectance_ambient_diffuse,1>::Construct )
,		SchemaEntry("surface_style_reflectance_ambient_diffuse_specular",&STEP::ObjectHelper<surface_style_reflectance_ambient_diffuse_specular,3>::Construct )
,		SchemaEntry("surface_style_rendering",&STEP::ObjectHelper<surface_style_rendering,2>::Construct )
,		SchemaEntry("surface_style_rendering_with_properties",&STEP::ObjectHelper<surface_style_rendering_with_properties,1>::Construct )
,		SchemaEntry("surface_style_segmentation_curve",&STEP::ObjectHelper<surface_style_segmentation_curve,1>::Construct )
,		SchemaEntry("surface_style_silhouette",&STEP::ObjectHelper<surface_style_silhouette,1>::Construct )
,		SchemaEntry("surface_style_transparent",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("surface_style_usage",&STEP::ObjectHelper<surface_style_usage,2>::Construct )
,		SchemaEntry("surface_texture_representation",&STEP::ObjectHelper<surface_texture_representation,0>::Construct )
,		SchemaEntry("surfaced_open_shell",&STEP::ObjectHelper<surfaced_open_shell,0>::Construct )
,		SchemaEntry("swept_disk_solid",&STEP::ObjectHelper<swept_disk_solid,5>::Construct )
,		SchemaEntry("symbol",&STEP::ObjectHelper<symbol,0>::Construct )
,		SchemaEntry("symbol_colour",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("symbol_representation_map",&STEP::ObjectHelper<symbol_representation_map,0>::Construct )
,		SchemaEntry("symbol_style",&STEP::ObjectHelper<symbol_style,2>::Construct )
,		SchemaEntry("symbol_target",&STEP::ObjectHelper<symbol_target,3>::Construct )
,		SchemaEntry("symmetric_shape_aspect",&STEP::ObjectHelper<symmetric_shape_aspect,0>::Construct )
,		SchemaEntry("symmetry_tolerance",&STEP::ObjectHelper<symmetry_tolerance,0>::Construct )
,		SchemaEntry("table_representation_item",&STEP::ObjectHelper<table_representation_item,0>::Construct )
,		SchemaEntry("tactile_appearance_representation",&STEP::ObjectHelper<tactile_appearance_representation,0>::Construct )
,		SchemaEntry("tagged_text_format",&STEP::ObjectHelper<tagged_text_format,0>::Construct )
,		SchemaEntry("tagged_text_item",&STEP::ObjectHelper<tagged_text_item,0>::Construct )
,		SchemaEntry("tangent",&STEP::ObjectHelper<tangent,0>::Construct )
,		SchemaEntry("text_font",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("text_font_family",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("text_font_in_family",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("text_literal_with_associated_curves",&STEP::ObjectHelper<text_literal_with_associated_curves,1>::Construct )
,		SchemaEntry("text_literal_with_blanking_box",&STEP::ObjectHelper<text_literal_with_blanking_box,1>::Construct )
,		SchemaEntry("text_literal_with_extent",&STEP::ObjectHelper<text_literal_with_extent,1>::Construct )
,		SchemaEntry("text_string_representation",&STEP::ObjectHelper<text_string_representation,0>::Construct )
,		SchemaEntry("text_style",&STEP::ObjectHelper<text_style,2>::Construct )
,		SchemaEntry("text_style_for_defined_font",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("text_style_with_box_characteristics",&STEP::ObjectHelper<text_style_with_box_characteristics,1>::Construct )
,		SchemaEntry("text_style_with_mirror",&STEP::ObjectHelper<text_style_with_mirror,1>::Construct )
,		SchemaEntry("text_style_with_spacing",&STEP::ObjectHelper<text_style_with_spacing,1>::Construct )
,		SchemaEntry("thermal_resistance_measure_with_unit",&STEP::ObjectHelper<thermal_resistance_measure_with_unit,0>::Construct )
,		SchemaEntry("thermal_resistance_unit",&STEP::ObjectHelper<thermal_resistance_unit,0>::Construct )
,		SchemaEntry("thermodynamic_temperature_measure_with_unit",&STEP::ObjectHelper<thermodynamic_temperature_measure_with_unit,0>::Construct )
,		SchemaEntry("thermodynamic_temperature_unit",&STEP::ObjectHelper<thermodynamic_temperature_unit,0>::Construct )
,		SchemaEntry("thickened_face_solid",&STEP::ObjectHelper<thickened_face_solid,3>::Construct )
,		SchemaEntry("thickness_laminate_definition",&STEP::ObjectHelper<thickness_laminate_definition,0>::Construct )
,		SchemaEntry("thickness_laminate_table",&STEP::ObjectHelper<thickness_laminate_table,0>::Construct )
,		SchemaEntry("time_interval",&STEP::ObjectHelper<time_interval,3>::Construct )
,		SchemaEntry("time_interval_based_effectivity",&STEP::ObjectHelper<time_interval_based_effectivity,1>::Construct )
,		SchemaEntry("time_interval_relationship",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("time_interval_role",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("time_interval_with_bounds",&STEP::ObjectHelper<time_interval_with_bounds,3>::Construct )
,		SchemaEntry("time_measure_with_unit",&STEP::ObjectHelper<time_measure_with_unit,0>::Construct )
,		SchemaEntry("time_unit",&STEP::ObjectHelper<time_unit,0>::Construct )
,		SchemaEntry("tolerance_value",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("tolerance_zone",&STEP::ObjectHelper<tolerance_zone,2>::Construct )
,		SchemaEntry("tolerance_zone_form",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("torus",&STEP::ObjectHelper<torus,3>::Construct )
,		SchemaEntry("total_runout_tolerance",&STEP::ObjectHelper<total_runout_tolerance,0>::Construct )
,		SchemaEntry("track_blended_solid",&STEP::ObjectHelper<track_blended_solid,0>::Construct )
,		SchemaEntry("track_blended_solid_with_end_conditions",&STEP::ObjectHelper<track_blended_solid_with_end_conditions,1>::Construct )
,		SchemaEntry("trimmed_curve",&STEP::ObjectHelper<trimmed_curve,5>::Construct )
,		SchemaEntry("two_direction_repeat_factor",&STEP::ObjectHelper<two_direction_repeat_factor,1>::Construct )
,		SchemaEntry("type_qualifier",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("unary_generic_expression",&STEP::ObjectHelper<unary_generic_expression,1>::Construct )
,		SchemaEntry("unary_numeric_expression",&STEP::ObjectHelper<unary_numeric_expression,0>::Construct )
,		SchemaEntry("uncertainty_assigned_representation",&STEP::ObjectHelper<uncertainty_assigned_representation,1>::Construct )
,		SchemaEntry("uncertainty_measure_with_unit",&STEP::ObjectHelper<uncertainty_measure_with_unit,2>::Construct )
,		SchemaEntry("uniform_curve",&STEP::ObjectHelper<uniform_curve,0>::Construct )
,		SchemaEntry("uniform_resource_identifier",&STEP::ObjectHelper<uniform_resource_identifier,0>::Construct )
,		SchemaEntry("uniform_surface",&STEP::ObjectHelper<uniform_surface,0>::Construct )
,		SchemaEntry("usage_association",&STEP::ObjectHelper<usage_association,0>::Construct )
,		SchemaEntry("user_defined_curve_font",&STEP::ObjectHelper<user_defined_curve_font,0>::Construct )
,		SchemaEntry("user_defined_marker",&STEP::ObjectHelper<user_defined_marker,0>::Construct )
,		SchemaEntry("user_defined_terminator_symbol",&STEP::ObjectHelper<user_defined_terminator_symbol,0>::Construct )
,		SchemaEntry("user_selected_shape_elements",&STEP::ObjectHelper<user_selected_shape_elements,0>::Construct )
,		SchemaEntry("value_range",&STEP::ObjectHelper<value_range,0>::Construct )
,		SchemaEntry("value_representation_item",&STEP::ObjectHelper<value_representation_item,1>::Construct )
,		SchemaEntry("variable_semantics",&STEP::ObjectHelper<variable_semantics,0>::Construct )
,		SchemaEntry("variational_representation_item",&STEP::ObjectHelper<variational_representation_item,0>::Construct )
,		SchemaEntry("vector",&STEP::ObjectHelper<vector,2>::Construct )
,		SchemaEntry("vector_style",&STEP::ObjectHelper<vector_style,0>::Construct )
,		SchemaEntry("velocity_measure_with_unit",&STEP::ObjectHelper<velocity_measure_with_unit,0>::Construct )
,		SchemaEntry("velocity_unit",&STEP::ObjectHelper<velocity_unit,0>::Construct )
,		SchemaEntry("versioned_action_request",&STEP::ObjectHelper<NotImplemented,0>::Construct )
,		SchemaEntry("vertex",&STEP::ObjectHelper<vertex,0>::Construct )
,		SchemaEntry("vertex_loop",&STEP::ObjectHelper<vertex_loop,1>::Construct )
,		SchemaEntry("vertex_point",&STEP::ObjectHelper<vertex_point,1>::Construct )
,		SchemaEntry("vertex_shell",&STEP::ObjectHelper<vertex_shell,1>::Construct )
,		SchemaEntry("view_volume",&STEP::ObjectHelper<view_volume,9>::Construct )
,		SchemaEntry("visual_appearance_representation",&STEP::ObjectHelper<visual_appearance_representation,0>::Construct )
,		SchemaEntry("volume_measure_with_unit",&STEP::ObjectHelper<volume_measure_with_unit,0>::Construct )
,		SchemaEntry("volume_unit",&STEP::ObjectHelper<volume_unit,0>::Construct )
,		SchemaEntry("week_of_year_and_day_date",&STEP::ObjectHelper<week_of_year_and_day_date,2>::Construct )
,		SchemaEntry("wire_shell",&STEP::ObjectHelper<wire_shell,1>::Construct )
,		SchemaEntry("year_month",&STEP::ObjectHelper<year_month,1>::Construct )

	};
}

// -----------------------------------------------------------------------------------------------------------
void StepFile::GetSchema(EXPRESS::ConversionSchema& out)
{
	out = EXPRESS::ConversionSchema(schema_raw);
}

namespace STEP {

// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<NotImplemented>(const STEP::DB& db, const LIST& params, NotImplemented* in)
{
	return 0;
}



// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<measure_with_unit>(const DB& db, const LIST& params, measure_with_unit* in)
{
	size_t base = 0;
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to measure_with_unit"); }    do { // convert the 'value_component' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::measure_with_unit,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->value_component, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to measure_with_unit to be a `measure_value`")); }
    } while(0);
    do { // convert the 'unit_component' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::measure_with_unit,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->unit_component, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to measure_with_unit to be a `unit`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<absorbed_dose_measure_with_unit>(const DB& db, const LIST& params, absorbed_dose_measure_with_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<measure_with_unit*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to absorbed_dose_measure_with_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<derived_unit>(const DB& db, const LIST& params, derived_unit* in)
{
	size_t base = 0;
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to derived_unit"); }    do { // convert the 'elements' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::derived_unit,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->elements, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to derived_unit to be a `SET [1:?] OF derived_unit_element`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<absorbed_dose_unit>(const DB& db, const LIST& params, absorbed_dose_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<derived_unit*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to absorbed_dose_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<abstract_variable>(const DB& db, const LIST& params, abstract_variable* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<acceleration_measure_with_unit>(const DB& db, const LIST& params, acceleration_measure_with_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<measure_with_unit*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to acceleration_measure_with_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<acceleration_unit>(const DB& db, const LIST& params, acceleration_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<derived_unit*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to acceleration_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<action>(const DB& db, const LIST& params, action* in)
{
	size_t base = 0;
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to action"); }    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::action,3>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to action to be a `label`")); }
    } while(0);
    do { // convert the 'description' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::action,3>::aux_is_derived[1]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->description, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to action to be a `text`")); }
    } while(0);
    do { // convert the 'chosen_method' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::action,3>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->chosen_method, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to action to be a `action_method`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<action_assignment>(const DB& db, const LIST& params, action_assignment* in)
{
	size_t base = 0;
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to action_assignment"); }    do { // convert the 'assigned_action' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::action_assignment,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->assigned_action, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to action_assignment to be a `action`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<action_method>(const DB& db, const LIST& params, action_method* in)
{
	size_t base = 0;
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to action_method"); }    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::action_method,4>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to action_method to be a `label`")); }
    } while(0);
    do { // convert the 'description' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::action_method,4>::aux_is_derived[1]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->description, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to action_method to be a `text`")); }
    } while(0);
    do { // convert the 'consequence' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::action_method,4>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->consequence, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to action_method to be a `text`")); }
    } while(0);
    do { // convert the 'purpose' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::action_method,4>::aux_is_derived[3]=true; break; }
        try { GenericConvert( in->purpose, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to action_method to be a `text`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<action_method_assignment>(const DB& db, const LIST& params, action_method_assignment* in)
{
	size_t base = 0;
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to action_method_assignment"); }    do { // convert the 'assigned_action_method' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::action_method_assignment,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->assigned_action_method, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to action_method_assignment to be a `action_method`")); }
    } while(0);
    do { // convert the 'role' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::action_method_assignment,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->role, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to action_method_assignment to be a `action_method_role`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<action_method_relationship>(const DB& db, const LIST& params, action_method_relationship* in)
{
	size_t base = 0;
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to action_method_relationship"); }    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::action_method_relationship,4>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to action_method_relationship to be a `label`")); }
    } while(0);
    do { // convert the 'description' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::action_method_relationship,4>::aux_is_derived[1]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->description, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to action_method_relationship to be a `text`")); }
    } while(0);
    do { // convert the 'relating_method' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::action_method_relationship,4>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->relating_method, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to action_method_relationship to be a `action_method`")); }
    } while(0);
    do { // convert the 'related_method' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::action_method_relationship,4>::aux_is_derived[3]=true; break; }
        try { GenericConvert( in->related_method, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to action_method_relationship to be a `action_method`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<action_request_assignment>(const DB& db, const LIST& params, action_request_assignment* in)
{
	size_t base = 0;
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to action_request_assignment"); }    do { // convert the 'assigned_action_request' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::action_request_assignment,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->assigned_action_request, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to action_request_assignment to be a `versioned_action_request`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<address>(const DB& db, const LIST& params, address* in)
{
	size_t base = 0;
	if (params.GetSize() < 12) { throw STEP::TypeError("expected 12 arguments to address"); }    do { // convert the 'internal_location' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::address,12>::aux_is_derived[0]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->internal_location, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to address to be a `label`")); }
    } while(0);
    do { // convert the 'street_number' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::address,12>::aux_is_derived[1]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->street_number, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to address to be a `label`")); }
    } while(0);
    do { // convert the 'street' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::address,12>::aux_is_derived[2]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->street, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to address to be a `label`")); }
    } while(0);
    do { // convert the 'postal_box' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::address,12>::aux_is_derived[3]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->postal_box, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to address to be a `label`")); }
    } while(0);
    do { // convert the 'town' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::address,12>::aux_is_derived[4]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->town, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to address to be a `label`")); }
    } while(0);
    do { // convert the 'region' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::address,12>::aux_is_derived[5]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->region, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to address to be a `label`")); }
    } while(0);
    do { // convert the 'postal_code' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::address,12>::aux_is_derived[6]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->postal_code, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to address to be a `label`")); }
    } while(0);
    do { // convert the 'country' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::address,12>::aux_is_derived[7]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->country, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to address to be a `label`")); }
    } while(0);
    do { // convert the 'facsimile_number' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::address,12>::aux_is_derived[8]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->facsimile_number, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 8 to address to be a `label`")); }
    } while(0);
    do { // convert the 'telephone_number' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::address,12>::aux_is_derived[9]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->telephone_number, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 9 to address to be a `label`")); }
    } while(0);
    do { // convert the 'electronic_mail_address' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::address,12>::aux_is_derived[10]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->electronic_mail_address, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 10 to address to be a `label`")); }
    } while(0);
    do { // convert the 'telex_number' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::address,12>::aux_is_derived[11]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->telex_number, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 11 to address to be a `label`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<representation>(const DB& db, const LIST& params, representation* in)
{
	size_t base = 0;
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to representation"); }    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::representation,3>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to representation to be a `label`")); }
    } while(0);
    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::representation,3>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to representation to be a `SET [1:?] OF representation_item`")); }
    } while(0);
    do { // convert the 'context_of_items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::representation,3>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->context_of_items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to representation to be a `representation_context`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<shape_representation>(const DB& db, const LIST& params, shape_representation* in)
{
	size_t base = GenericFill(db,params,static_cast<representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to shape_representation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<advanced_brep_shape_representation>(const DB& db, const LIST& params, advanced_brep_shape_representation* in)
{
	size_t base = GenericFill(db,params,static_cast<shape_representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to advanced_brep_shape_representation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<face_surface>(const DB& db, const LIST& params, face_surface* in)
{
	size_t base = 0;
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to face_surface"); }    do { // convert the 'face_geometry' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::face_surface,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->face_geometry, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to face_surface to be a `surface`")); }
    } while(0);
    do { // convert the 'same_sense' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::face_surface,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->same_sense, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to face_surface to be a `BOOLEAN`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<advanced_face>(const DB& db, const LIST& params, advanced_face* in)
{
	size_t base = GenericFill(db,params,static_cast<face_surface*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to advanced_face"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<amount_of_substance_measure_with_unit>(const DB& db, const LIST& params, amount_of_substance_measure_with_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<measure_with_unit*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to amount_of_substance_measure_with_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<named_unit>(const DB& db, const LIST& params, named_unit* in)
{
	size_t base = 0;
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to named_unit"); }    do { // convert the 'dimensions' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::named_unit,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->dimensions, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to named_unit to be a `dimensional_exponents`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<amount_of_substance_unit>(const DB& db, const LIST& params, amount_of_substance_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<named_unit*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to amount_of_substance_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<angle_direction_reference>(const DB& db, const LIST& params, angle_direction_reference* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<representation_item>(const DB& db, const LIST& params, representation_item* in)
{
	size_t base = 0;
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to representation_item"); }    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::representation_item,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to representation_item to be a `label`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<geometric_representation_item>(const DB& db, const LIST& params, geometric_representation_item* in)
{
	size_t base = GenericFill(db,params,static_cast<representation_item*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to geometric_representation_item"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<draughting_callout>(const DB& db, const LIST& params, draughting_callout* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to draughting_callout"); }    do { // convert the 'contents' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::draughting_callout,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->contents, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to draughting_callout to be a `SET [1:?] OF draughting_callout_element`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<dimension_curve_directed_callout>(const DB& db, const LIST& params, dimension_curve_directed_callout* in)
{
	size_t base = GenericFill(db,params,static_cast<draughting_callout*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to dimension_curve_directed_callout"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<angular_dimension>(const DB& db, const LIST& params, angular_dimension* in)
{
	size_t base = GenericFill(db,params,static_cast<dimension_curve_directed_callout*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to angular_dimension"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<shape_aspect_relationship>(const DB& db, const LIST& params, shape_aspect_relationship* in)
{
	size_t base = 0;
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to shape_aspect_relationship"); }    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::shape_aspect_relationship,4>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to shape_aspect_relationship to be a `label`")); }
    } while(0);
    do { // convert the 'description' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::shape_aspect_relationship,4>::aux_is_derived[1]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->description, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to shape_aspect_relationship to be a `text`")); }
    } while(0);
    do { // convert the 'relating_shape_aspect' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::shape_aspect_relationship,4>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->relating_shape_aspect, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to shape_aspect_relationship to be a `shape_aspect`")); }
    } while(0);
    do { // convert the 'related_shape_aspect' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::shape_aspect_relationship,4>::aux_is_derived[3]=true; break; }
        try { GenericConvert( in->related_shape_aspect, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to shape_aspect_relationship to be a `shape_aspect`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<dimensional_location>(const DB& db, const LIST& params, dimensional_location* in)
{
	size_t base = GenericFill(db,params,static_cast<shape_aspect_relationship*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to dimensional_location"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<angular_location>(const DB& db, const LIST& params, angular_location* in)
{
	size_t base = GenericFill(db,params,static_cast<dimensional_location*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to angular_location"); }    do { // convert the 'angle_selection' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->angle_selection, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to angular_location to be a `angle_relator`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<dimensional_size>(const DB& db, const LIST& params, dimensional_size* in)
{
	size_t base = 0;
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to dimensional_size"); }    do { // convert the 'applies_to' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::dimensional_size,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->applies_to, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to dimensional_size to be a `shape_aspect`")); }
    } while(0);
    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::dimensional_size,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to dimensional_size to be a `label`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<angular_size>(const DB& db, const LIST& params, angular_size* in)
{
	size_t base = GenericFill(db,params,static_cast<dimensional_size*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to angular_size"); }    do { // convert the 'angle_selection' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->angle_selection, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to angular_size to be a `angle_relator`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<geometric_tolerance>(const DB& db, const LIST& params, geometric_tolerance* in)
{
	size_t base = 0;
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to geometric_tolerance"); }    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::geometric_tolerance,4>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to geometric_tolerance to be a `label`")); }
    } while(0);
    do { // convert the 'description' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::geometric_tolerance,4>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->description, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to geometric_tolerance to be a `text`")); }
    } while(0);
    do { // convert the 'magnitude' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::geometric_tolerance,4>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->magnitude, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to geometric_tolerance to be a `measure_with_unit`")); }
    } while(0);
    do { // convert the 'toleranced_shape_aspect' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::geometric_tolerance,4>::aux_is_derived[3]=true; break; }
        try { GenericConvert( in->toleranced_shape_aspect, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to geometric_tolerance to be a `shape_aspect`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<geometric_tolerance_with_datum_reference>(const DB& db, const LIST& params, geometric_tolerance_with_datum_reference* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_tolerance*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to geometric_tolerance_with_datum_reference"); }    do { // convert the 'datum_system' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::geometric_tolerance_with_datum_reference,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->datum_system, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to geometric_tolerance_with_datum_reference to be a `SET [1:?] OF datum_reference`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<angularity_tolerance>(const DB& db, const LIST& params, angularity_tolerance* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_tolerance_with_datum_reference*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to angularity_tolerance"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<styled_item>(const DB& db, const LIST& params, styled_item* in)
{
	size_t base = GenericFill(db,params,static_cast<representation_item*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to styled_item"); }    do { // convert the 'styles' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::styled_item,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->styles, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to styled_item to be a `SET [1:?] OF presentation_style_assignment`")); }
    } while(0);
    do { // convert the 'item' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::styled_item,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->item, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to styled_item to be a `representation_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<annotation_occurrence>(const DB& db, const LIST& params, annotation_occurrence* in)
{
	size_t base = GenericFill(db,params,static_cast<styled_item*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to annotation_occurrence"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<annotation_curve_occurrence>(const DB& db, const LIST& params, annotation_curve_occurrence* in)
{
	size_t base = GenericFill(db,params,static_cast<annotation_occurrence*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to annotation_curve_occurrence"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<annotation_fill_area>(const DB& db, const LIST& params, annotation_fill_area* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to annotation_fill_area"); }    do { // convert the 'boundaries' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->boundaries, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to annotation_fill_area to be a `SET [1:?] OF curve`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<annotation_fill_area_occurrence>(const DB& db, const LIST& params, annotation_fill_area_occurrence* in)
{
	size_t base = GenericFill(db,params,static_cast<annotation_occurrence*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to annotation_fill_area_occurrence"); }    do { // convert the 'fill_style_target' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->fill_style_target, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to annotation_fill_area_occurrence to be a `point`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<annotation_occurrence_relationship>(const DB& db, const LIST& params, annotation_occurrence_relationship* in)
{
	size_t base = 0;
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to annotation_occurrence_relationship"); }    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::annotation_occurrence_relationship,4>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to annotation_occurrence_relationship to be a `label`")); }
    } while(0);
    do { // convert the 'description' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::annotation_occurrence_relationship,4>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->description, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to annotation_occurrence_relationship to be a `text`")); }
    } while(0);
    do { // convert the 'relating_annotation_occurrence' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::annotation_occurrence_relationship,4>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->relating_annotation_occurrence, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to annotation_occurrence_relationship to be a `annotation_occurrence`")); }
    } while(0);
    do { // convert the 'related_annotation_occurrence' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::annotation_occurrence_relationship,4>::aux_is_derived[3]=true; break; }
        try { GenericConvert( in->related_annotation_occurrence, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to annotation_occurrence_relationship to be a `annotation_occurrence`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<annotation_occurrence_associativity>(const DB& db, const LIST& params, annotation_occurrence_associativity* in)
{
	size_t base = GenericFill(db,params,static_cast<annotation_occurrence_relationship*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to annotation_occurrence_associativity"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<annotation_plane>(const DB& db, const LIST& params, annotation_plane* in)
{
	size_t base = 0;
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to annotation_plane"); }    do { // convert the 'elements' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->elements, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to annotation_plane to be a `SET [1:?] OF annotation_plane_element`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<annotation_symbol_occurrence>(const DB& db, const LIST& params, annotation_symbol_occurrence* in)
{
	size_t base = GenericFill(db,params,static_cast<annotation_occurrence*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to annotation_symbol_occurrence"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<annotation_subfigure_occurrence>(const DB& db, const LIST& params, annotation_subfigure_occurrence* in)
{
	size_t base = GenericFill(db,params,static_cast<annotation_symbol_occurrence*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to annotation_subfigure_occurrence"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<mapped_item>(const DB& db, const LIST& params, mapped_item* in)
{
	size_t base = GenericFill(db,params,static_cast<representation_item*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to mapped_item"); }    do { // convert the 'mapping_source' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::mapped_item,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->mapping_source, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to mapped_item to be a `representation_map`")); }
    } while(0);
    do { // convert the 'mapping_target' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::mapped_item,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->mapping_target, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to mapped_item to be a `representation_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<annotation_symbol>(const DB& db, const LIST& params, annotation_symbol* in)
{
	size_t base = GenericFill(db,params,static_cast<mapped_item*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to annotation_symbol"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<annotation_text>(const DB& db, const LIST& params, annotation_text* in)
{
	size_t base = GenericFill(db,params,static_cast<mapped_item*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to annotation_text"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<annotation_text_character>(const DB& db, const LIST& params, annotation_text_character* in)
{
	size_t base = GenericFill(db,params,static_cast<mapped_item*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to annotation_text_character"); }    do { // convert the 'alignment' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->alignment, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to annotation_text_character to be a `text_alignment`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<annotation_text_occurrence>(const DB& db, const LIST& params, annotation_text_occurrence* in)
{
	size_t base = GenericFill(db,params,static_cast<annotation_occurrence*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to annotation_text_occurrence"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<shape_aspect>(const DB& db, const LIST& params, shape_aspect* in)
{
	size_t base = 0;
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to shape_aspect"); }    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::shape_aspect,4>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to shape_aspect to be a `label`")); }
    } while(0);
    do { // convert the 'description' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::shape_aspect,4>::aux_is_derived[1]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->description, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to shape_aspect to be a `text`")); }
    } while(0);
    do { // convert the 'of_shape' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::shape_aspect,4>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->of_shape, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to shape_aspect to be a `product_definition_shape`")); }
    } while(0);
    do { // convert the 'product_definitional' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::shape_aspect,4>::aux_is_derived[3]=true; break; }
        try { GenericConvert( in->product_definitional, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to shape_aspect to be a `LOGICAL`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<derived_shape_aspect>(const DB& db, const LIST& params, derived_shape_aspect* in)
{
	size_t base = GenericFill(db,params,static_cast<shape_aspect*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to derived_shape_aspect"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<apex>(const DB& db, const LIST& params, apex* in)
{
	size_t base = GenericFill(db,params,static_cast<derived_shape_aspect*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to apex"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<application_context_element>(const DB& db, const LIST& params, application_context_element* in)
{
	size_t base = 0;
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to application_context_element"); }    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::application_context_element,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to application_context_element to be a `label`")); }
    } while(0);
    do { // convert the 'frame_of_reference' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::application_context_element,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->frame_of_reference, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to application_context_element to be a `application_context`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<applied_action_assignment>(const DB& db, const LIST& params, applied_action_assignment* in)
{
	size_t base = GenericFill(db,params,static_cast<action_assignment*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to applied_action_assignment"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::applied_action_assignment,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to applied_action_assignment to be a `SET [1:?] OF action_items`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<applied_action_method_assignment>(const DB& db, const LIST& params, applied_action_method_assignment* in)
{
	size_t base = GenericFill(db,params,static_cast<action_method_assignment*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to applied_action_method_assignment"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to applied_action_method_assignment to be a `SET [1:?] OF action_method_items`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<applied_action_request_assignment>(const DB& db, const LIST& params, applied_action_request_assignment* in)
{
	size_t base = GenericFill(db,params,static_cast<action_request_assignment*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to applied_action_request_assignment"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to applied_action_request_assignment to be a `SET [1:?] OF action_request_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<approval_assignment>(const DB& db, const LIST& params, approval_assignment* in)
{
	size_t base = 0;
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to approval_assignment"); }    do { // convert the 'assigned_approval' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::approval_assignment,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->assigned_approval, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to approval_assignment to be a `approval`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<applied_approval_assignment>(const DB& db, const LIST& params, applied_approval_assignment* in)
{
	size_t base = GenericFill(db,params,static_cast<approval_assignment*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to applied_approval_assignment"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to applied_approval_assignment to be a `SET [1:?] OF approval_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<attribute_classification_assignment>(const DB& db, const LIST& params, attribute_classification_assignment* in)
{
	size_t base = 0;
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to attribute_classification_assignment"); }    do { // convert the 'assigned_class' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::attribute_classification_assignment,3>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->assigned_class, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to attribute_classification_assignment to be a `group`")); }
    } while(0);
    do { // convert the 'attribute_name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::attribute_classification_assignment,3>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->attribute_name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to attribute_classification_assignment to be a `label`")); }
    } while(0);
    do { // convert the 'role' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::attribute_classification_assignment,3>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->role, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to attribute_classification_assignment to be a `classification_role`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<applied_attribute_classification_assignment>(const DB& db, const LIST& params, applied_attribute_classification_assignment* in)
{
	size_t base = GenericFill(db,params,static_cast<attribute_classification_assignment*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to applied_attribute_classification_assignment"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to applied_attribute_classification_assignment to be a `SET [1:?] OF attribute_classification_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<certification_assignment>(const DB& db, const LIST& params, certification_assignment* in)
{
	size_t base = 0;
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to certification_assignment"); }    do { // convert the 'assigned_certification' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::certification_assignment,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->assigned_certification, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to certification_assignment to be a `certification`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<applied_certification_assignment>(const DB& db, const LIST& params, applied_certification_assignment* in)
{
	size_t base = GenericFill(db,params,static_cast<certification_assignment*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to applied_certification_assignment"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to applied_certification_assignment to be a `SET [1:?] OF certification_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<classification_assignment>(const DB& db, const LIST& params, classification_assignment* in)
{
	size_t base = 0;
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to classification_assignment"); }    do { // convert the 'assigned_class' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::classification_assignment,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->assigned_class, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to classification_assignment to be a `group`")); }
    } while(0);
    do { // convert the 'role' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::classification_assignment,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->role, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to classification_assignment to be a `classification_role`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<applied_classification_assignment>(const DB& db, const LIST& params, applied_classification_assignment* in)
{
	size_t base = GenericFill(db,params,static_cast<classification_assignment*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to applied_classification_assignment"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to applied_classification_assignment to be a `SET [1:?] OF classification_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<contract_assignment>(const DB& db, const LIST& params, contract_assignment* in)
{
	size_t base = 0;
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to contract_assignment"); }    do { // convert the 'assigned_contract' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::contract_assignment,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->assigned_contract, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to contract_assignment to be a `contract`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<applied_contract_assignment>(const DB& db, const LIST& params, applied_contract_assignment* in)
{
	size_t base = GenericFill(db,params,static_cast<contract_assignment*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to applied_contract_assignment"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to applied_contract_assignment to be a `SET [1:?] OF contract_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<date_and_time_assignment>(const DB& db, const LIST& params, date_and_time_assignment* in)
{
	size_t base = 0;
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to date_and_time_assignment"); }    do { // convert the 'assigned_date_and_time' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::date_and_time_assignment,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->assigned_date_and_time, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to date_and_time_assignment to be a `date_and_time`")); }
    } while(0);
    do { // convert the 'role' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::date_and_time_assignment,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->role, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to date_and_time_assignment to be a `date_time_role`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<applied_date_and_time_assignment>(const DB& db, const LIST& params, applied_date_and_time_assignment* in)
{
	size_t base = GenericFill(db,params,static_cast<date_and_time_assignment*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to applied_date_and_time_assignment"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to applied_date_and_time_assignment to be a `SET [1:?] OF date_and_time_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<date_assignment>(const DB& db, const LIST& params, date_assignment* in)
{
	size_t base = 0;
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to date_assignment"); }    do { // convert the 'assigned_date' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::date_assignment,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->assigned_date, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to date_assignment to be a `date`")); }
    } while(0);
    do { // convert the 'role' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::date_assignment,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->role, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to date_assignment to be a `date_role`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<applied_date_assignment>(const DB& db, const LIST& params, applied_date_assignment* in)
{
	size_t base = GenericFill(db,params,static_cast<date_assignment*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to applied_date_assignment"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to applied_date_assignment to be a `SET [1:?] OF date_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<document_reference>(const DB& db, const LIST& params, document_reference* in)
{
	size_t base = 0;
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to document_reference"); }    do { // convert the 'assigned_document' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::document_reference,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->assigned_document, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to document_reference to be a `document`")); }
    } while(0);
    do { // convert the 'source' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::document_reference,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->source, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to document_reference to be a `label`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<applied_document_reference>(const DB& db, const LIST& params, applied_document_reference* in)
{
	size_t base = GenericFill(db,params,static_cast<document_reference*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to applied_document_reference"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to applied_document_reference to be a `SET [1:?] OF document_reference_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<document_usage_constraint_assignment>(const DB& db, const LIST& params, document_usage_constraint_assignment* in)
{
	size_t base = 0;
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to document_usage_constraint_assignment"); }    do { // convert the 'assigned_document_usage' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::document_usage_constraint_assignment,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->assigned_document_usage, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to document_usage_constraint_assignment to be a `document_usage_constraint`")); }
    } while(0);
    do { // convert the 'role' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::document_usage_constraint_assignment,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->role, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to document_usage_constraint_assignment to be a `document_usage_role`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<applied_document_usage_constraint_assignment>(const DB& db, const LIST& params, applied_document_usage_constraint_assignment* in)
{
	size_t base = GenericFill(db,params,static_cast<document_usage_constraint_assignment*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to applied_document_usage_constraint_assignment"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to applied_document_usage_constraint_assignment to be a `SET [1:?] OF document_reference_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<effectivity_assignment>(const DB& db, const LIST& params, effectivity_assignment* in)
{
	size_t base = 0;
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to effectivity_assignment"); }    do { // convert the 'assigned_effectivity' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::effectivity_assignment,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->assigned_effectivity, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to effectivity_assignment to be a `effectivity`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<applied_effectivity_assignment>(const DB& db, const LIST& params, applied_effectivity_assignment* in)
{
	size_t base = GenericFill(db,params,static_cast<effectivity_assignment*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to applied_effectivity_assignment"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to applied_effectivity_assignment to be a `SET [1:?] OF effectivity_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<event_occurrence_assignment>(const DB& db, const LIST& params, event_occurrence_assignment* in)
{
	size_t base = 0;
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to event_occurrence_assignment"); }    do { // convert the 'assigned_event_occurrence' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::event_occurrence_assignment,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->assigned_event_occurrence, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to event_occurrence_assignment to be a `event_occurrence`")); }
    } while(0);
    do { // convert the 'role' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::event_occurrence_assignment,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->role, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to event_occurrence_assignment to be a `event_occurrence_role`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<applied_event_occurrence_assignment>(const DB& db, const LIST& params, applied_event_occurrence_assignment* in)
{
	size_t base = GenericFill(db,params,static_cast<event_occurrence_assignment*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to applied_event_occurrence_assignment"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to applied_event_occurrence_assignment to be a `SET [1:?] OF event_occurrence_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<identification_assignment>(const DB& db, const LIST& params, identification_assignment* in)
{
	size_t base = 0;
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to identification_assignment"); }    do { // convert the 'assigned_id' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::identification_assignment,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->assigned_id, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to identification_assignment to be a `identifier`")); }
    } while(0);
    do { // convert the 'role' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::identification_assignment,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->role, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to identification_assignment to be a `identification_role`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<external_identification_assignment>(const DB& db, const LIST& params, external_identification_assignment* in)
{
	size_t base = GenericFill(db,params,static_cast<identification_assignment*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to external_identification_assignment"); }    do { // convert the 'source' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::external_identification_assignment,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->source, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to external_identification_assignment to be a `external_source`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<applied_external_identification_assignment>(const DB& db, const LIST& params, applied_external_identification_assignment* in)
{
	size_t base = GenericFill(db,params,static_cast<external_identification_assignment*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to applied_external_identification_assignment"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to applied_external_identification_assignment to be a `SET [1:?] OF external_identification_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<group_assignment>(const DB& db, const LIST& params, group_assignment* in)
{
	size_t base = 0;
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to group_assignment"); }    do { // convert the 'assigned_group' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::group_assignment,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->assigned_group, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to group_assignment to be a `group`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<applied_group_assignment>(const DB& db, const LIST& params, applied_group_assignment* in)
{
	size_t base = GenericFill(db,params,static_cast<group_assignment*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to applied_group_assignment"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to applied_group_assignment to be a `SET [1:?] OF groupable_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<applied_identification_assignment>(const DB& db, const LIST& params, applied_identification_assignment* in)
{
	size_t base = GenericFill(db,params,static_cast<identification_assignment*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to applied_identification_assignment"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to applied_identification_assignment to be a `SET [1:?] OF identification_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<name_assignment>(const DB& db, const LIST& params, name_assignment* in)
{
	size_t base = 0;
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to name_assignment"); }    do { // convert the 'assigned_name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::name_assignment,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->assigned_name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to name_assignment to be a `label`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<applied_name_assignment>(const DB& db, const LIST& params, applied_name_assignment* in)
{
	size_t base = GenericFill(db,params,static_cast<name_assignment*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to applied_name_assignment"); }    do { // convert the 'item' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->item, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to applied_name_assignment to be a `name_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<organization_assignment>(const DB& db, const LIST& params, organization_assignment* in)
{
	size_t base = 0;
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to organization_assignment"); }    do { // convert the 'assigned_organization' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::organization_assignment,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->assigned_organization, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to organization_assignment to be a `organization`")); }
    } while(0);
    do { // convert the 'role' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::organization_assignment,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->role, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to organization_assignment to be a `organization_role`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<applied_organization_assignment>(const DB& db, const LIST& params, applied_organization_assignment* in)
{
	size_t base = GenericFill(db,params,static_cast<organization_assignment*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to applied_organization_assignment"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to applied_organization_assignment to be a `SET [1:?] OF organization_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<organizational_project_assignment>(const DB& db, const LIST& params, organizational_project_assignment* in)
{
	size_t base = 0;
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to organizational_project_assignment"); }    do { // convert the 'assigned_organizational_project' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::organizational_project_assignment,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->assigned_organizational_project, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to organizational_project_assignment to be a `organizational_project`")); }
    } while(0);
    do { // convert the 'role' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::organizational_project_assignment,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->role, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to organizational_project_assignment to be a `organizational_project_role`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<applied_organizational_project_assignment>(const DB& db, const LIST& params, applied_organizational_project_assignment* in)
{
	size_t base = GenericFill(db,params,static_cast<organizational_project_assignment*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to applied_organizational_project_assignment"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to applied_organizational_project_assignment to be a `SET [1:?] OF project_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<person_and_organization_assignment>(const DB& db, const LIST& params, person_and_organization_assignment* in)
{
	size_t base = 0;
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to person_and_organization_assignment"); }    do { // convert the 'assigned_person_and_organization' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::person_and_organization_assignment,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->assigned_person_and_organization, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to person_and_organization_assignment to be a `person_and_organization`")); }
    } while(0);
    do { // convert the 'role' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::person_and_organization_assignment,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->role, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to person_and_organization_assignment to be a `person_and_organization_role`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<applied_person_and_organization_assignment>(const DB& db, const LIST& params, applied_person_and_organization_assignment* in)
{
	size_t base = GenericFill(db,params,static_cast<person_and_organization_assignment*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to applied_person_and_organization_assignment"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to applied_person_and_organization_assignment to be a `SET [1:?] OF person_and_organization_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<presented_item>(const DB& db, const LIST& params, presented_item* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<applied_presented_item>(const DB& db, const LIST& params, applied_presented_item* in)
{
	size_t base = GenericFill(db,params,static_cast<presented_item*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to applied_presented_item"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to applied_presented_item to be a `SET [1:?] OF presented_item_select`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<security_classification_assignment>(const DB& db, const LIST& params, security_classification_assignment* in)
{
	size_t base = 0;
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to security_classification_assignment"); }    do { // convert the 'assigned_security_classification' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::security_classification_assignment,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->assigned_security_classification, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to security_classification_assignment to be a `security_classification`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<applied_security_classification_assignment>(const DB& db, const LIST& params, applied_security_classification_assignment* in)
{
	size_t base = GenericFill(db,params,static_cast<security_classification_assignment*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to applied_security_classification_assignment"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to applied_security_classification_assignment to be a `SET [1:?] OF security_classification_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<time_interval_assignment>(const DB& db, const LIST& params, time_interval_assignment* in)
{
	size_t base = 0;
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to time_interval_assignment"); }    do { // convert the 'assigned_time_interval' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::time_interval_assignment,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->assigned_time_interval, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to time_interval_assignment to be a `time_interval`")); }
    } while(0);
    do { // convert the 'role' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::time_interval_assignment,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->role, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to time_interval_assignment to be a `time_interval_role`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<applied_time_interval_assignment>(const DB& db, const LIST& params, applied_time_interval_assignment* in)
{
	size_t base = GenericFill(db,params,static_cast<time_interval_assignment*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to applied_time_interval_assignment"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to applied_time_interval_assignment to be a `SET [0:?] OF time_interval_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<applied_usage_right>(const DB& db, const LIST& params, applied_usage_right* in)
{
	size_t base = GenericFill(db,params,static_cast<applied_action_assignment*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to applied_usage_right"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<area_in_set>(const DB& db, const LIST& params, area_in_set* in)
{
	size_t base = 0;
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to area_in_set"); }    do { // convert the 'area' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::area_in_set,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->area, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to area_in_set to be a `presentation_area`")); }
    } while(0);
    do { // convert the 'in_set' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::area_in_set,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->in_set, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to area_in_set to be a `presentation_set`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<area_measure_with_unit>(const DB& db, const LIST& params, area_measure_with_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<measure_with_unit*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to area_measure_with_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<area_unit>(const DB& db, const LIST& params, area_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<derived_unit*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to area_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<product_definition_relationship>(const DB& db, const LIST& params, product_definition_relationship* in)
{
	size_t base = 0;
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to product_definition_relationship"); }    do { // convert the 'id' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::product_definition_relationship,5>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->id, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to product_definition_relationship to be a `identifier`")); }
    } while(0);
    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::product_definition_relationship,5>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to product_definition_relationship to be a `label`")); }
    } while(0);
    do { // convert the 'description' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::product_definition_relationship,5>::aux_is_derived[2]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->description, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to product_definition_relationship to be a `text`")); }
    } while(0);
    do { // convert the 'relating_product_definition' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::product_definition_relationship,5>::aux_is_derived[3]=true; break; }
        try { GenericConvert( in->relating_product_definition, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to product_definition_relationship to be a `product_definition`")); }
    } while(0);
    do { // convert the 'related_product_definition' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::product_definition_relationship,5>::aux_is_derived[4]=true; break; }
        try { GenericConvert( in->related_product_definition, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to product_definition_relationship to be a `product_definition`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<product_definition_usage>(const DB& db, const LIST& params, product_definition_usage* in)
{
	size_t base = GenericFill(db,params,static_cast<product_definition_relationship*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to product_definition_usage"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<assembly_component_usage>(const DB& db, const LIST& params, assembly_component_usage* in)
{
	size_t base = GenericFill(db,params,static_cast<product_definition_usage*>(in));
	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to assembly_component_usage"); }    do { // convert the 'reference_designator' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::assembly_component_usage,1>::aux_is_derived[0]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->reference_designator, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to assembly_component_usage to be a `identifier`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<assigned_requirement>(const DB& db, const LIST& params, assigned_requirement* in)
{
	size_t base = GenericFill(db,params,static_cast<group_assignment*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to assigned_requirement"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to assigned_requirement to be a `SET [1:1] OF product_definition`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<compound_representation_item>(const DB& db, const LIST& params, compound_representation_item* in)
{
	size_t base = GenericFill(db,params,static_cast<representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to compound_representation_item"); }    do { // convert the 'item_element' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::compound_representation_item,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->item_element, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to compound_representation_item to be a `compound_item_definition`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<atomic_formula>(const DB& db, const LIST& params, atomic_formula* in)
{
	size_t base = GenericFill(db,params,static_cast<compound_representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to atomic_formula"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<attribute_assertion>(const DB& db, const LIST& params, attribute_assertion* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<attribute_language_assignment>(const DB& db, const LIST& params, attribute_language_assignment* in)
{
	size_t base = GenericFill(db,params,static_cast<attribute_classification_assignment*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to attribute_language_assignment"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to attribute_language_assignment to be a `SET [1:?] OF attribute_language_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<attribute_value_assignment>(const DB& db, const LIST& params, attribute_value_assignment* in)
{
	size_t base = 0;
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to attribute_value_assignment"); }    do { // convert the 'attribute_name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::attribute_value_assignment,3>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->attribute_name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to attribute_value_assignment to be a `label`")); }
    } while(0);
    do { // convert the 'attribute_value' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::attribute_value_assignment,3>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->attribute_value, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to attribute_value_assignment to be a `attribute_type`")); }
    } while(0);
    do { // convert the 'role' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::attribute_value_assignment,3>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->role, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to attribute_value_assignment to be a `attribute_value_role`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<auxiliary_geometric_representation_item>(const DB& db, const LIST& params, auxiliary_geometric_representation_item* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<placement>(const DB& db, const LIST& params, placement* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to placement"); }    do { // convert the 'location' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::placement,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->location, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to placement to be a `cartesian_point`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<axis1_placement>(const DB& db, const LIST& params, axis1_placement* in)
{
	size_t base = GenericFill(db,params,static_cast<placement*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to axis1_placement"); }    do { // convert the 'axis' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->axis, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to axis1_placement to be a `direction`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<axis2_placement_2d>(const DB& db, const LIST& params, axis2_placement_2d* in)
{
	size_t base = GenericFill(db,params,static_cast<placement*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to axis2_placement_2d"); }    do { // convert the 'ref_direction' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->ref_direction, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to axis2_placement_2d to be a `direction`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<axis2_placement_3d>(const DB& db, const LIST& params, axis2_placement_3d* in)
{
	size_t base = GenericFill(db,params,static_cast<placement*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to axis2_placement_3d"); }    do { // convert the 'axis' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->axis, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to axis2_placement_3d to be a `direction`")); }
    } while(0);
    do { // convert the 'ref_direction' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->ref_direction, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to axis2_placement_3d to be a `direction`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<curve>(const DB& db, const LIST& params, curve* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_representation_item*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to curve"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<bounded_curve>(const DB& db, const LIST& params, bounded_curve* in)
{
	size_t base = GenericFill(db,params,static_cast<curve*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to bounded_curve"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<b_spline_curve>(const DB& db, const LIST& params, b_spline_curve* in)
{
	size_t base = GenericFill(db,params,static_cast<bounded_curve*>(in));
	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to b_spline_curve"); }    do { // convert the 'degree' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::b_spline_curve,5>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->degree, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to b_spline_curve to be a `INTEGER`")); }
    } while(0);
    do { // convert the 'control_points_list' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::b_spline_curve,5>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->control_points_list, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to b_spline_curve to be a `LIST [2:?] OF cartesian_point`")); }
    } while(0);
    do { // convert the 'curve_form' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::b_spline_curve,5>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->curve_form, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to b_spline_curve to be a `b_spline_curve_form`")); }
    } while(0);
    do { // convert the 'closed_curve' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::b_spline_curve,5>::aux_is_derived[3]=true; break; }
        try { GenericConvert( in->closed_curve, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to b_spline_curve to be a `LOGICAL`")); }
    } while(0);
    do { // convert the 'self_intersect' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::b_spline_curve,5>::aux_is_derived[4]=true; break; }
        try { GenericConvert( in->self_intersect, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to b_spline_curve to be a `LOGICAL`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<b_spline_curve_with_knots>(const DB& db, const LIST& params, b_spline_curve_with_knots* in)
{
	size_t base = GenericFill(db,params,static_cast<b_spline_curve*>(in));
	if (params.GetSize() < 9) { throw STEP::TypeError("expected 9 arguments to b_spline_curve_with_knots"); }    do { // convert the 'knot_multiplicities' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->knot_multiplicities, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to b_spline_curve_with_knots to be a `LIST [2:?] OF INTEGER`")); }
    } while(0);
    do { // convert the 'knots' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->knots, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to b_spline_curve_with_knots to be a `LIST [2:?] OF parameter_value`")); }
    } while(0);
    do { // convert the 'knot_spec' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->knot_spec, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 8 to b_spline_curve_with_knots to be a `knot_type`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<surface>(const DB& db, const LIST& params, surface* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_representation_item*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to surface"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<bounded_surface>(const DB& db, const LIST& params, bounded_surface* in)
{
	size_t base = GenericFill(db,params,static_cast<surface*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to bounded_surface"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<b_spline_surface>(const DB& db, const LIST& params, b_spline_surface* in)
{
	size_t base = GenericFill(db,params,static_cast<bounded_surface*>(in));
	if (params.GetSize() < 7) { throw STEP::TypeError("expected 7 arguments to b_spline_surface"); }    do { // convert the 'u_degree' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::b_spline_surface,6>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->u_degree, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to b_spline_surface to be a `INTEGER`")); }
    } while(0);
    do { // convert the 'v_degree' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::b_spline_surface,6>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->v_degree, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to b_spline_surface to be a `INTEGER`")); }
    } while(0);
    do { // convert the 'surface_form' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::b_spline_surface,6>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->surface_form, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to b_spline_surface to be a `b_spline_surface_form`")); }
    } while(0);
    do { // convert the 'u_closed' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::b_spline_surface,6>::aux_is_derived[3]=true; break; }
        try { GenericConvert( in->u_closed, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to b_spline_surface to be a `LOGICAL`")); }
    } while(0);
    do { // convert the 'v_closed' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::b_spline_surface,6>::aux_is_derived[4]=true; break; }
        try { GenericConvert( in->v_closed, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to b_spline_surface to be a `LOGICAL`")); }
    } while(0);
    do { // convert the 'self_intersect' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::b_spline_surface,6>::aux_is_derived[5]=true; break; }
        try { GenericConvert( in->self_intersect, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to b_spline_surface to be a `LOGICAL`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<b_spline_surface_with_knots>(const DB& db, const LIST& params, b_spline_surface_with_knots* in)
{
	size_t base = GenericFill(db,params,static_cast<b_spline_surface*>(in));
	if (params.GetSize() < 12) { throw STEP::TypeError("expected 12 arguments to b_spline_surface_with_knots"); }    do { // convert the 'u_multiplicities' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->u_multiplicities, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to b_spline_surface_with_knots to be a `LIST [2:?] OF INTEGER`")); }
    } while(0);
    do { // convert the 'v_multiplicities' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->v_multiplicities, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 8 to b_spline_surface_with_knots to be a `LIST [2:?] OF INTEGER`")); }
    } while(0);
    do { // convert the 'u_knots' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->u_knots, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 9 to b_spline_surface_with_knots to be a `LIST [2:?] OF parameter_value`")); }
    } while(0);
    do { // convert the 'v_knots' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->v_knots, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 10 to b_spline_surface_with_knots to be a `LIST [2:?] OF parameter_value`")); }
    } while(0);
    do { // convert the 'knot_spec' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->knot_spec, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 11 to b_spline_surface_with_knots to be a `knot_type`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<product_definition>(const DB& db, const LIST& params, product_definition* in)
{
	size_t base = 0;
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to product_definition"); }    do { // convert the 'id' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::product_definition,4>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->id, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to product_definition to be a `identifier`")); }
    } while(0);
    do { // convert the 'description' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::product_definition,4>::aux_is_derived[1]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->description, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to product_definition to be a `text`")); }
    } while(0);
    do { // convert the 'formation' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::product_definition,4>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->formation, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to product_definition to be a `product_definition_formation`")); }
    } while(0);
    do { // convert the 'frame_of_reference' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::product_definition,4>::aux_is_derived[3]=true; break; }
        try { GenericConvert( in->frame_of_reference, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to product_definition to be a `product_definition_context`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<rule_software_definition>(const DB& db, const LIST& params, rule_software_definition* in)
{
	size_t base = GenericFill(db,params,static_cast<product_definition*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to rule_software_definition"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<rule_definition>(const DB& db, const LIST& params, rule_definition* in)
{
	size_t base = GenericFill(db,params,static_cast<rule_software_definition*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to rule_definition"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<back_chaining_rule>(const DB& db, const LIST& params, back_chaining_rule* in)
{
	size_t base = GenericFill(db,params,static_cast<rule_definition*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to back_chaining_rule"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<back_chaining_rule_body>(const DB& db, const LIST& params, back_chaining_rule_body* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<colour>(const DB& db, const LIST& params, colour* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<background_colour>(const DB& db, const LIST& params, background_colour* in)
{
	size_t base = GenericFill(db,params,static_cast<colour*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to background_colour"); }    do { // convert the 'presentation' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->presentation, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to background_colour to be a `area_or_view`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<beveled_sheet_representation>(const DB& db, const LIST& params, beveled_sheet_representation* in)
{
	size_t base = GenericFill(db,params,static_cast<shape_representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to beveled_sheet_representation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<bezier_curve>(const DB& db, const LIST& params, bezier_curve* in)
{
	size_t base = GenericFill(db,params,static_cast<b_spline_curve*>(in));
	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to bezier_curve"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<bezier_surface>(const DB& db, const LIST& params, bezier_surface* in)
{
	size_t base = GenericFill(db,params,static_cast<b_spline_surface*>(in));
	if (params.GetSize() < 7) { throw STEP::TypeError("expected 7 arguments to bezier_surface"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<generic_expression>(const DB& db, const LIST& params, generic_expression* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<binary_generic_expression>(const DB& db, const LIST& params, binary_generic_expression* in)
{
	size_t base = GenericFill(db,params,static_cast<generic_expression*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to binary_generic_expression"); }    do { // convert the 'operands' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->operands, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to binary_generic_expression to be a `LIST [2:2] OF generic_expression`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<binary_numeric_expression>(const DB& db, const LIST& params, binary_numeric_expression* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<binary_representation_item>(const DB& db, const LIST& params, binary_representation_item* in)
{
	size_t base = GenericFill(db,params,static_cast<representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to binary_representation_item"); }    do { // convert the 'binary_value' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::binary_representation_item,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->binary_value, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to binary_representation_item to be a `BINARY`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<block>(const DB& db, const LIST& params, block* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_representation_item*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to block"); }    do { // convert the 'position' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->position, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to block to be a `axis2_placement_3d`")); }
    } while(0);
    do { // convert the 'x' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->x, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to block to be a `positive_length_measure`")); }
    } while(0);
    do { // convert the 'y' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->y, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to block to be a `positive_length_measure`")); }
    } while(0);
    do { // convert the 'z' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->z, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to block to be a `positive_length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<expression>(const DB& db, const LIST& params, expression* in)
{
	size_t base = GenericFill(db,params,static_cast<generic_expression*>(in));
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<boolean_expression>(const DB& db, const LIST& params, boolean_expression* in)
{
	size_t base = GenericFill(db,params,static_cast<expression*>(in));
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<boolean_literal>(const DB& db, const LIST& params, boolean_literal* in)
{
	size_t base = 0;
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to boolean_literal"); }    do { // convert the 'the_value' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->the_value, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to boolean_literal to be a `BOOLEAN`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<boolean_representation_item>(const DB& db, const LIST& params, boolean_representation_item* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<boolean_result>(const DB& db, const LIST& params, boolean_result* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_representation_item*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to boolean_result"); }    do { // convert the 'operator' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->operator_, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to boolean_result to be a `boolean_operator`")); }
    } while(0);
    do { // convert the 'first_operand' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->first_operand, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to boolean_result to be a `boolean_operand`")); }
    } while(0);
    do { // convert the 'second_operand' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->second_operand, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to boolean_result to be a `boolean_operand`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<composite_curve>(const DB& db, const LIST& params, composite_curve* in)
{
	size_t base = GenericFill(db,params,static_cast<bounded_curve*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to composite_curve"); }    do { // convert the 'segments' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::composite_curve,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->segments, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to composite_curve to be a `LIST [1:?] OF composite_curve_segment`")); }
    } while(0);
    do { // convert the 'self_intersect' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::composite_curve,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->self_intersect, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to composite_curve to be a `LOGICAL`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<composite_curve_on_surface>(const DB& db, const LIST& params, composite_curve_on_surface* in)
{
	size_t base = GenericFill(db,params,static_cast<composite_curve*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to composite_curve_on_surface"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<boundary_curve>(const DB& db, const LIST& params, boundary_curve* in)
{
	size_t base = GenericFill(db,params,static_cast<composite_curve_on_surface*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to boundary_curve"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<bounded_pcurve>(const DB& db, const LIST& params, bounded_pcurve* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<bounded_surface_curve>(const DB& db, const LIST& params, bounded_surface_curve* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<founded_item>(const DB& db, const LIST& params, founded_item* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<box_domain>(const DB& db, const LIST& params, box_domain* in)
{
	size_t base = GenericFill(db,params,static_cast<founded_item*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to box_domain"); }    do { // convert the 'corner' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->corner, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to box_domain to be a `cartesian_point`")); }
    } while(0);
    do { // convert the 'xlength' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->xlength, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to box_domain to be a `positive_length_measure`")); }
    } while(0);
    do { // convert the 'ylength' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->ylength, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to box_domain to be a `positive_length_measure`")); }
    } while(0);
    do { // convert the 'zlength' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->zlength, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to box_domain to be a `positive_length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<half_space_solid>(const DB& db, const LIST& params, half_space_solid* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_representation_item*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to half_space_solid"); }    do { // convert the 'base_surface' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::half_space_solid,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->base_surface, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to half_space_solid to be a `surface`")); }
    } while(0);
    do { // convert the 'agreement_flag' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::half_space_solid,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->agreement_flag, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to half_space_solid to be a `BOOLEAN`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<boxed_half_space>(const DB& db, const LIST& params, boxed_half_space* in)
{
	size_t base = GenericFill(db,params,static_cast<half_space_solid*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to boxed_half_space"); }    do { // convert the 'enclosure' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->enclosure, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to boxed_half_space to be a `box_domain`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<breakdown_context>(const DB& db, const LIST& params, breakdown_context* in)
{
	size_t base = GenericFill(db,params,static_cast<product_definition_relationship*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to breakdown_context"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<breakdown_element_group_assignment>(const DB& db, const LIST& params, breakdown_element_group_assignment* in)
{
	size_t base = GenericFill(db,params,static_cast<group_assignment*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to breakdown_element_group_assignment"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to breakdown_element_group_assignment to be a `SET [1:1] OF product_definition_or_breakdown_element_usage`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<breakdown_element_realization>(const DB& db, const LIST& params, breakdown_element_realization* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<breakdown_element_usage>(const DB& db, const LIST& params, breakdown_element_usage* in)
{
	size_t base = GenericFill(db,params,static_cast<product_definition_relationship*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to breakdown_element_usage"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<breakdown_of>(const DB& db, const LIST& params, breakdown_of* in)
{
	size_t base = GenericFill(db,params,static_cast<product_definition_relationship*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to breakdown_of"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<solid_model>(const DB& db, const LIST& params, solid_model* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_representation_item*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to solid_model"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<manifold_solid_brep>(const DB& db, const LIST& params, manifold_solid_brep* in)
{
	size_t base = GenericFill(db,params,static_cast<solid_model*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to manifold_solid_brep"); }    do { // convert the 'outer' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::manifold_solid_brep,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->outer, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to manifold_solid_brep to be a `closed_shell`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<brep_with_voids>(const DB& db, const LIST& params, brep_with_voids* in)
{
	size_t base = GenericFill(db,params,static_cast<manifold_solid_brep*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to brep_with_voids"); }    do { // convert the 'voids' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->voids, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to brep_with_voids to be a `SET [1:?] OF oriented_closed_shell`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<bytes_representation_item>(const DB& db, const LIST& params, bytes_representation_item* in)
{
	size_t base = GenericFill(db,params,static_cast<binary_representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to bytes_representation_item"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<date>(const DB& db, const LIST& params, date* in)
{
	size_t base = 0;
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to date"); }    do { // convert the 'year_component' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::date,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->year_component, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to date to be a `year_number`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<calendar_date>(const DB& db, const LIST& params, calendar_date* in)
{
	size_t base = GenericFill(db,params,static_cast<date*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to calendar_date"); }    do { // convert the 'day_component' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->day_component, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to calendar_date to be a `day_in_month_number`")); }
    } while(0);
    do { // convert the 'month_component' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->month_component, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to calendar_date to be a `month_in_year_number`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<camera_image>(const DB& db, const LIST& params, camera_image* in)
{
	size_t base = GenericFill(db,params,static_cast<mapped_item*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to camera_image"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<camera_image_3d_with_scale>(const DB& db, const LIST& params, camera_image_3d_with_scale* in)
{
	size_t base = GenericFill(db,params,static_cast<camera_image*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to camera_image_3d_with_scale"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<camera_model>(const DB& db, const LIST& params, camera_model* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_representation_item*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to camera_model"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<camera_model_d3>(const DB& db, const LIST& params, camera_model_d3* in)
{
	size_t base = GenericFill(db,params,static_cast<camera_model*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to camera_model_d3"); }    do { // convert the 'view_reference_system' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::camera_model_d3,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->view_reference_system, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to camera_model_d3 to be a `axis2_placement_3d`")); }
    } while(0);
    do { // convert the 'perspective_of_volume' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::camera_model_d3,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->perspective_of_volume, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to camera_model_d3 to be a `view_volume`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<camera_model_d3_multi_clipping>(const DB& db, const LIST& params, camera_model_d3_multi_clipping* in)
{
	size_t base = GenericFill(db,params,static_cast<camera_model_d3*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to camera_model_d3_multi_clipping"); }    do { // convert the 'shape_clipping' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->shape_clipping, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to camera_model_d3_multi_clipping to be a `SET [1:?] OF camera_model_d3_multi_clipping_interection_select`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<camera_model_d3_multi_clipping_intersection>(const DB& db, const LIST& params, camera_model_d3_multi_clipping_intersection* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to camera_model_d3_multi_clipping_intersection"); }    do { // convert the 'shape_clipping' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->shape_clipping, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to camera_model_d3_multi_clipping_intersection to be a `SET [2:?] OF camera_model_d3_multi_clipping_interection_select`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<camera_model_d3_multi_clipping_union>(const DB& db, const LIST& params, camera_model_d3_multi_clipping_union* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to camera_model_d3_multi_clipping_union"); }    do { // convert the 'shape_clipping' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->shape_clipping, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to camera_model_d3_multi_clipping_union to be a `SET [2:?] OF camera_model_d3_multi_clipping_union_select`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<camera_model_d3_with_hlhsr>(const DB& db, const LIST& params, camera_model_d3_with_hlhsr* in)
{
	size_t base = GenericFill(db,params,static_cast<camera_model_d3*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to camera_model_d3_with_hlhsr"); }    do { // convert the 'hidden_line_surface_removal' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->hidden_line_surface_removal, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to camera_model_d3_with_hlhsr to be a `BOOLEAN`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<camera_model_with_light_sources>(const DB& db, const LIST& params, camera_model_with_light_sources* in)
{
	size_t base = GenericFill(db,params,static_cast<camera_model_d3*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to camera_model_with_light_sources"); }    do { // convert the 'sources' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->sources, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to camera_model_with_light_sources to be a `SET [1:?] OF light_source`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<representation_map>(const DB& db, const LIST& params, representation_map* in)
{
	size_t base = 0;
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to representation_map"); }    do { // convert the 'mapping_origin' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::representation_map,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->mapping_origin, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to representation_map to be a `representation_item`")); }
    } while(0);
    do { // convert the 'mapped_representation' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::representation_map,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->mapped_representation, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to representation_map to be a `representation`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<camera_usage>(const DB& db, const LIST& params, camera_usage* in)
{
	size_t base = GenericFill(db,params,static_cast<representation_map*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to camera_usage"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<capacitance_measure_with_unit>(const DB& db, const LIST& params, capacitance_measure_with_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<measure_with_unit*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to capacitance_measure_with_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<capacitance_unit>(const DB& db, const LIST& params, capacitance_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<derived_unit*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to capacitance_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<point>(const DB& db, const LIST& params, point* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_representation_item*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to point"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<cartesian_point>(const DB& db, const LIST& params, cartesian_point* in)
{
	size_t base = GenericFill(db,params,static_cast<point*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to cartesian_point"); }    do { // convert the 'coordinates' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->coordinates, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to cartesian_point to be a `LIST [1:3] OF length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<cartesian_transformation_operator>(const DB& db, const LIST& params, cartesian_transformation_operator* in)
{
	size_t base = 0;
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to cartesian_transformation_operator"); }    do { // convert the 'axis1' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::cartesian_transformation_operator,4>::aux_is_derived[0]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->axis1, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to cartesian_transformation_operator to be a `direction`")); }
    } while(0);
    do { // convert the 'axis2' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::cartesian_transformation_operator,4>::aux_is_derived[1]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->axis2, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to cartesian_transformation_operator to be a `direction`")); }
    } while(0);
    do { // convert the 'local_origin' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::cartesian_transformation_operator,4>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->local_origin, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to cartesian_transformation_operator to be a `cartesian_point`")); }
    } while(0);
    do { // convert the 'scale' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::cartesian_transformation_operator,4>::aux_is_derived[3]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->scale, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to cartesian_transformation_operator to be a `REAL`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<cartesian_transformation_operator_2d>(const DB& db, const LIST& params, cartesian_transformation_operator_2d* in)
{
	size_t base = GenericFill(db,params,static_cast<cartesian_transformation_operator*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to cartesian_transformation_operator_2d"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<cartesian_transformation_operator_3d>(const DB& db, const LIST& params, cartesian_transformation_operator_3d* in)
{
	size_t base = GenericFill(db,params,static_cast<cartesian_transformation_operator*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to cartesian_transformation_operator_3d"); }    do { // convert the 'axis3' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->axis3, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to cartesian_transformation_operator_3d to be a `direction`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<cc_design_approval>(const DB& db, const LIST& params, cc_design_approval* in)
{
	size_t base = GenericFill(db,params,static_cast<approval_assignment*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to cc_design_approval"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to cc_design_approval to be a `SET [1:?] OF approved_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<cc_design_certification>(const DB& db, const LIST& params, cc_design_certification* in)
{
	size_t base = GenericFill(db,params,static_cast<certification_assignment*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to cc_design_certification"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to cc_design_certification to be a `SET [1:?] OF certified_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<cc_design_contract>(const DB& db, const LIST& params, cc_design_contract* in)
{
	size_t base = GenericFill(db,params,static_cast<contract_assignment*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to cc_design_contract"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to cc_design_contract to be a `SET [1:?] OF contracted_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<cc_design_date_and_time_assignment>(const DB& db, const LIST& params, cc_design_date_and_time_assignment* in)
{
	size_t base = GenericFill(db,params,static_cast<date_and_time_assignment*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to cc_design_date_and_time_assignment"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to cc_design_date_and_time_assignment to be a `SET [1:?] OF date_time_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<cc_design_person_and_organization_assignment>(const DB& db, const LIST& params, cc_design_person_and_organization_assignment* in)
{
	size_t base = GenericFill(db,params,static_cast<person_and_organization_assignment*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to cc_design_person_and_organization_assignment"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to cc_design_person_and_organization_assignment to be a `SET [1:?] OF cc_person_organization_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<cc_design_security_classification>(const DB& db, const LIST& params, cc_design_security_classification* in)
{
	size_t base = GenericFill(db,params,static_cast<security_classification_assignment*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to cc_design_security_classification"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to cc_design_security_classification to be a `SET [1:?] OF cc_classified_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<cc_design_specification_reference>(const DB& db, const LIST& params, cc_design_specification_reference* in)
{
	size_t base = GenericFill(db,params,static_cast<document_reference*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to cc_design_specification_reference"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to cc_design_specification_reference to be a `SET [1:?] OF cc_specified_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<celsius_temperature_measure_with_unit>(const DB& db, const LIST& params, celsius_temperature_measure_with_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<measure_with_unit*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to celsius_temperature_measure_with_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<centre_of_symmetry>(const DB& db, const LIST& params, centre_of_symmetry* in)
{
	size_t base = GenericFill(db,params,static_cast<derived_shape_aspect*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to centre_of_symmetry"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<change>(const DB& db, const LIST& params, change* in)
{
	size_t base = GenericFill(db,params,static_cast<action_assignment*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to change"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to change to be a `SET [1:?] OF work_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<change_request>(const DB& db, const LIST& params, change_request* in)
{
	size_t base = GenericFill(db,params,static_cast<action_request_assignment*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to change_request"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to change_request to be a `SET [1:?] OF change_request_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<character_glyph_style_outline>(const DB& db, const LIST& params, character_glyph_style_outline* in)
{
	size_t base = GenericFill(db,params,static_cast<founded_item*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to character_glyph_style_outline"); }    do { // convert the 'outline_style' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->outline_style, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to character_glyph_style_outline to be a `curve_style`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<character_glyph_style_stroke>(const DB& db, const LIST& params, character_glyph_style_stroke* in)
{
	size_t base = GenericFill(db,params,static_cast<founded_item*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to character_glyph_style_stroke"); }    do { // convert the 'stroke_style' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->stroke_style, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to character_glyph_style_stroke to be a `curve_style`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<symbol_representation>(const DB& db, const LIST& params, symbol_representation* in)
{
	size_t base = GenericFill(db,params,static_cast<representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to symbol_representation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<generic_character_glyph_symbol>(const DB& db, const LIST& params, generic_character_glyph_symbol* in)
{
	size_t base = GenericFill(db,params,static_cast<symbol_representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to generic_character_glyph_symbol"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<character_glyph_symbol>(const DB& db, const LIST& params, character_glyph_symbol* in)
{
	size_t base = GenericFill(db,params,static_cast<generic_character_glyph_symbol*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to character_glyph_symbol"); }    do { // convert the 'character_box' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::character_glyph_symbol,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->character_box, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to character_glyph_symbol to be a `planar_extent`")); }
    } while(0);
    do { // convert the 'baseline_ratio' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::character_glyph_symbol,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->baseline_ratio, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to character_glyph_symbol to be a `ratio_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<character_glyph_symbol_outline>(const DB& db, const LIST& params, character_glyph_symbol_outline* in)
{
	size_t base = GenericFill(db,params,static_cast<character_glyph_symbol*>(in));
	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to character_glyph_symbol_outline"); }    do { // convert the 'outlines' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->outlines, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to character_glyph_symbol_outline to be a `SET [1:?] OF annotation_fill_area`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<character_glyph_symbol_stroke>(const DB& db, const LIST& params, character_glyph_symbol_stroke* in)
{
	size_t base = GenericFill(db,params,static_cast<character_glyph_symbol*>(in));
	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to character_glyph_symbol_stroke"); }    do { // convert the 'strokes' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->strokes, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to character_glyph_symbol_stroke to be a `SET [1:?] OF curve`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<general_property>(const DB& db, const LIST& params, general_property* in)
{
	size_t base = 0;
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to general_property"); }    do { // convert the 'id' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::general_property,3>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->id, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to general_property to be a `identifier`")); }
    } while(0);
    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::general_property,3>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to general_property to be a `label`")); }
    } while(0);
    do { // convert the 'description' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::general_property,3>::aux_is_derived[2]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->description, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to general_property to be a `text`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<characteristic_data_column_header>(const DB& db, const LIST& params, characteristic_data_column_header* in)
{
	size_t base = GenericFill(db,params,static_cast<general_property*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to characteristic_data_column_header"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<general_property_relationship>(const DB& db, const LIST& params, general_property_relationship* in)
{
	size_t base = 0;
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to general_property_relationship"); }    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::general_property_relationship,4>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to general_property_relationship to be a `label`")); }
    } while(0);
    do { // convert the 'description' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::general_property_relationship,4>::aux_is_derived[1]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->description, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to general_property_relationship to be a `text`")); }
    } while(0);
    do { // convert the 'relating_property' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::general_property_relationship,4>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->relating_property, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to general_property_relationship to be a `general_property`")); }
    } while(0);
    do { // convert the 'related_property' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::general_property_relationship,4>::aux_is_derived[3]=true; break; }
        try { GenericConvert( in->related_property, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to general_property_relationship to be a `general_property`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<characteristic_data_column_header_link>(const DB& db, const LIST& params, characteristic_data_column_header_link* in)
{
	size_t base = GenericFill(db,params,static_cast<general_property_relationship*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to characteristic_data_column_header_link"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<characteristic_data_table_header>(const DB& db, const LIST& params, characteristic_data_table_header* in)
{
	size_t base = GenericFill(db,params,static_cast<general_property*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to characteristic_data_table_header"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<characteristic_data_table_header_decomposition>(const DB& db, const LIST& params, characteristic_data_table_header_decomposition* in)
{
	size_t base = GenericFill(db,params,static_cast<general_property_relationship*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to characteristic_data_table_header_decomposition"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<group>(const DB& db, const LIST& params, group* in)
{
	size_t base = 0;
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to group"); }    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::group,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to group to be a `label`")); }
    } while(0);
    do { // convert the 'description' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::group,2>::aux_is_derived[1]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->description, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to group to be a `text`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<characteristic_type>(const DB& db, const LIST& params, characteristic_type* in)
{
	size_t base = GenericFill(db,params,static_cast<group*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to characteristic_type"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<characterized_class>(const DB& db, const LIST& params, characterized_class* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<characterized_object>(const DB& db, const LIST& params, characterized_object* in)
{
	size_t base = 0;
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to characterized_object"); }    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::characterized_object,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to characterized_object to be a `label`")); }
    } while(0);
    do { // convert the 'description' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::characterized_object,2>::aux_is_derived[1]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->description, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to characterized_object to be a `text`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<conic>(const DB& db, const LIST& params, conic* in)
{
	size_t base = GenericFill(db,params,static_cast<curve*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to conic"); }    do { // convert the 'position' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::conic,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->position, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to conic to be a `axis2_placement`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<circle>(const DB& db, const LIST& params, circle* in)
{
	size_t base = GenericFill(db,params,static_cast<conic*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to circle"); }    do { // convert the 'radius' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->radius, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to circle to be a `positive_length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<circular_runout_tolerance>(const DB& db, const LIST& params, circular_runout_tolerance* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_tolerance_with_datum_reference*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to circular_runout_tolerance"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<class_by_extension>(const DB& db, const LIST& params, class_by_extension* in)
{
	size_t base = GenericFill(db,params,static_cast<class_t*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to class_by_extension"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<class_by_intension>(const DB& db, const LIST& params, class_by_intension* in)
{
	size_t base = GenericFill(db,params,static_cast<class_t*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to class_by_intension"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<class_system>(const DB& db, const LIST& params, class_system* in)
{
	size_t base = GenericFill(db,params,static_cast<group*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to class_system"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<effectivity_context_assignment>(const DB& db, const LIST& params, effectivity_context_assignment* in)
{
	size_t base = 0;
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to effectivity_context_assignment"); }    do { // convert the 'assigned_effectivity_assignment' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::effectivity_context_assignment,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->assigned_effectivity_assignment, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to effectivity_context_assignment to be a `effectivity_assignment`")); }
    } while(0);
    do { // convert the 'role' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::effectivity_context_assignment,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->role, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to effectivity_context_assignment to be a `effectivity_context_role`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<class_usage_effectivity_context_assignment>(const DB& db, const LIST& params, class_usage_effectivity_context_assignment* in)
{
	size_t base = GenericFill(db,params,static_cast<effectivity_context_assignment*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to class_usage_effectivity_context_assignment"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to class_usage_effectivity_context_assignment to be a `SET [1:?] OF class_usage_effectivity_context_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<topological_representation_item>(const DB& db, const LIST& params, topological_representation_item* in)
{
	size_t base = GenericFill(db,params,static_cast<representation_item*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to topological_representation_item"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<connected_face_set>(const DB& db, const LIST& params, connected_face_set* in)
{
	size_t base = GenericFill(db,params,static_cast<topological_representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to connected_face_set"); }    do { // convert the 'cfs_faces' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::connected_face_set,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->cfs_faces, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to connected_face_set to be a `SET [1:?] OF face`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<closed_shell>(const DB& db, const LIST& params, closed_shell* in)
{
	size_t base = GenericFill(db,params,static_cast<connected_face_set*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to closed_shell"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<coaxiality_tolerance>(const DB& db, const LIST& params, coaxiality_tolerance* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_tolerance_with_datum_reference*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to coaxiality_tolerance"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<colour_specification>(const DB& db, const LIST& params, colour_specification* in)
{
	size_t base = GenericFill(db,params,static_cast<colour*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to colour_specification"); }    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::colour_specification,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to colour_specification to be a `label`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<colour_rgb>(const DB& db, const LIST& params, colour_rgb* in)
{
	size_t base = GenericFill(db,params,static_cast<colour_specification*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to colour_rgb"); }    do { // convert the 'red' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->red, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to colour_rgb to be a `REAL`")); }
    } while(0);
    do { // convert the 'green' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->green, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to colour_rgb to be a `REAL`")); }
    } while(0);
    do { // convert the 'blue' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->blue, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to colour_rgb to be a `REAL`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<common_datum>(const DB& db, const LIST& params, common_datum* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<comparison_expression>(const DB& db, const LIST& params, comparison_expression* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<complex_clause>(const DB& db, const LIST& params, complex_clause* in)
{
	size_t base = GenericFill(db,params,static_cast<compound_representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to complex_clause"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<complex_conjunctive_clause>(const DB& db, const LIST& params, complex_conjunctive_clause* in)
{
	size_t base = GenericFill(db,params,static_cast<complex_clause*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to complex_conjunctive_clause"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<complex_disjunctive_clause>(const DB& db, const LIST& params, complex_disjunctive_clause* in)
{
	size_t base = GenericFill(db,params,static_cast<complex_clause*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to complex_disjunctive_clause"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<modified_solid>(const DB& db, const LIST& params, modified_solid* in)
{
	size_t base = GenericFill(db,params,static_cast<solid_model*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to modified_solid"); }    do { // convert the 'rationale' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::modified_solid,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->rationale, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to modified_solid to be a `text`")); }
    } while(0);
    do { // convert the 'base_solid' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::modified_solid,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->base_solid, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to modified_solid to be a `base_solid_select`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<shelled_solid>(const DB& db, const LIST& params, shelled_solid* in)
{
	size_t base = GenericFill(db,params,static_cast<modified_solid*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to shelled_solid"); }    do { // convert the 'deleted_face_set' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::shelled_solid,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->deleted_face_set, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to shelled_solid to be a `SET [1:?] OF face_surface`")); }
    } while(0);
    do { // convert the 'thickness' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::shelled_solid,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->thickness, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to shelled_solid to be a `length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<complex_shelled_solid>(const DB& db, const LIST& params, complex_shelled_solid* in)
{
	size_t base = GenericFill(db,params,static_cast<shelled_solid*>(in));
	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to complex_shelled_solid"); }    do { // convert the 'thickness_list' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->thickness_list, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to complex_shelled_solid to be a `LIST [1:?] OF length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<composite_assembly_definition>(const DB& db, const LIST& params, composite_assembly_definition* in)
{
	size_t base = GenericFill(db,params,static_cast<product_definition*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to composite_assembly_definition"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<composite_assembly_sequence_definition>(const DB& db, const LIST& params, composite_assembly_sequence_definition* in)
{
	size_t base = GenericFill(db,params,static_cast<product_definition*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to composite_assembly_sequence_definition"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<laminate_table>(const DB& db, const LIST& params, laminate_table* in)
{
	size_t base = GenericFill(db,params,static_cast<product_definition*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to laminate_table"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<part_laminate_table>(const DB& db, const LIST& params, part_laminate_table* in)
{
	size_t base = GenericFill(db,params,static_cast<laminate_table*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to part_laminate_table"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<composite_assembly_table>(const DB& db, const LIST& params, composite_assembly_table* in)
{
	size_t base = GenericFill(db,params,static_cast<part_laminate_table*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to composite_assembly_table"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<composite_curve_segment>(const DB& db, const LIST& params, composite_curve_segment* in)
{
	size_t base = GenericFill(db,params,static_cast<founded_item*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to composite_curve_segment"); }    do { // convert the 'transition' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::composite_curve_segment,3>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->transition, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to composite_curve_segment to be a `transition_code`")); }
    } while(0);
    do { // convert the 'same_sense' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::composite_curve_segment,3>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->same_sense, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to composite_curve_segment to be a `BOOLEAN`")); }
    } while(0);
    do { // convert the 'parent_curve' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::composite_curve_segment,3>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->parent_curve, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to composite_curve_segment to be a `curve`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<material_designation>(const DB& db, const LIST& params, material_designation* in)
{
	size_t base = 0;
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to material_designation"); }    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::material_designation,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to material_designation to be a `label`")); }
    } while(0);
    do { // convert the 'definitions' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::material_designation,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->definitions, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to material_designation to be a `SET [1:?] OF characterized_definition`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<composite_material_designation>(const DB& db, const LIST& params, composite_material_designation* in)
{
	size_t base = GenericFill(db,params,static_cast<material_designation*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to composite_material_designation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<composite_shape_aspect>(const DB& db, const LIST& params, composite_shape_aspect* in)
{
	size_t base = GenericFill(db,params,static_cast<shape_aspect*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to composite_shape_aspect"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<composite_sheet_representation>(const DB& db, const LIST& params, composite_sheet_representation* in)
{
	size_t base = GenericFill(db,params,static_cast<shape_representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to composite_sheet_representation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<composite_text>(const DB& db, const LIST& params, composite_text* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to composite_text"); }    do { // convert the 'collected_text' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::composite_text,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->collected_text, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to composite_text to be a `SET [2:?] OF text_or_character`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<composite_text_with_associated_curves>(const DB& db, const LIST& params, composite_text_with_associated_curves* in)
{
	size_t base = GenericFill(db,params,static_cast<composite_text*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to composite_text_with_associated_curves"); }    do { // convert the 'associated_curves' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->associated_curves, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to composite_text_with_associated_curves to be a `SET [1:?] OF curve`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<composite_text_with_blanking_box>(const DB& db, const LIST& params, composite_text_with_blanking_box* in)
{
	size_t base = GenericFill(db,params,static_cast<composite_text*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to composite_text_with_blanking_box"); }    do { // convert the 'blanking' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->blanking, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to composite_text_with_blanking_box to be a `planar_box`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<composite_text_with_delineation>(const DB& db, const LIST& params, composite_text_with_delineation* in)
{
	size_t base = GenericFill(db,params,static_cast<composite_text*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to composite_text_with_delineation"); }    do { // convert the 'delineation' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->delineation, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to composite_text_with_delineation to be a `text_delineation`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<composite_text_with_extent>(const DB& db, const LIST& params, composite_text_with_extent* in)
{
	size_t base = GenericFill(db,params,static_cast<composite_text*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to composite_text_with_extent"); }    do { // convert the 'extent' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->extent, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to composite_text_with_extent to be a `planar_extent`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<compound_shape_representation>(const DB& db, const LIST& params, compound_shape_representation* in)
{
	size_t base = GenericFill(db,params,static_cast<shape_representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to compound_shape_representation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<concentricity_tolerance>(const DB& db, const LIST& params, concentricity_tolerance* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_tolerance_with_datum_reference*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to concentricity_tolerance"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<concept_feature_relationship>(const DB& db, const LIST& params, concept_feature_relationship* in)
{
	size_t base = 0;
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to concept_feature_relationship"); }    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::concept_feature_relationship,4>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to concept_feature_relationship to be a `label`")); }
    } while(0);
    do { // convert the 'description' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::concept_feature_relationship,4>::aux_is_derived[1]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->description, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to concept_feature_relationship to be a `text`")); }
    } while(0);
    do { // convert the 'relating_product_concept_feature' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::concept_feature_relationship,4>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->relating_product_concept_feature, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to concept_feature_relationship to be a `product_concept_feature`")); }
    } while(0);
    do { // convert the 'related_product_concept_feature' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::concept_feature_relationship,4>::aux_is_derived[3]=true; break; }
        try { GenericConvert( in->related_product_concept_feature, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to concept_feature_relationship to be a `product_concept_feature`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<concept_feature_relationship_with_condition>(const DB& db, const LIST& params, concept_feature_relationship_with_condition* in)
{
	size_t base = GenericFill(db,params,static_cast<concept_feature_relationship*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to concept_feature_relationship_with_condition"); }    do { // convert the 'conditional_operator' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->conditional_operator, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to concept_feature_relationship_with_condition to be a `concept_feature_operator`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<product_concept_feature>(const DB& db, const LIST& params, product_concept_feature* in)
{
	size_t base = 0;
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to product_concept_feature"); }    do { // convert the 'id' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::product_concept_feature,3>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->id, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to product_concept_feature to be a `identifier`")); }
    } while(0);
    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::product_concept_feature,3>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to product_concept_feature to be a `label`")); }
    } while(0);
    do { // convert the 'description' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::product_concept_feature,3>::aux_is_derived[2]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->description, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to product_concept_feature to be a `text`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<conditional_concept_feature>(const DB& db, const LIST& params, conditional_concept_feature* in)
{
	size_t base = GenericFill(db,params,static_cast<product_concept_feature*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to conditional_concept_feature"); }    do { // convert the 'condition' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::conditional_concept_feature,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->condition, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to conditional_concept_feature to be a `concept_feature_relationship_with_condition`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<conductance_measure_with_unit>(const DB& db, const LIST& params, conductance_measure_with_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<measure_with_unit*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to conductance_measure_with_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<conductance_unit>(const DB& db, const LIST& params, conductance_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<derived_unit*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to conductance_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<configuration_item>(const DB& db, const LIST& params, configuration_item* in)
{
	size_t base = 0;
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to configuration_item"); }    do { // convert the 'id' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::configuration_item,5>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->id, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to configuration_item to be a `identifier`")); }
    } while(0);
    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::configuration_item,5>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to configuration_item to be a `label`")); }
    } while(0);
    do { // convert the 'description' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::configuration_item,5>::aux_is_derived[2]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->description, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to configuration_item to be a `text`")); }
    } while(0);
    do { // convert the 'item_concept' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::configuration_item,5>::aux_is_derived[3]=true; break; }
        try { GenericConvert( in->item_concept, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to configuration_item to be a `product_concept`")); }
    } while(0);
    do { // convert the 'purpose' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::configuration_item,5>::aux_is_derived[4]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->purpose, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to configuration_item to be a `label`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<configurable_item>(const DB& db, const LIST& params, configurable_item* in)
{
	size_t base = GenericFill(db,params,static_cast<configuration_item*>(in));
	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to configurable_item"); }    do { // convert the 'item_concept_feature' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->item_concept_feature, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to configurable_item to be a `SET [1:?] OF product_concept_feature_association`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<effectivity>(const DB& db, const LIST& params, effectivity* in)
{
	size_t base = 0;
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to effectivity"); }    do { // convert the 'id' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::effectivity,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->id, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to effectivity to be a `identifier`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<product_definition_effectivity>(const DB& db, const LIST& params, product_definition_effectivity* in)
{
	size_t base = GenericFill(db,params,static_cast<effectivity*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to product_definition_effectivity"); }    do { // convert the 'usage' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::product_definition_effectivity,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->usage, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to product_definition_effectivity to be a `product_definition_relationship`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<configuration_effectivity>(const DB& db, const LIST& params, configuration_effectivity* in)
{
	size_t base = GenericFill(db,params,static_cast<product_definition_effectivity*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to configuration_effectivity"); }    do { // convert the 'configuration' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->configuration, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to configuration_effectivity to be a `configuration_design`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<configuration_item_relationship>(const DB& db, const LIST& params, configuration_item_relationship* in)
{
	size_t base = 0;
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to configuration_item_relationship"); }    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::configuration_item_relationship,4>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to configuration_item_relationship to be a `label`")); }
    } while(0);
    do { // convert the 'description' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::configuration_item_relationship,4>::aux_is_derived[1]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->description, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to configuration_item_relationship to be a `text`")); }
    } while(0);
    do { // convert the 'relating_configuration_item' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::configuration_item_relationship,4>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->relating_configuration_item, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to configuration_item_relationship to be a `configuration_item`")); }
    } while(0);
    do { // convert the 'related_configuration_item' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::configuration_item_relationship,4>::aux_is_derived[3]=true; break; }
        try { GenericConvert( in->related_configuration_item, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to configuration_item_relationship to be a `configuration_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<configuration_item_hierarchical_relationship>(const DB& db, const LIST& params, configuration_item_hierarchical_relationship* in)
{
	size_t base = GenericFill(db,params,static_cast<configuration_item_relationship*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to configuration_item_hierarchical_relationship"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<configuration_item_revision_sequence>(const DB& db, const LIST& params, configuration_item_revision_sequence* in)
{
	size_t base = GenericFill(db,params,static_cast<configuration_item_relationship*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to configuration_item_revision_sequence"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<configured_effectivity_assignment>(const DB& db, const LIST& params, configured_effectivity_assignment* in)
{
	size_t base = GenericFill(db,params,static_cast<effectivity_assignment*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to configured_effectivity_assignment"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to configured_effectivity_assignment to be a `SET [1:?] OF configured_effectivity_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<configured_effectivity_context_assignment>(const DB& db, const LIST& params, configured_effectivity_context_assignment* in)
{
	size_t base = GenericFill(db,params,static_cast<effectivity_context_assignment*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to configured_effectivity_context_assignment"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to configured_effectivity_context_assignment to be a `SET [1:?] OF configured_effectivity_context_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<conical_stepped_hole_transition>(const DB& db, const LIST& params, conical_stepped_hole_transition* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_representation_item*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to conical_stepped_hole_transition"); }    do { // convert the 'transition_number' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->transition_number, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to conical_stepped_hole_transition to be a `positive_integer`")); }
    } while(0);
    do { // convert the 'cone_apex_angle' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->cone_apex_angle, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to conical_stepped_hole_transition to be a `plane_angle_measure`")); }
    } while(0);
    do { // convert the 'cone_base_radius' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->cone_base_radius, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to conical_stepped_hole_transition to be a `positive_length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<elementary_surface>(const DB& db, const LIST& params, elementary_surface* in)
{
	size_t base = GenericFill(db,params,static_cast<surface*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to elementary_surface"); }    do { // convert the 'position' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::elementary_surface,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->position, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to elementary_surface to be a `axis2_placement_3d`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<conical_surface>(const DB& db, const LIST& params, conical_surface* in)
{
	size_t base = GenericFill(db,params,static_cast<elementary_surface*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to conical_surface"); }    do { // convert the 'radius' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->radius, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to conical_surface to be a `length_measure`")); }
    } while(0);
    do { // convert the 'semi_angle' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->semi_angle, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to conical_surface to be a `plane_angle_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<connected_edge_set>(const DB& db, const LIST& params, connected_edge_set* in)
{
	size_t base = GenericFill(db,params,static_cast<topological_representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to connected_edge_set"); }    do { // convert the 'ces_edges' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->ces_edges, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to connected_edge_set to be a `SET [1:?] OF edge`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<connected_face_sub_set>(const DB& db, const LIST& params, connected_face_sub_set* in)
{
	size_t base = GenericFill(db,params,static_cast<connected_face_set*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to connected_face_sub_set"); }    do { // convert the 'parent_face_set' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->parent_face_set, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to connected_face_sub_set to be a `connected_face_set`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<constructive_geometry_representation>(const DB& db, const LIST& params, constructive_geometry_representation* in)
{
	size_t base = GenericFill(db,params,static_cast<representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to constructive_geometry_representation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<representation_relationship>(const DB& db, const LIST& params, representation_relationship* in)
{
	size_t base = 0;
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to representation_relationship"); }    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::representation_relationship,4>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to representation_relationship to be a `label`")); }
    } while(0);
    do { // convert the 'description' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::representation_relationship,4>::aux_is_derived[1]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->description, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to representation_relationship to be a `text`")); }
    } while(0);
    do { // convert the 'rep_1' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::representation_relationship,4>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->rep_1, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to representation_relationship to be a `representation`")); }
    } while(0);
    do { // convert the 'rep_2' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::representation_relationship,4>::aux_is_derived[3]=true; break; }
        try { GenericConvert( in->rep_2, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to representation_relationship to be a `representation`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<constructive_geometry_representation_relationship>(const DB& db, const LIST& params, constructive_geometry_representation_relationship* in)
{
	size_t base = GenericFill(db,params,static_cast<representation_relationship*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to constructive_geometry_representation_relationship"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<contact_ratio_representation>(const DB& db, const LIST& params, contact_ratio_representation* in)
{
	size_t base = GenericFill(db,params,static_cast<representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to contact_ratio_representation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<invisibility>(const DB& db, const LIST& params, invisibility* in)
{
	size_t base = 0;
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to invisibility"); }    do { // convert the 'invisible_items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::invisibility,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->invisible_items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to invisibility to be a `SET [1:?] OF invisible_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<context_dependent_invisibility>(const DB& db, const LIST& params, context_dependent_invisibility* in)
{
	size_t base = GenericFill(db,params,static_cast<invisibility*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to context_dependent_invisibility"); }    do { // convert the 'presentation_context' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->presentation_context, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to context_dependent_invisibility to be a `invisibility_context`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<over_riding_styled_item>(const DB& db, const LIST& params, over_riding_styled_item* in)
{
	size_t base = GenericFill(db,params,static_cast<styled_item*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to over_riding_styled_item"); }    do { // convert the 'over_ridden_style' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::over_riding_styled_item,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->over_ridden_style, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to over_riding_styled_item to be a `styled_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<context_dependent_over_riding_styled_item>(const DB& db, const LIST& params, context_dependent_over_riding_styled_item* in)
{
	size_t base = GenericFill(db,params,static_cast<over_riding_styled_item*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to context_dependent_over_riding_styled_item"); }    do { // convert the 'style_context' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::context_dependent_over_riding_styled_item,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->style_context, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to context_dependent_over_riding_styled_item to be a `LIST [1:?] OF style_context_select`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<context_dependent_unit>(const DB& db, const LIST& params, context_dependent_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<named_unit*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to context_dependent_unit"); }    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::context_dependent_unit,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to context_dependent_unit to be a `label`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<conversion_based_unit>(const DB& db, const LIST& params, conversion_based_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<named_unit*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to conversion_based_unit"); }    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to conversion_based_unit to be a `label`")); }
    } while(0);
    do { // convert the 'conversion_factor' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->conversion_factor, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to conversion_based_unit to be a `measure_with_unit`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<csg_shape_representation>(const DB& db, const LIST& params, csg_shape_representation* in)
{
	size_t base = GenericFill(db,params,static_cast<shape_representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to csg_shape_representation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<csg_solid>(const DB& db, const LIST& params, csg_solid* in)
{
	size_t base = GenericFill(db,params,static_cast<solid_model*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to csg_solid"); }    do { // convert the 'tree_root_expression' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->tree_root_expression, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to csg_solid to be a `csg_select`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<currency>(const DB& db, const LIST& params, currency* in)
{
	size_t base = GenericFill(db,params,static_cast<context_dependent_unit*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to currency"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<currency_measure_with_unit>(const DB& db, const LIST& params, currency_measure_with_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<measure_with_unit*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to currency_measure_with_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<curve_bounded_surface>(const DB& db, const LIST& params, curve_bounded_surface* in)
{
	size_t base = GenericFill(db,params,static_cast<bounded_surface*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to curve_bounded_surface"); }    do { // convert the 'basis_surface' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->basis_surface, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to curve_bounded_surface to be a `surface`")); }
    } while(0);
    do { // convert the 'boundaries' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->boundaries, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to curve_bounded_surface to be a `SET [1:?] OF boundary_curve`")); }
    } while(0);
    do { // convert the 'implicit_outer' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->implicit_outer, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to curve_bounded_surface to be a `BOOLEAN`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<curve_dimension>(const DB& db, const LIST& params, curve_dimension* in)
{
	size_t base = GenericFill(db,params,static_cast<dimension_curve_directed_callout*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to curve_dimension"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<curve_replica>(const DB& db, const LIST& params, curve_replica* in)
{
	size_t base = GenericFill(db,params,static_cast<curve*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to curve_replica"); }    do { // convert the 'parent_curve' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->parent_curve, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to curve_replica to be a `curve`")); }
    } while(0);
    do { // convert the 'transformation' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->transformation, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to curve_replica to be a `cartesian_transformation_operator`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<curve_style>(const DB& db, const LIST& params, curve_style* in)
{
	size_t base = GenericFill(db,params,static_cast<founded_item*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to curve_style"); }    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to curve_style to be a `label`")); }
    } while(0);
    do { // convert the 'curve_font' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->curve_font, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to curve_style to be a `curve_font_or_scaled_curve_font_select`")); }
    } while(0);
    do { // convert the 'curve_width' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->curve_width, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to curve_style to be a `size_select`")); }
    } while(0);
    do { // convert the 'curve_colour' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->curve_colour, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to curve_style to be a `colour`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<curve_style_font>(const DB& db, const LIST& params, curve_style_font* in)
{
	size_t base = GenericFill(db,params,static_cast<founded_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to curve_style_font"); }    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to curve_style_font to be a `label`")); }
    } while(0);
    do { // convert the 'pattern_list' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->pattern_list, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to curve_style_font to be a `LIST [1:?] OF curve_style_font_pattern`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<curve_style_font_and_scaling>(const DB& db, const LIST& params, curve_style_font_and_scaling* in)
{
	size_t base = GenericFill(db,params,static_cast<founded_item*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to curve_style_font_and_scaling"); }    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to curve_style_font_and_scaling to be a `label`")); }
    } while(0);
    do { // convert the 'curve_font' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->curve_font, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to curve_style_font_and_scaling to be a `curve_style_font_select`")); }
    } while(0);
    do { // convert the 'curve_font_scaling' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->curve_font_scaling, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to curve_style_font_and_scaling to be a `REAL`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<curve_style_font_pattern>(const DB& db, const LIST& params, curve_style_font_pattern* in)
{
	size_t base = GenericFill(db,params,static_cast<founded_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to curve_style_font_pattern"); }    do { // convert the 'visible_segment_length' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->visible_segment_length, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to curve_style_font_pattern to be a `positive_length_measure`")); }
    } while(0);
    do { // convert the 'invisible_segment_length' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->invisible_segment_length, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to curve_style_font_pattern to be a `positive_length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<curve_swept_solid_shape_representation>(const DB& db, const LIST& params, curve_swept_solid_shape_representation* in)
{
	size_t base = GenericFill(db,params,static_cast<shape_representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to curve_swept_solid_shape_representation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<cylindrical_surface>(const DB& db, const LIST& params, cylindrical_surface* in)
{
	size_t base = GenericFill(db,params,static_cast<elementary_surface*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to cylindrical_surface"); }    do { // convert the 'radius' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->radius, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to cylindrical_surface to be a `positive_length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<cylindricity_tolerance>(const DB& db, const LIST& params, cylindricity_tolerance* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_tolerance*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to cylindricity_tolerance"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<date_representation_item>(const DB& db, const LIST& params, date_representation_item* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<date_time_representation_item>(const DB& db, const LIST& params, date_time_representation_item* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<dated_effectivity>(const DB& db, const LIST& params, dated_effectivity* in)
{
	size_t base = GenericFill(db,params,static_cast<effectivity*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to dated_effectivity"); }    do { // convert the 'effectivity_end_date' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->effectivity_end_date, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to dated_effectivity to be a `date_time_or_event_occurrence`")); }
    } while(0);
    do { // convert the 'effectivity_start_date' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->effectivity_start_date, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to dated_effectivity to be a `date_time_or_event_occurrence`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<datum>(const DB& db, const LIST& params, datum* in)
{
	size_t base = GenericFill(db,params,static_cast<shape_aspect*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to datum"); }    do { // convert the 'identification' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->identification, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to datum to be a `identifier`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<datum_feature>(const DB& db, const LIST& params, datum_feature* in)
{
	size_t base = GenericFill(db,params,static_cast<shape_aspect*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to datum_feature"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<datum_feature_callout>(const DB& db, const LIST& params, datum_feature_callout* in)
{
	size_t base = GenericFill(db,params,static_cast<draughting_callout*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to datum_feature_callout"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<datum_reference>(const DB& db, const LIST& params, datum_reference* in)
{
	size_t base = 0;
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to datum_reference"); }    do { // convert the 'precedence' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::datum_reference,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->precedence, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to datum_reference to be a `INTEGER`")); }
    } while(0);
    do { // convert the 'referenced_datum' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::datum_reference,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->referenced_datum, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to datum_reference to be a `datum`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<datum_target>(const DB& db, const LIST& params, datum_target* in)
{
	size_t base = GenericFill(db,params,static_cast<shape_aspect*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to datum_target"); }    do { // convert the 'target_id' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::datum_target,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->target_id, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to datum_target to be a `identifier`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<datum_target_callout>(const DB& db, const LIST& params, datum_target_callout* in)
{
	size_t base = GenericFill(db,params,static_cast<draughting_callout*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to datum_target_callout"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<default_tolerance_table>(const DB& db, const LIST& params, default_tolerance_table* in)
{
	size_t base = GenericFill(db,params,static_cast<representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to default_tolerance_table"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<default_tolerance_table_cell>(const DB& db, const LIST& params, default_tolerance_table_cell* in)
{
	size_t base = GenericFill(db,params,static_cast<compound_representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to default_tolerance_table_cell"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<defined_symbol>(const DB& db, const LIST& params, defined_symbol* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_representation_item*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to defined_symbol"); }    do { // convert the 'definition' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->definition, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to defined_symbol to be a `defined_symbol_select`")); }
    } while(0);
    do { // convert the 'target' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->target, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to defined_symbol to be a `symbol_target`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<definitional_representation>(const DB& db, const LIST& params, definitional_representation* in)
{
	size_t base = GenericFill(db,params,static_cast<representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to definitional_representation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<definitional_representation_relationship>(const DB& db, const LIST& params, definitional_representation_relationship* in)
{
	size_t base = GenericFill(db,params,static_cast<representation_relationship*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to definitional_representation_relationship"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<definitional_representation_relationship_with_same_context>(const DB& db, const LIST& params, definitional_representation_relationship_with_same_context* in)
{
	size_t base = GenericFill(db,params,static_cast<definitional_representation_relationship*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to definitional_representation_relationship_with_same_context"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<degenerate_pcurve>(const DB& db, const LIST& params, degenerate_pcurve* in)
{
	size_t base = GenericFill(db,params,static_cast<point*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to degenerate_pcurve"); }    do { // convert the 'basis_surface' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::degenerate_pcurve,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->basis_surface, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to degenerate_pcurve to be a `surface`")); }
    } while(0);
    do { // convert the 'reference_to_curve' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::degenerate_pcurve,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->reference_to_curve, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to degenerate_pcurve to be a `definitional_representation`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<toroidal_surface>(const DB& db, const LIST& params, toroidal_surface* in)
{
	size_t base = GenericFill(db,params,static_cast<elementary_surface*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to toroidal_surface"); }    do { // convert the 'major_radius' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::toroidal_surface,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->major_radius, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to toroidal_surface to be a `positive_length_measure`")); }
    } while(0);
    do { // convert the 'minor_radius' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::toroidal_surface,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->minor_radius, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to toroidal_surface to be a `positive_length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<degenerate_toroidal_surface>(const DB& db, const LIST& params, degenerate_toroidal_surface* in)
{
	size_t base = GenericFill(db,params,static_cast<toroidal_surface*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to degenerate_toroidal_surface"); }    do { // convert the 'select_outer' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->select_outer, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to degenerate_toroidal_surface to be a `BOOLEAN`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<descriptive_representation_item>(const DB& db, const LIST& params, descriptive_representation_item* in)
{
	size_t base = GenericFill(db,params,static_cast<representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to descriptive_representation_item"); }    do { // convert the 'description' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::descriptive_representation_item,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->description, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to descriptive_representation_item to be a `text`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<product_definition_context>(const DB& db, const LIST& params, product_definition_context* in)
{
	size_t base = GenericFill(db,params,static_cast<application_context_element*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to product_definition_context"); }    do { // convert the 'life_cycle_stage' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::product_definition_context,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->life_cycle_stage, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to product_definition_context to be a `label`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<design_context>(const DB& db, const LIST& params, design_context* in)
{
	size_t base = GenericFill(db,params,static_cast<product_definition_context*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to design_context"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<design_make_from_relationship>(const DB& db, const LIST& params, design_make_from_relationship* in)
{
	size_t base = GenericFill(db,params,static_cast<product_definition_relationship*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to design_make_from_relationship"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<diameter_dimension>(const DB& db, const LIST& params, diameter_dimension* in)
{
	size_t base = GenericFill(db,params,static_cast<dimension_curve_directed_callout*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to diameter_dimension"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<ratio_measure_with_unit>(const DB& db, const LIST& params, ratio_measure_with_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<measure_with_unit*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to ratio_measure_with_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<dielectric_constant_measure_with_unit>(const DB& db, const LIST& params, dielectric_constant_measure_with_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<ratio_measure_with_unit*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to dielectric_constant_measure_with_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<dimension_callout>(const DB& db, const LIST& params, dimension_callout* in)
{
	size_t base = GenericFill(db,params,static_cast<draughting_callout*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to dimension_callout"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<draughting_callout_relationship>(const DB& db, const LIST& params, draughting_callout_relationship* in)
{
	size_t base = 0;
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to draughting_callout_relationship"); }    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::draughting_callout_relationship,4>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to draughting_callout_relationship to be a `label`")); }
    } while(0);
    do { // convert the 'description' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::draughting_callout_relationship,4>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->description, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to draughting_callout_relationship to be a `text`")); }
    } while(0);
    do { // convert the 'relating_draughting_callout' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::draughting_callout_relationship,4>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->relating_draughting_callout, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to draughting_callout_relationship to be a `draughting_callout`")); }
    } while(0);
    do { // convert the 'related_draughting_callout' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::draughting_callout_relationship,4>::aux_is_derived[3]=true; break; }
        try { GenericConvert( in->related_draughting_callout, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to draughting_callout_relationship to be a `draughting_callout`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<dimension_callout_component_relationship>(const DB& db, const LIST& params, dimension_callout_component_relationship* in)
{
	size_t base = GenericFill(db,params,static_cast<draughting_callout_relationship*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to dimension_callout_component_relationship"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<dimension_callout_relationship>(const DB& db, const LIST& params, dimension_callout_relationship* in)
{
	size_t base = GenericFill(db,params,static_cast<draughting_callout_relationship*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to dimension_callout_relationship"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<dimension_curve>(const DB& db, const LIST& params, dimension_curve* in)
{
	size_t base = GenericFill(db,params,static_cast<annotation_curve_occurrence*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to dimension_curve"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<terminator_symbol>(const DB& db, const LIST& params, terminator_symbol* in)
{
	size_t base = GenericFill(db,params,static_cast<annotation_symbol_occurrence*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to terminator_symbol"); }    do { // convert the 'annotated_curve' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::terminator_symbol,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->annotated_curve, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to terminator_symbol to be a `annotation_curve_occurrence`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<dimension_curve_terminator>(const DB& db, const LIST& params, dimension_curve_terminator* in)
{
	size_t base = GenericFill(db,params,static_cast<terminator_symbol*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to dimension_curve_terminator"); }    do { // convert the 'role' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->role, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to dimension_curve_terminator to be a `dimension_extent_usage`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<dimension_curve_terminator_to_projection_curve_associativity>(const DB& db, const LIST& params, dimension_curve_terminator_to_projection_curve_associativity* in)
{
	size_t base = GenericFill(db,params,static_cast<annotation_occurrence_associativity*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to dimension_curve_terminator_to_projection_curve_associativity"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<dimension_pair>(const DB& db, const LIST& params, dimension_pair* in)
{
	size_t base = GenericFill(db,params,static_cast<draughting_callout_relationship*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to dimension_pair"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<dimension_text_associativity>(const DB& db, const LIST& params, dimension_text_associativity* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<dimensional_location_with_path>(const DB& db, const LIST& params, dimensional_location_with_path* in)
{
	size_t base = GenericFill(db,params,static_cast<dimensional_location*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to dimensional_location_with_path"); }    do { // convert the 'path' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->path, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to dimensional_location_with_path to be a `shape_aspect`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<dimensional_size_with_path>(const DB& db, const LIST& params, dimensional_size_with_path* in)
{
	size_t base = GenericFill(db,params,static_cast<dimensional_size*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to dimensional_size_with_path"); }    do { // convert the 'path' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->path, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to dimensional_size_with_path to be a `shape_aspect`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<executed_action>(const DB& db, const LIST& params, executed_action* in)
{
	size_t base = GenericFill(db,params,static_cast<action*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to executed_action"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<directed_action>(const DB& db, const LIST& params, directed_action* in)
{
	size_t base = GenericFill(db,params,static_cast<executed_action*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to directed_action"); }    do { // convert the 'directive' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->directive, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to directed_action to be a `action_directive`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<directed_dimensional_location>(const DB& db, const LIST& params, directed_dimensional_location* in)
{
	size_t base = GenericFill(db,params,static_cast<dimensional_location*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to directed_dimensional_location"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<direction>(const DB& db, const LIST& params, direction* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to direction"); }    do { // convert the 'direction_ratios' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->direction_ratios, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to direction to be a `LIST [2:3] OF REAL`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<document_file>(const DB& db, const LIST& params, document_file* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<document_identifier>(const DB& db, const LIST& params, document_identifier* in)
{
	size_t base = GenericFill(db,params,static_cast<group*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to document_identifier"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<document_identifier_assignment>(const DB& db, const LIST& params, document_identifier_assignment* in)
{
	size_t base = GenericFill(db,params,static_cast<group_assignment*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to document_identifier_assignment"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to document_identifier_assignment to be a `SET [1:?] OF document_identifier_assigned_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<document_product_association>(const DB& db, const LIST& params, document_product_association* in)
{
	size_t base = 0;
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to document_product_association"); }    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::document_product_association,4>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to document_product_association to be a `label`")); }
    } while(0);
    do { // convert the 'description' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::document_product_association,4>::aux_is_derived[1]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->description, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to document_product_association to be a `text`")); }
    } while(0);
    do { // convert the 'relating_document' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::document_product_association,4>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->relating_document, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to document_product_association to be a `document`")); }
    } while(0);
    do { // convert the 'related_product' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::document_product_association,4>::aux_is_derived[3]=true; break; }
        try { GenericConvert( in->related_product, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to document_product_association to be a `product_or_formation_or_definition`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<document_product_equivalence>(const DB& db, const LIST& params, document_product_equivalence* in)
{
	size_t base = GenericFill(db,params,static_cast<document_product_association*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to document_product_equivalence"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<dose_equivalent_measure_with_unit>(const DB& db, const LIST& params, dose_equivalent_measure_with_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<measure_with_unit*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to dose_equivalent_measure_with_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<dose_equivalent_unit>(const DB& db, const LIST& params, dose_equivalent_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<derived_unit*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to dose_equivalent_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<double_offset_shelled_solid>(const DB& db, const LIST& params, double_offset_shelled_solid* in)
{
	size_t base = GenericFill(db,params,static_cast<shelled_solid*>(in));
	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to double_offset_shelled_solid"); }    do { // convert the 'thickness2' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->thickness2, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to double_offset_shelled_solid to be a `length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<item_defined_transformation>(const DB& db, const LIST& params, item_defined_transformation* in)
{
	size_t base = 0;
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to item_defined_transformation"); }    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::item_defined_transformation,4>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to item_defined_transformation to be a `label`")); }
    } while(0);
    do { // convert the 'description' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::item_defined_transformation,4>::aux_is_derived[1]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->description, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to item_defined_transformation to be a `text`")); }
    } while(0);
    do { // convert the 'transform_item_1' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::item_defined_transformation,4>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->transform_item_1, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to item_defined_transformation to be a `representation_item`")); }
    } while(0);
    do { // convert the 'transform_item_2' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::item_defined_transformation,4>::aux_is_derived[3]=true; break; }
        try { GenericConvert( in->transform_item_2, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to item_defined_transformation to be a `representation_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<transformation_with_derived_angle>(const DB& db, const LIST& params, transformation_with_derived_angle* in)
{
	size_t base = GenericFill(db,params,static_cast<item_defined_transformation*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to transformation_with_derived_angle"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<draped_defined_transformation>(const DB& db, const LIST& params, draped_defined_transformation* in)
{
	size_t base = GenericFill(db,params,static_cast<transformation_with_derived_angle*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to draped_defined_transformation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<draughting_annotation_occurrence>(const DB& db, const LIST& params, draughting_annotation_occurrence* in)
{
	size_t base = GenericFill(db,params,static_cast<annotation_occurrence*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to draughting_annotation_occurrence"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<draughting_elements>(const DB& db, const LIST& params, draughting_elements* in)
{
	size_t base = GenericFill(db,params,static_cast<draughting_callout*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to draughting_elements"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<draughting_model>(const DB& db, const LIST& params, draughting_model* in)
{
	size_t base = GenericFill(db,params,static_cast<representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to draughting_model"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<item_identified_representation_usage>(const DB& db, const LIST& params, item_identified_representation_usage* in)
{
	size_t base = 0;
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to item_identified_representation_usage"); }    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::item_identified_representation_usage,5>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to item_identified_representation_usage to be a `label`")); }
    } while(0);
    do { // convert the 'description' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::item_identified_representation_usage,5>::aux_is_derived[1]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->description, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to item_identified_representation_usage to be a `text`")); }
    } while(0);
    do { // convert the 'definition' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::item_identified_representation_usage,5>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->definition, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to item_identified_representation_usage to be a `represented_definition`")); }
    } while(0);
    do { // convert the 'used_representation' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::item_identified_representation_usage,5>::aux_is_derived[3]=true; break; }
        try { GenericConvert( in->used_representation, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to item_identified_representation_usage to be a `representation`")); }
    } while(0);
    do { // convert the 'identified_item' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::item_identified_representation_usage,5>::aux_is_derived[4]=true; break; }
        try { GenericConvert( in->identified_item, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to item_identified_representation_usage to be a `representation_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<draughting_model_item_association>(const DB& db, const LIST& params, draughting_model_item_association* in)
{
	size_t base = GenericFill(db,params,static_cast<item_identified_representation_usage*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to draughting_model_item_association"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<pre_defined_colour>(const DB& db, const LIST& params, pre_defined_colour* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<draughting_pre_defined_colour>(const DB& db, const LIST& params, draughting_pre_defined_colour* in)
{
	size_t base = GenericFill(db,params,static_cast<pre_defined_colour*>(in));
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<pre_defined_item>(const DB& db, const LIST& params, pre_defined_item* in)
{
	size_t base = 0;
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to pre_defined_item"); }    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::pre_defined_item,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to pre_defined_item to be a `label`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<pre_defined_curve_font>(const DB& db, const LIST& params, pre_defined_curve_font* in)
{
	size_t base = GenericFill(db,params,static_cast<pre_defined_item*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to pre_defined_curve_font"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<draughting_pre_defined_curve_font>(const DB& db, const LIST& params, draughting_pre_defined_curve_font* in)
{
	size_t base = GenericFill(db,params,static_cast<pre_defined_curve_font*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to draughting_pre_defined_curve_font"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<pre_defined_text_font>(const DB& db, const LIST& params, pre_defined_text_font* in)
{
	size_t base = GenericFill(db,params,static_cast<pre_defined_item*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to pre_defined_text_font"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<draughting_pre_defined_text_font>(const DB& db, const LIST& params, draughting_pre_defined_text_font* in)
{
	size_t base = GenericFill(db,params,static_cast<pre_defined_text_font*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to draughting_pre_defined_text_font"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<draughting_subfigure_representation>(const DB& db, const LIST& params, draughting_subfigure_representation* in)
{
	size_t base = GenericFill(db,params,static_cast<symbol_representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to draughting_subfigure_representation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<draughting_symbol_representation>(const DB& db, const LIST& params, draughting_symbol_representation* in)
{
	size_t base = GenericFill(db,params,static_cast<symbol_representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to draughting_symbol_representation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<text_literal>(const DB& db, const LIST& params, text_literal* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_representation_item*>(in));
	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to text_literal"); }    do { // convert the 'literal' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::text_literal,5>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->literal, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to text_literal to be a `presentable_text`")); }
    } while(0);
    do { // convert the 'placement' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::text_literal,5>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->placement, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to text_literal to be a `axis2_placement`")); }
    } while(0);
    do { // convert the 'alignment' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::text_literal,5>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->alignment, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to text_literal to be a `text_alignment`")); }
    } while(0);
    do { // convert the 'path' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::text_literal,5>::aux_is_derived[3]=true; break; }
        try { GenericConvert( in->path, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to text_literal to be a `text_path`")); }
    } while(0);
    do { // convert the 'font' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::text_literal,5>::aux_is_derived[4]=true; break; }
        try { GenericConvert( in->font, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to text_literal to be a `font_select`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<text_literal_with_delineation>(const DB& db, const LIST& params, text_literal_with_delineation* in)
{
	size_t base = GenericFill(db,params,static_cast<text_literal*>(in));
	if (params.GetSize() < 7) { throw STEP::TypeError("expected 7 arguments to text_literal_with_delineation"); }    do { // convert the 'delineation' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::text_literal_with_delineation,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->delineation, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to text_literal_with_delineation to be a `text_delineation`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<draughting_text_literal_with_delineation>(const DB& db, const LIST& params, draughting_text_literal_with_delineation* in)
{
	size_t base = GenericFill(db,params,static_cast<text_literal_with_delineation*>(in));
	if (params.GetSize() < 7) { throw STEP::TypeError("expected 7 arguments to draughting_text_literal_with_delineation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<presentation_set>(const DB& db, const LIST& params, presentation_set* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<drawing_revision>(const DB& db, const LIST& params, drawing_revision* in)
{
	size_t base = GenericFill(db,params,static_cast<presentation_set*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to drawing_revision"); }    do { // convert the 'revision_identifier' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->revision_identifier, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to drawing_revision to be a `identifier`")); }
    } while(0);
    do { // convert the 'drawing_identifier' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->drawing_identifier, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to drawing_revision to be a `drawing_definition`")); }
    } while(0);
    do { // convert the 'intended_scale' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->intended_scale, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to drawing_revision to be a `text`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<presentation_representation>(const DB& db, const LIST& params, presentation_representation* in)
{
	size_t base = GenericFill(db,params,static_cast<representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to presentation_representation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<presentation_area>(const DB& db, const LIST& params, presentation_area* in)
{
	size_t base = GenericFill(db,params,static_cast<presentation_representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to presentation_area"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<drawing_sheet_revision>(const DB& db, const LIST& params, drawing_sheet_revision* in)
{
	size_t base = GenericFill(db,params,static_cast<presentation_area*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to drawing_sheet_revision"); }    do { // convert the 'revision_identifier' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->revision_identifier, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to drawing_sheet_revision to be a `identifier`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<drawing_sheet_revision_sequence>(const DB& db, const LIST& params, drawing_sheet_revision_sequence* in)
{
	size_t base = GenericFill(db,params,static_cast<representation_relationship*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to drawing_sheet_revision_sequence"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<drawing_sheet_revision_usage>(const DB& db, const LIST& params, drawing_sheet_revision_usage* in)
{
	size_t base = GenericFill(db,params,static_cast<area_in_set*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to drawing_sheet_revision_usage"); }    do { // convert the 'sheet_number' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->sheet_number, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to drawing_sheet_revision_usage to be a `identifier`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<edge>(const DB& db, const LIST& params, edge* in)
{
	size_t base = GenericFill(db,params,static_cast<topological_representation_item*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to edge"); }    do { // convert the 'edge_start' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::edge,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->edge_start, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to edge to be a `vertex`")); }
    } while(0);
    do { // convert the 'edge_end' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::edge,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->edge_end, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to edge to be a `vertex`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<edge_based_wireframe_model>(const DB& db, const LIST& params, edge_based_wireframe_model* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to edge_based_wireframe_model"); }    do { // convert the 'ebwm_boundary' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->ebwm_boundary, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to edge_based_wireframe_model to be a `SET [1:?] OF connected_edge_set`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<edge_based_wireframe_shape_representation>(const DB& db, const LIST& params, edge_based_wireframe_shape_representation* in)
{
	size_t base = GenericFill(db,params,static_cast<shape_representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to edge_based_wireframe_shape_representation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<edge_blended_solid>(const DB& db, const LIST& params, edge_blended_solid* in)
{
	size_t base = GenericFill(db,params,static_cast<modified_solid*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to edge_blended_solid"); }    do { // convert the 'blended_edges' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::edge_blended_solid,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->blended_edges, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to edge_blended_solid to be a `LIST [1:?] OF edge_curve`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<edge_curve>(const DB& db, const LIST& params, edge_curve* in)
{
	size_t base = 0;
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to edge_curve"); }    do { // convert the 'edge_geometry' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->edge_geometry, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to edge_curve to be a `curve`")); }
    } while(0);
    do { // convert the 'same_sense' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->same_sense, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to edge_curve to be a `BOOLEAN`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<edge_loop>(const DB& db, const LIST& params, edge_loop* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<electric_charge_measure_with_unit>(const DB& db, const LIST& params, electric_charge_measure_with_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<measure_with_unit*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to electric_charge_measure_with_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<electric_charge_unit>(const DB& db, const LIST& params, electric_charge_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<derived_unit*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to electric_charge_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<electric_current_measure_with_unit>(const DB& db, const LIST& params, electric_current_measure_with_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<measure_with_unit*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to electric_current_measure_with_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<electric_current_unit>(const DB& db, const LIST& params, electric_current_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<named_unit*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to electric_current_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<electric_potential_measure_with_unit>(const DB& db, const LIST& params, electric_potential_measure_with_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<measure_with_unit*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to electric_potential_measure_with_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<electric_potential_unit>(const DB& db, const LIST& params, electric_potential_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<derived_unit*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to electric_potential_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<elementary_brep_shape_representation>(const DB& db, const LIST& params, elementary_brep_shape_representation* in)
{
	size_t base = GenericFill(db,params,static_cast<shape_representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to elementary_brep_shape_representation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<ellipse>(const DB& db, const LIST& params, ellipse* in)
{
	size_t base = GenericFill(db,params,static_cast<conic*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to ellipse"); }    do { // convert the 'semi_axis_1' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->semi_axis_1, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to ellipse to be a `positive_length_measure`")); }
    } while(0);
    do { // convert the 'semi_axis_2' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->semi_axis_2, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to ellipse to be a `positive_length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<energy_measure_with_unit>(const DB& db, const LIST& params, energy_measure_with_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<measure_with_unit*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to energy_measure_with_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<energy_unit>(const DB& db, const LIST& params, energy_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<derived_unit*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to energy_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<property_definition>(const DB& db, const LIST& params, property_definition* in)
{
	size_t base = 0;
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to property_definition"); }    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::property_definition,3>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to property_definition to be a `label`")); }
    } while(0);
    do { // convert the 'description' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::property_definition,3>::aux_is_derived[1]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->description, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to property_definition to be a `text`")); }
    } while(0);
    do { // convert the 'definition' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::property_definition,3>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->definition, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to property_definition to be a `characterized_definition`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<fact_type>(const DB& db, const LIST& params, fact_type* in)
{
	size_t base = GenericFill(db,params,static_cast<property_definition*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to fact_type"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<entity_assertion>(const DB& db, const LIST& params, entity_assertion* in)
{
	size_t base = GenericFill(db,params,static_cast<fact_type*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to entity_assertion"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<enum_reference_prefix>(const DB& db, const LIST& params, enum_reference_prefix* in)
{
	size_t base = GenericFill(db,params,static_cast<descriptive_representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to enum_reference_prefix"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<evaluated_characteristic>(const DB& db, const LIST& params, evaluated_characteristic* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<evaluated_degenerate_pcurve>(const DB& db, const LIST& params, evaluated_degenerate_pcurve* in)
{
	size_t base = GenericFill(db,params,static_cast<degenerate_pcurve*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to evaluated_degenerate_pcurve"); }    do { // convert the 'equivalent_point' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->equivalent_point, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to evaluated_degenerate_pcurve to be a `cartesian_point`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<evaluation_product_definition>(const DB& db, const LIST& params, evaluation_product_definition* in)
{
	size_t base = GenericFill(db,params,static_cast<product_definition*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to evaluation_product_definition"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<event_occurrence>(const DB& db, const LIST& params, event_occurrence* in)
{
	size_t base = 0;
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to event_occurrence"); }    do { // convert the 'id' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::event_occurrence,3>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->id, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to event_occurrence to be a `identifier`")); }
    } while(0);
    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::event_occurrence,3>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to event_occurrence to be a `label`")); }
    } while(0);
    do { // convert the 'description' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::event_occurrence,3>::aux_is_derived[2]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->description, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to event_occurrence to be a `text`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<product_concept_feature_category>(const DB& db, const LIST& params, product_concept_feature_category* in)
{
	size_t base = GenericFill(db,params,static_cast<group*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to product_concept_feature_category"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<exclusive_product_concept_feature_category>(const DB& db, const LIST& params, exclusive_product_concept_feature_category* in)
{
	size_t base = GenericFill(db,params,static_cast<product_concept_feature_category*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to exclusive_product_concept_feature_category"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<uncertainty_qualifier>(const DB& db, const LIST& params, uncertainty_qualifier* in)
{
	size_t base = 0;
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to uncertainty_qualifier"); }    do { // convert the 'measure_name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::uncertainty_qualifier,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->measure_name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to uncertainty_qualifier to be a `label`")); }
    } while(0);
    do { // convert the 'description' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::uncertainty_qualifier,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->description, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to uncertainty_qualifier to be a `text`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<standard_uncertainty>(const DB& db, const LIST& params, standard_uncertainty* in)
{
	size_t base = GenericFill(db,params,static_cast<uncertainty_qualifier*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to standard_uncertainty"); }    do { // convert the 'uncertainty_value' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::standard_uncertainty,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->uncertainty_value, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to standard_uncertainty to be a `REAL`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<expanded_uncertainty>(const DB& db, const LIST& params, expanded_uncertainty* in)
{
	size_t base = GenericFill(db,params,static_cast<standard_uncertainty*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to expanded_uncertainty"); }    do { // convert the 'coverage_factor' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->coverage_factor, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to expanded_uncertainty to be a `REAL`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<representation_item_relationship>(const DB& db, const LIST& params, representation_item_relationship* in)
{
	size_t base = 0;
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to representation_item_relationship"); }    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::representation_item_relationship,4>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to representation_item_relationship to be a `label`")); }
    } while(0);
    do { // convert the 'description' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::representation_item_relationship,4>::aux_is_derived[1]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->description, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to representation_item_relationship to be a `text`")); }
    } while(0);
    do { // convert the 'relating_representation_item' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::representation_item_relationship,4>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->relating_representation_item, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to representation_item_relationship to be a `representation_item`")); }
    } while(0);
    do { // convert the 'related_representation_item' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::representation_item_relationship,4>::aux_is_derived[3]=true; break; }
        try { GenericConvert( in->related_representation_item, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to representation_item_relationship to be a `representation_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<explicit_procedural_representation_item_relationship>(const DB& db, const LIST& params, explicit_procedural_representation_item_relationship* in)
{
	size_t base = GenericFill(db,params,static_cast<representation_item_relationship*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to explicit_procedural_representation_item_relationship"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<explicit_procedural_geometric_representation_item_relationship>(const DB& db, const LIST& params, explicit_procedural_geometric_representation_item_relationship* in)
{
	size_t base = GenericFill(db,params,static_cast<explicit_procedural_representation_item_relationship*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to explicit_procedural_geometric_representation_item_relationship"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<explicit_procedural_representation_relationship>(const DB& db, const LIST& params, explicit_procedural_representation_relationship* in)
{
	size_t base = GenericFill(db,params,static_cast<representation_relationship*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to explicit_procedural_representation_relationship"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<explicit_procedural_shape_representation_relationship>(const DB& db, const LIST& params, explicit_procedural_shape_representation_relationship* in)
{
	size_t base = GenericFill(db,params,static_cast<explicit_procedural_representation_relationship*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to explicit_procedural_shape_representation_relationship"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<expression_conversion_based_unit>(const DB& db, const LIST& params, expression_conversion_based_unit* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<extension>(const DB& db, const LIST& params, extension* in)
{
	size_t base = GenericFill(db,params,static_cast<derived_shape_aspect*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to extension"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<extent>(const DB& db, const LIST& params, extent* in)
{
	size_t base = GenericFill(db,params,static_cast<characterized_object*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to extent"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<external_source>(const DB& db, const LIST& params, external_source* in)
{
	size_t base = 0;
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to external_source"); }    do { // convert the 'source_id' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::external_source,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->source_id, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to external_source to be a `source_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<external_class_library>(const DB& db, const LIST& params, external_class_library* in)
{
	size_t base = GenericFill(db,params,static_cast<external_source*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to external_class_library"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<externally_defined_class>(const DB& db, const LIST& params, externally_defined_class* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<externally_defined_colour>(const DB& db, const LIST& params, externally_defined_colour* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<externally_defined_context_dependent_unit>(const DB& db, const LIST& params, externally_defined_context_dependent_unit* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<externally_defined_conversion_based_unit>(const DB& db, const LIST& params, externally_defined_conversion_based_unit* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<externally_defined_currency>(const DB& db, const LIST& params, externally_defined_currency* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<externally_defined_item>(const DB& db, const LIST& params, externally_defined_item* in)
{
	size_t base = 0;
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to externally_defined_item"); }    do { // convert the 'item_id' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::externally_defined_item,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->item_id, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to externally_defined_item to be a `source_item`")); }
    } while(0);
    do { // convert the 'source' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::externally_defined_item,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->source, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to externally_defined_item to be a `external_source`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<externally_defined_curve_font>(const DB& db, const LIST& params, externally_defined_curve_font* in)
{
	size_t base = GenericFill(db,params,static_cast<externally_defined_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to externally_defined_curve_font"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<externally_defined_dimension_definition>(const DB& db, const LIST& params, externally_defined_dimension_definition* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<externally_defined_general_property>(const DB& db, const LIST& params, externally_defined_general_property* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<externally_defined_hatch_style>(const DB& db, const LIST& params, externally_defined_hatch_style* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<externally_defined_marker>(const DB& db, const LIST& params, externally_defined_marker* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<picture_representation_item>(const DB& db, const LIST& params, picture_representation_item* in)
{
	size_t base = GenericFill(db,params,static_cast<bytes_representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to picture_representation_item"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<externally_defined_picture_representation_item>(const DB& db, const LIST& params, externally_defined_picture_representation_item* in)
{
	size_t base = GenericFill(db,params,static_cast<picture_representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to externally_defined_picture_representation_item"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<externally_defined_representation_item>(const DB& db, const LIST& params, externally_defined_representation_item* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<externally_defined_string>(const DB& db, const LIST& params, externally_defined_string* in)
{
	size_t base = GenericFill(db,params,static_cast<externally_defined_representation_item*>(in));
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<externally_defined_symbol>(const DB& db, const LIST& params, externally_defined_symbol* in)
{
	size_t base = GenericFill(db,params,static_cast<externally_defined_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to externally_defined_symbol"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<externally_defined_terminator_symbol>(const DB& db, const LIST& params, externally_defined_terminator_symbol* in)
{
	size_t base = GenericFill(db,params,static_cast<externally_defined_symbol*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to externally_defined_terminator_symbol"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<externally_defined_text_font>(const DB& db, const LIST& params, externally_defined_text_font* in)
{
	size_t base = GenericFill(db,params,static_cast<externally_defined_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to externally_defined_text_font"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<externally_defined_tile>(const DB& db, const LIST& params, externally_defined_tile* in)
{
	size_t base = GenericFill(db,params,static_cast<externally_defined_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to externally_defined_tile"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<externally_defined_tile_style>(const DB& db, const LIST& params, externally_defined_tile_style* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<swept_area_solid>(const DB& db, const LIST& params, swept_area_solid* in)
{
	size_t base = GenericFill(db,params,static_cast<solid_model*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to swept_area_solid"); }    do { // convert the 'swept_area' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::swept_area_solid,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->swept_area, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to swept_area_solid to be a `curve_bounded_surface`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<extruded_area_solid>(const DB& db, const LIST& params, extruded_area_solid* in)
{
	size_t base = GenericFill(db,params,static_cast<swept_area_solid*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to extruded_area_solid"); }    do { // convert the 'extruded_direction' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->extruded_direction, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to extruded_area_solid to be a `direction`")); }
    } while(0);
    do { // convert the 'depth' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->depth, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to extruded_area_solid to be a `positive_length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<swept_face_solid>(const DB& db, const LIST& params, swept_face_solid* in)
{
	size_t base = GenericFill(db,params,static_cast<solid_model*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to swept_face_solid"); }    do { // convert the 'swept_face' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::swept_face_solid,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->swept_face, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to swept_face_solid to be a `face_surface`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<extruded_face_solid>(const DB& db, const LIST& params, extruded_face_solid* in)
{
	size_t base = GenericFill(db,params,static_cast<swept_face_solid*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to extruded_face_solid"); }    do { // convert the 'extruded_direction' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::extruded_face_solid,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->extruded_direction, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to extruded_face_solid to be a `direction`")); }
    } while(0);
    do { // convert the 'depth' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::extruded_face_solid,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->depth, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to extruded_face_solid to be a `positive_length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<extruded_face_solid_with_trim_conditions>(const DB& db, const LIST& params, extruded_face_solid_with_trim_conditions* in)
{
	size_t base = GenericFill(db,params,static_cast<extruded_face_solid*>(in));
	if (params.GetSize() < 10) { throw STEP::TypeError("expected 10 arguments to extruded_face_solid_with_trim_conditions"); }    do { // convert the 'first_trim_condition' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::extruded_face_solid_with_trim_conditions,6>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->first_trim_condition, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to extruded_face_solid_with_trim_conditions to be a `trim_condition_select`")); }
    } while(0);
    do { // convert the 'second_trim_condition' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::extruded_face_solid_with_trim_conditions,6>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->second_trim_condition, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to extruded_face_solid_with_trim_conditions to be a `trim_condition_select`")); }
    } while(0);
    do { // convert the 'first_trim_intent' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::extruded_face_solid_with_trim_conditions,6>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->first_trim_intent, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to extruded_face_solid_with_trim_conditions to be a `trim_intent`")); }
    } while(0);
    do { // convert the 'second_trim_intent' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::extruded_face_solid_with_trim_conditions,6>::aux_is_derived[3]=true; break; }
        try { GenericConvert( in->second_trim_intent, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to extruded_face_solid_with_trim_conditions to be a `trim_intent`")); }
    } while(0);
    do { // convert the 'first_offset' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::extruded_face_solid_with_trim_conditions,6>::aux_is_derived[4]=true; break; }
        try { GenericConvert( in->first_offset, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 8 to extruded_face_solid_with_trim_conditions to be a `non_negative_length_measure`")); }
    } while(0);
    do { // convert the 'second_offset' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::extruded_face_solid_with_trim_conditions,6>::aux_is_derived[5]=true; break; }
        try { GenericConvert( in->second_offset, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 9 to extruded_face_solid_with_trim_conditions to be a `non_negative_length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<extruded_face_solid_with_draft_angle>(const DB& db, const LIST& params, extruded_face_solid_with_draft_angle* in)
{
	size_t base = GenericFill(db,params,static_cast<extruded_face_solid_with_trim_conditions*>(in));
	if (params.GetSize() < 11) { throw STEP::TypeError("expected 11 arguments to extruded_face_solid_with_draft_angle"); }    do { // convert the 'draft_angle' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->draft_angle, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 10 to extruded_face_solid_with_draft_angle to be a `plane_angle_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<extruded_face_solid_with_multiple_draft_angles>(const DB& db, const LIST& params, extruded_face_solid_with_multiple_draft_angles* in)
{
	size_t base = GenericFill(db,params,static_cast<extruded_face_solid_with_trim_conditions*>(in));
	if (params.GetSize() < 11) { throw STEP::TypeError("expected 11 arguments to extruded_face_solid_with_multiple_draft_angles"); }    do { // convert the 'draft_angles' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->draft_angles, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 10 to extruded_face_solid_with_multiple_draft_angles to be a `LIST [2:?] OF plane_angle_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<face>(const DB& db, const LIST& params, face* in)
{
	size_t base = GenericFill(db,params,static_cast<topological_representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to face"); }    do { // convert the 'bounds' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::face,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->bounds, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to face to be a `SET [1:?] OF face_bound`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<face_based_surface_model>(const DB& db, const LIST& params, face_based_surface_model* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to face_based_surface_model"); }    do { // convert the 'fbsm_faces' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->fbsm_faces, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to face_based_surface_model to be a `SET [1:?] OF connected_face_set`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<face_bound>(const DB& db, const LIST& params, face_bound* in)
{
	size_t base = GenericFill(db,params,static_cast<topological_representation_item*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to face_bound"); }    do { // convert the 'bound' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::face_bound,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->bound, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to face_bound to be a `loop`")); }
    } while(0);
    do { // convert the 'orientation' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::face_bound,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->orientation, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to face_bound to be a `BOOLEAN`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<face_outer_bound>(const DB& db, const LIST& params, face_outer_bound* in)
{
	size_t base = GenericFill(db,params,static_cast<face_bound*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to face_outer_bound"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<faceted_brep>(const DB& db, const LIST& params, faceted_brep* in)
{
	size_t base = GenericFill(db,params,static_cast<manifold_solid_brep*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to faceted_brep"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<faceted_brep_shape_representation>(const DB& db, const LIST& params, faceted_brep_shape_representation* in)
{
	size_t base = GenericFill(db,params,static_cast<shape_representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to faceted_brep_shape_representation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<fill_area_style>(const DB& db, const LIST& params, fill_area_style* in)
{
	size_t base = GenericFill(db,params,static_cast<founded_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to fill_area_style"); }    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to fill_area_style to be a `label`")); }
    } while(0);
    do { // convert the 'fill_styles' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->fill_styles, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to fill_area_style to be a `SET [1:?] OF fill_style_select`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<fill_area_style_hatching>(const DB& db, const LIST& params, fill_area_style_hatching* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_representation_item*>(in));
	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to fill_area_style_hatching"); }    do { // convert the 'hatch_line_appearance' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->hatch_line_appearance, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to fill_area_style_hatching to be a `curve_style`")); }
    } while(0);
    do { // convert the 'start_of_next_hatch_line' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->start_of_next_hatch_line, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to fill_area_style_hatching to be a `one_direction_repeat_factor`")); }
    } while(0);
    do { // convert the 'point_of_reference_hatch_line' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->point_of_reference_hatch_line, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to fill_area_style_hatching to be a `cartesian_point`")); }
    } while(0);
    do { // convert the 'pattern_start' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->pattern_start, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to fill_area_style_hatching to be a `cartesian_point`")); }
    } while(0);
    do { // convert the 'hatch_line_angle' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->hatch_line_angle, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to fill_area_style_hatching to be a `plane_angle_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<fill_area_style_tile_coloured_region>(const DB& db, const LIST& params, fill_area_style_tile_coloured_region* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_representation_item*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to fill_area_style_tile_coloured_region"); }    do { // convert the 'closed_curve' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->closed_curve, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to fill_area_style_tile_coloured_region to be a `curve_or_annotation_curve_occurrence`")); }
    } while(0);
    do { // convert the 'region_colour' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->region_colour, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to fill_area_style_tile_coloured_region to be a `colour`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<fill_area_style_tile_curve_with_style>(const DB& db, const LIST& params, fill_area_style_tile_curve_with_style* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to fill_area_style_tile_curve_with_style"); }    do { // convert the 'styled_curve' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->styled_curve, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to fill_area_style_tile_curve_with_style to be a `annotation_curve_occurrence`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<fill_area_style_tile_symbol_with_style>(const DB& db, const LIST& params, fill_area_style_tile_symbol_with_style* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to fill_area_style_tile_symbol_with_style"); }    do { // convert the 'symbol' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->symbol, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to fill_area_style_tile_symbol_with_style to be a `annotation_symbol_occurrence`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<fill_area_style_tiles>(const DB& db, const LIST& params, fill_area_style_tiles* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_representation_item*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to fill_area_style_tiles"); }    do { // convert the 'tiling_pattern' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->tiling_pattern, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to fill_area_style_tiles to be a `two_direction_repeat_factor`")); }
    } while(0);
    do { // convert the 'tiles' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->tiles, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to fill_area_style_tiles to be a `SET [1:?] OF fill_area_style_tile_shape_select`")); }
    } while(0);
    do { // convert the 'tiling_scale' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->tiling_scale, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to fill_area_style_tiles to be a `positive_ratio_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<shape_representation_relationship>(const DB& db, const LIST& params, shape_representation_relationship* in)
{
	size_t base = GenericFill(db,params,static_cast<representation_relationship*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to shape_representation_relationship"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<flat_pattern_ply_representation_relationship>(const DB& db, const LIST& params, flat_pattern_ply_representation_relationship* in)
{
	size_t base = GenericFill(db,params,static_cast<shape_representation_relationship*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to flat_pattern_ply_representation_relationship"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<flatness_tolerance>(const DB& db, const LIST& params, flatness_tolerance* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_tolerance*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to flatness_tolerance"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<force_measure_with_unit>(const DB& db, const LIST& params, force_measure_with_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<measure_with_unit*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to force_measure_with_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<force_unit>(const DB& db, const LIST& params, force_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<derived_unit*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to force_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<forward_chaining_rule>(const DB& db, const LIST& params, forward_chaining_rule* in)
{
	size_t base = GenericFill(db,params,static_cast<rule_definition*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to forward_chaining_rule"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<forward_chaining_rule_premise>(const DB& db, const LIST& params, forward_chaining_rule_premise* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<frequency_measure_with_unit>(const DB& db, const LIST& params, frequency_measure_with_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<measure_with_unit*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to frequency_measure_with_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<frequency_unit>(const DB& db, const LIST& params, frequency_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<derived_unit*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to frequency_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<func>(const DB& db, const LIST& params, func* in)
{
	size_t base = GenericFill(db,params,static_cast<compound_representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to func"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<functional_breakdown_context>(const DB& db, const LIST& params, functional_breakdown_context* in)
{
	size_t base = GenericFill(db,params,static_cast<breakdown_context*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to functional_breakdown_context"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<functional_element_usage>(const DB& db, const LIST& params, functional_element_usage* in)
{
	size_t base = GenericFill(db,params,static_cast<breakdown_element_usage*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to functional_element_usage"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<general_material_property>(const DB& db, const LIST& params, general_material_property* in)
{
	size_t base = GenericFill(db,params,static_cast<general_property*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to general_material_property"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<simple_generic_expression>(const DB& db, const LIST& params, simple_generic_expression* in)
{
	size_t base = GenericFill(db,params,static_cast<generic_expression*>(in));
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<generic_literal>(const DB& db, const LIST& params, generic_literal* in)
{
	size_t base = GenericFill(db,params,static_cast<simple_generic_expression*>(in));
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<generic_variable>(const DB& db, const LIST& params, generic_variable* in)
{
	size_t base = GenericFill(db,params,static_cast<simple_generic_expression*>(in));
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<geometric_alignment>(const DB& db, const LIST& params, geometric_alignment* in)
{
	size_t base = GenericFill(db,params,static_cast<derived_shape_aspect*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to geometric_alignment"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<geometric_set>(const DB& db, const LIST& params, geometric_set* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to geometric_set"); }    do { // convert the 'elements' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::geometric_set,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->elements, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to geometric_set to be a `SET [1:?] OF geometric_set_select`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<geometric_curve_set>(const DB& db, const LIST& params, geometric_curve_set* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_set*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to geometric_curve_set"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<geometric_intersection>(const DB& db, const LIST& params, geometric_intersection* in)
{
	size_t base = GenericFill(db,params,static_cast<derived_shape_aspect*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to geometric_intersection"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<geometric_item_specific_usage>(const DB& db, const LIST& params, geometric_item_specific_usage* in)
{
	size_t base = GenericFill(db,params,static_cast<item_identified_representation_usage*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to geometric_item_specific_usage"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<geometric_model_element_relationship>(const DB& db, const LIST& params, geometric_model_element_relationship* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<representation_context>(const DB& db, const LIST& params, representation_context* in)
{
	size_t base = 0;
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to representation_context"); }    do { // convert the 'context_identifier' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::representation_context,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->context_identifier, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to representation_context to be a `identifier`")); }
    } while(0);
    do { // convert the 'context_type' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::representation_context,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->context_type, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to representation_context to be a `text`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<geometric_representation_context>(const DB& db, const LIST& params, geometric_representation_context* in)
{
	size_t base = GenericFill(db,params,static_cast<representation_context*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to geometric_representation_context"); }    do { // convert the 'coordinate_space_dimension' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->coordinate_space_dimension, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to geometric_representation_context to be a `dimension_count`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<geometric_tolerance_with_defined_unit>(const DB& db, const LIST& params, geometric_tolerance_with_defined_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_tolerance*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to geometric_tolerance_with_defined_unit"); }    do { // convert the 'unit_size' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->unit_size, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to geometric_tolerance_with_defined_unit to be a `measure_with_unit`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<geometrical_tolerance_callout>(const DB& db, const LIST& params, geometrical_tolerance_callout* in)
{
	size_t base = GenericFill(db,params,static_cast<draughting_callout*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to geometrical_tolerance_callout"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<geometrically_bounded_2d_wireframe_representation>(const DB& db, const LIST& params, geometrically_bounded_2d_wireframe_representation* in)
{
	size_t base = GenericFill(db,params,static_cast<shape_representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to geometrically_bounded_2d_wireframe_representation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<geometrically_bounded_surface_shape_representation>(const DB& db, const LIST& params, geometrically_bounded_surface_shape_representation* in)
{
	size_t base = GenericFill(db,params,static_cast<shape_representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to geometrically_bounded_surface_shape_representation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<geometrically_bounded_wireframe_shape_representation>(const DB& db, const LIST& params, geometrically_bounded_wireframe_shape_representation* in)
{
	size_t base = GenericFill(db,params,static_cast<shape_representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to geometrically_bounded_wireframe_shape_representation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<global_assignment>(const DB& db, const LIST& params, global_assignment* in)
{
	size_t base = GenericFill(db,params,static_cast<representation_item_relationship*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to global_assignment"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<global_uncertainty_assigned_context>(const DB& db, const LIST& params, global_uncertainty_assigned_context* in)
{
	size_t base = GenericFill(db,params,static_cast<representation_context*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to global_uncertainty_assigned_context"); }    do { // convert the 'uncertainty' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->uncertainty, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to global_uncertainty_assigned_context to be a `SET [1:?] OF uncertainty_measure_with_unit`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<global_unit_assigned_context>(const DB& db, const LIST& params, global_unit_assigned_context* in)
{
	size_t base = GenericFill(db,params,static_cast<representation_context*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to global_unit_assigned_context"); }    do { // convert the 'units' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->units, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to global_unit_assigned_context to be a `SET [1:?] OF unit`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<ground_fact>(const DB& db, const LIST& params, ground_fact* in)
{
	size_t base = GenericFill(db,params,static_cast<atomic_formula*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to ground_fact"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<hardness_representation>(const DB& db, const LIST& params, hardness_representation* in)
{
	size_t base = GenericFill(db,params,static_cast<representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to hardness_representation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<hidden_element_over_riding_styled_item>(const DB& db, const LIST& params, hidden_element_over_riding_styled_item* in)
{
	size_t base = GenericFill(db,params,static_cast<context_dependent_over_riding_styled_item*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to hidden_element_over_riding_styled_item"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<hyperbola>(const DB& db, const LIST& params, hyperbola* in)
{
	size_t base = GenericFill(db,params,static_cast<conic*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to hyperbola"); }    do { // convert the 'semi_axis' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->semi_axis, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to hyperbola to be a `positive_length_measure`")); }
    } while(0);
    do { // convert the 'semi_imag_axis' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->semi_imag_axis, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to hyperbola to be a `positive_length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<illuminance_measure_with_unit>(const DB& db, const LIST& params, illuminance_measure_with_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<measure_with_unit*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to illuminance_measure_with_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<illuminance_unit>(const DB& db, const LIST& params, illuminance_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<derived_unit*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to illuminance_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<included_text_block>(const DB& db, const LIST& params, included_text_block* in)
{
	size_t base = GenericFill(db,params,static_cast<mapped_item*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to included_text_block"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<inclusion_product_concept_feature>(const DB& db, const LIST& params, inclusion_product_concept_feature* in)
{
	size_t base = GenericFill(db,params,static_cast<conditional_concept_feature*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to inclusion_product_concept_feature"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<user_selected_elements>(const DB& db, const LIST& params, user_selected_elements* in)
{
	size_t base = GenericFill(db,params,static_cast<representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to user_selected_elements"); }    do { // convert the 'picked_items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::user_selected_elements,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->picked_items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to user_selected_elements to be a `SET [1:?] OF representation_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<indirectly_selected_elements>(const DB& db, const LIST& params, indirectly_selected_elements* in)
{
	size_t base = GenericFill(db,params,static_cast<user_selected_elements*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to indirectly_selected_elements"); }    do { // convert the 'indirectly_picked_items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->indirectly_picked_items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to indirectly_selected_elements to be a `SET [1:?] OF representation_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<indirectly_selected_shape_elements>(const DB& db, const LIST& params, indirectly_selected_shape_elements* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<inductance_measure_with_unit>(const DB& db, const LIST& params, inductance_measure_with_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<measure_with_unit*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to inductance_measure_with_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<inductance_unit>(const DB& db, const LIST& params, inductance_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<derived_unit*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to inductance_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<information_right>(const DB& db, const LIST& params, information_right* in)
{
	size_t base = GenericFill(db,params,static_cast<action_method*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to information_right"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<information_usage_right>(const DB& db, const LIST& params, information_usage_right* in)
{
	size_t base = GenericFill(db,params,static_cast<action_method*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to information_usage_right"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<instance_usage_context_assignment>(const DB& db, const LIST& params, instance_usage_context_assignment* in)
{
	size_t base = GenericFill(db,params,static_cast<product_definition_context*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to instance_usage_context_assignment"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to instance_usage_context_assignment to be a `SET [1:?] OF instance_usage_context_select`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<instanced_feature>(const DB& db, const LIST& params, instanced_feature* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<literal_number>(const DB& db, const LIST& params, literal_number* in)
{
	size_t base = 0;
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to literal_number"); }    do { // convert the 'the_value' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::literal_number,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->the_value, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to literal_number to be a `NUMBER`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<int_literal>(const DB& db, const LIST& params, int_literal* in)
{
	size_t base = GenericFill(db,params,static_cast<literal_number*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to int_literal"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<integer_representation_item>(const DB& db, const LIST& params, integer_representation_item* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<surface_curve>(const DB& db, const LIST& params, surface_curve* in)
{
	size_t base = GenericFill(db,params,static_cast<curve*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to surface_curve"); }    do { // convert the 'curve_3d' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::surface_curve,3>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->curve_3d, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to surface_curve to be a `curve`")); }
    } while(0);
    do { // convert the 'associated_geometry' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::surface_curve,3>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->associated_geometry, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to surface_curve to be a `LIST [1:2] OF pcurve_or_surface`")); }
    } while(0);
    do { // convert the 'master_representation' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::surface_curve,3>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->master_representation, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to surface_curve to be a `preferred_surface_curve_representation`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<intersection_curve>(const DB& db, const LIST& params, intersection_curve* in)
{
	size_t base = GenericFill(db,params,static_cast<surface_curve*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to intersection_curve"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<interval_expression>(const DB& db, const LIST& params, interval_expression* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<iso4217_currency>(const DB& db, const LIST& params, iso4217_currency* in)
{
	size_t base = GenericFill(db,params,static_cast<currency*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to iso4217_currency"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<known_source>(const DB& db, const LIST& params, known_source* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<laid_defined_transformation>(const DB& db, const LIST& params, laid_defined_transformation* in)
{
	size_t base = GenericFill(db,params,static_cast<transformation_with_derived_angle*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to laid_defined_transformation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<language>(const DB& db, const LIST& params, language* in)
{
	size_t base = GenericFill(db,params,static_cast<group*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to language"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<leader_curve>(const DB& db, const LIST& params, leader_curve* in)
{
	size_t base = GenericFill(db,params,static_cast<annotation_curve_occurrence*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to leader_curve"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<leader_directed_callout>(const DB& db, const LIST& params, leader_directed_callout* in)
{
	size_t base = GenericFill(db,params,static_cast<draughting_callout*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to leader_directed_callout"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<leader_directed_dimension>(const DB& db, const LIST& params, leader_directed_dimension* in)
{
	size_t base = GenericFill(db,params,static_cast<leader_directed_callout*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to leader_directed_dimension"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<leader_terminator>(const DB& db, const LIST& params, leader_terminator* in)
{
	size_t base = GenericFill(db,params,static_cast<terminator_symbol*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to leader_terminator"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<length_measure_with_unit>(const DB& db, const LIST& params, length_measure_with_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<measure_with_unit*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to length_measure_with_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<length_unit>(const DB& db, const LIST& params, length_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<named_unit*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to length_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<light_source>(const DB& db, const LIST& params, light_source* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to light_source"); }    do { // convert the 'light_colour' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::light_source,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->light_colour, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to light_source to be a `colour`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<light_source_ambient>(const DB& db, const LIST& params, light_source_ambient* in)
{
	size_t base = GenericFill(db,params,static_cast<light_source*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to light_source_ambient"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<light_source_directional>(const DB& db, const LIST& params, light_source_directional* in)
{
	size_t base = GenericFill(db,params,static_cast<light_source*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to light_source_directional"); }    do { // convert the 'orientation' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->orientation, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to light_source_directional to be a `direction`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<light_source_positional>(const DB& db, const LIST& params, light_source_positional* in)
{
	size_t base = GenericFill(db,params,static_cast<light_source*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to light_source_positional"); }    do { // convert the 'position' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->position, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to light_source_positional to be a `cartesian_point`")); }
    } while(0);
    do { // convert the 'constant_attenuation' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->constant_attenuation, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to light_source_positional to be a `REAL`")); }
    } while(0);
    do { // convert the 'distance_attenuation' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->distance_attenuation, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to light_source_positional to be a `REAL`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<light_source_spot>(const DB& db, const LIST& params, light_source_spot* in)
{
	size_t base = GenericFill(db,params,static_cast<light_source*>(in));
	if (params.GetSize() < 8) { throw STEP::TypeError("expected 8 arguments to light_source_spot"); }    do { // convert the 'position' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->position, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to light_source_spot to be a `cartesian_point`")); }
    } while(0);
    do { // convert the 'orientation' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->orientation, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to light_source_spot to be a `direction`")); }
    } while(0);
    do { // convert the 'concentration_exponent' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->concentration_exponent, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to light_source_spot to be a `REAL`")); }
    } while(0);
    do { // convert the 'constant_attenuation' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->constant_attenuation, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to light_source_spot to be a `REAL`")); }
    } while(0);
    do { // convert the 'distance_attenuation' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->distance_attenuation, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to light_source_spot to be a `REAL`")); }
    } while(0);
    do { // convert the 'spread_angle' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->spread_angle, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to light_source_spot to be a `positive_plane_angle_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<line>(const DB& db, const LIST& params, line* in)
{
	size_t base = GenericFill(db,params,static_cast<curve*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to line"); }    do { // convert the 'pnt' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->pnt, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to line to be a `cartesian_point`")); }
    } while(0);
    do { // convert the 'dir' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->dir, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to line to be a `vector`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<line_profile_tolerance>(const DB& db, const LIST& params, line_profile_tolerance* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_tolerance*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to line_profile_tolerance"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<linear_dimension>(const DB& db, const LIST& params, linear_dimension* in)
{
	size_t base = GenericFill(db,params,static_cast<dimension_curve_directed_callout*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to linear_dimension"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<simple_clause>(const DB& db, const LIST& params, simple_clause* in)
{
	size_t base = GenericFill(db,params,static_cast<compound_representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to simple_clause"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<literal_conjunction>(const DB& db, const LIST& params, literal_conjunction* in)
{
	size_t base = GenericFill(db,params,static_cast<simple_clause*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to literal_conjunction"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<literal_disjunction>(const DB& db, const LIST& params, literal_disjunction* in)
{
	size_t base = GenericFill(db,params,static_cast<simple_clause*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to literal_disjunction"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<logical_literal>(const DB& db, const LIST& params, logical_literal* in)
{
	size_t base = GenericFill(db,params,static_cast<generic_literal*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to logical_literal"); }    do { // convert the 'lit_value' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->lit_value, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to logical_literal to be a `LOGICAL`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<logical_representation_item>(const DB& db, const LIST& params, logical_representation_item* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<loop>(const DB& db, const LIST& params, loop* in)
{
	size_t base = GenericFill(db,params,static_cast<topological_representation_item*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to loop"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<loss_tangent_measure_with_unit>(const DB& db, const LIST& params, loss_tangent_measure_with_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<ratio_measure_with_unit*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to loss_tangent_measure_with_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<lot_effectivity>(const DB& db, const LIST& params, lot_effectivity* in)
{
	size_t base = GenericFill(db,params,static_cast<effectivity*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to lot_effectivity"); }    do { // convert the 'effectivity_lot_id' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->effectivity_lot_id, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to lot_effectivity to be a `identifier`")); }
    } while(0);
    do { // convert the 'effectivity_lot_size' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->effectivity_lot_size, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to lot_effectivity to be a `measure_with_unit`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<luminous_flux_measure_with_unit>(const DB& db, const LIST& params, luminous_flux_measure_with_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<measure_with_unit*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to luminous_flux_measure_with_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<luminous_flux_unit>(const DB& db, const LIST& params, luminous_flux_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<named_unit*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to luminous_flux_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<luminous_intensity_measure_with_unit>(const DB& db, const LIST& params, luminous_intensity_measure_with_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<measure_with_unit*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to luminous_intensity_measure_with_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<luminous_intensity_unit>(const DB& db, const LIST& params, luminous_intensity_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<named_unit*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to luminous_intensity_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<magnetic_flux_density_measure_with_unit>(const DB& db, const LIST& params, magnetic_flux_density_measure_with_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<measure_with_unit*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to magnetic_flux_density_measure_with_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<magnetic_flux_density_unit>(const DB& db, const LIST& params, magnetic_flux_density_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<derived_unit*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to magnetic_flux_density_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<magnetic_flux_measure_with_unit>(const DB& db, const LIST& params, magnetic_flux_measure_with_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<measure_with_unit*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to magnetic_flux_measure_with_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<magnetic_flux_unit>(const DB& db, const LIST& params, magnetic_flux_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<derived_unit*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to magnetic_flux_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<make_from_usage_option>(const DB& db, const LIST& params, make_from_usage_option* in)
{
	size_t base = GenericFill(db,params,static_cast<product_definition_usage*>(in));
	if (params.GetSize() < 8) { throw STEP::TypeError("expected 8 arguments to make_from_usage_option"); }    do { // convert the 'ranking' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->ranking, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to make_from_usage_option to be a `INTEGER`")); }
    } while(0);
    do { // convert the 'ranking_rationale' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->ranking_rationale, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to make_from_usage_option to be a `text`")); }
    } while(0);
    do { // convert the 'quantity' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->quantity, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to make_from_usage_option to be a `measure_with_unit`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<manifold_subsurface_shape_representation>(const DB& db, const LIST& params, manifold_subsurface_shape_representation* in)
{
	size_t base = GenericFill(db,params,static_cast<shape_representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to manifold_subsurface_shape_representation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<manifold_surface_shape_representation>(const DB& db, const LIST& params, manifold_surface_shape_representation* in)
{
	size_t base = GenericFill(db,params,static_cast<shape_representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to manifold_surface_shape_representation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<mass_measure_with_unit>(const DB& db, const LIST& params, mass_measure_with_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<measure_with_unit*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to mass_measure_with_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<mass_unit>(const DB& db, const LIST& params, mass_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<named_unit*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to mass_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<material_property>(const DB& db, const LIST& params, material_property* in)
{
	size_t base = GenericFill(db,params,static_cast<property_definition*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to material_property"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<property_definition_representation>(const DB& db, const LIST& params, property_definition_representation* in)
{
	size_t base = 0;
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to property_definition_representation"); }    do { // convert the 'definition' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::property_definition_representation,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->definition, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to property_definition_representation to be a `represented_definition`")); }
    } while(0);
    do { // convert the 'used_representation' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::property_definition_representation,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->used_representation, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to property_definition_representation to be a `representation`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<material_property_representation>(const DB& db, const LIST& params, material_property_representation* in)
{
	size_t base = GenericFill(db,params,static_cast<property_definition_representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to material_property_representation"); }    do { // convert the 'dependent_environment' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->dependent_environment, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to material_property_representation to be a `data_environment`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<measure_representation_item>(const DB& db, const LIST& params, measure_representation_item* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<product_context>(const DB& db, const LIST& params, product_context* in)
{
	size_t base = GenericFill(db,params,static_cast<application_context_element*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to product_context"); }    do { // convert the 'discipline_type' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::product_context,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->discipline_type, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to product_context to be a `label`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<mechanical_context>(const DB& db, const LIST& params, mechanical_context* in)
{
	size_t base = GenericFill(db,params,static_cast<product_context*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to mechanical_context"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<mechanical_design_and_draughting_relationship>(const DB& db, const LIST& params, mechanical_design_and_draughting_relationship* in)
{
	size_t base = GenericFill(db,params,static_cast<definitional_representation_relationship_with_same_context*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to mechanical_design_and_draughting_relationship"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<mechanical_design_geometric_presentation_area>(const DB& db, const LIST& params, mechanical_design_geometric_presentation_area* in)
{
	size_t base = GenericFill(db,params,static_cast<presentation_area*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to mechanical_design_geometric_presentation_area"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<mechanical_design_geometric_presentation_representation>(const DB& db, const LIST& params, mechanical_design_geometric_presentation_representation* in)
{
	size_t base = GenericFill(db,params,static_cast<representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to mechanical_design_geometric_presentation_representation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<mechanical_design_presentation_representation_with_draughting>(const DB& db, const LIST& params, mechanical_design_presentation_representation_with_draughting* in)
{
	size_t base = GenericFill(db,params,static_cast<representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to mechanical_design_presentation_representation_with_draughting"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<mechanical_design_shaded_presentation_area>(const DB& db, const LIST& params, mechanical_design_shaded_presentation_area* in)
{
	size_t base = GenericFill(db,params,static_cast<presentation_area*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to mechanical_design_shaded_presentation_area"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<mechanical_design_shaded_presentation_representation>(const DB& db, const LIST& params, mechanical_design_shaded_presentation_representation* in)
{
	size_t base = GenericFill(db,params,static_cast<representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to mechanical_design_shaded_presentation_representation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<min_and_major_ply_orientation_basis>(const DB& db, const LIST& params, min_and_major_ply_orientation_basis* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<modified_geometric_tolerance>(const DB& db, const LIST& params, modified_geometric_tolerance* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_tolerance*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to modified_geometric_tolerance"); }    do { // convert the 'modifier' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->modifier, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to modified_geometric_tolerance to be a `limit_condition`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<modified_solid_with_placed_configuration>(const DB& db, const LIST& params, modified_solid_with_placed_configuration* in)
{
	size_t base = GenericFill(db,params,static_cast<modified_solid*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to modified_solid_with_placed_configuration"); }    do { // convert the 'placing' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::modified_solid_with_placed_configuration,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->placing, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to modified_solid_with_placed_configuration to be a `axis2_placement_3d`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<moments_of_inertia_representation>(const DB& db, const LIST& params, moments_of_inertia_representation* in)
{
	size_t base = GenericFill(db,params,static_cast<representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to moments_of_inertia_representation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<multi_language_attribute_assignment>(const DB& db, const LIST& params, multi_language_attribute_assignment* in)
{
	size_t base = GenericFill(db,params,static_cast<attribute_value_assignment*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to multi_language_attribute_assignment"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to multi_language_attribute_assignment to be a `SET [1:?] OF multi_language_attribute_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<multiple_arity_boolean_expression>(const DB& db, const LIST& params, multiple_arity_boolean_expression* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<multiple_arity_generic_expression>(const DB& db, const LIST& params, multiple_arity_generic_expression* in)
{
	size_t base = GenericFill(db,params,static_cast<generic_expression*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to multiple_arity_generic_expression"); }    do { // convert the 'operands' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->operands, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to multiple_arity_generic_expression to be a `LIST [2:?] OF generic_expression`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<multiple_arity_numeric_expression>(const DB& db, const LIST& params, multiple_arity_numeric_expression* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<next_assembly_usage_occurrence>(const DB& db, const LIST& params, next_assembly_usage_occurrence* in)
{
	size_t base = GenericFill(db,params,static_cast<assembly_component_usage*>(in));
	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to next_assembly_usage_occurrence"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<non_manifold_surface_shape_representation>(const DB& db, const LIST& params, non_manifold_surface_shape_representation* in)
{
	size_t base = GenericFill(db,params,static_cast<shape_representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to non_manifold_surface_shape_representation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<null_representation_item>(const DB& db, const LIST& params, null_representation_item* in)
{
	size_t base = GenericFill(db,params,static_cast<representation_item*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to null_representation_item"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<numeric_expression>(const DB& db, const LIST& params, numeric_expression* in)
{
	size_t base = GenericFill(db,params,static_cast<expression*>(in));
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<offset_curve_2d>(const DB& db, const LIST& params, offset_curve_2d* in)
{
	size_t base = GenericFill(db,params,static_cast<curve*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to offset_curve_2d"); }    do { // convert the 'basis_curve' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->basis_curve, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to offset_curve_2d to be a `curve`")); }
    } while(0);
    do { // convert the 'distance' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->distance, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to offset_curve_2d to be a `length_measure`")); }
    } while(0);
    do { // convert the 'self_intersect' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->self_intersect, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to offset_curve_2d to be a `LOGICAL`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<offset_curve_3d>(const DB& db, const LIST& params, offset_curve_3d* in)
{
	size_t base = GenericFill(db,params,static_cast<curve*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to offset_curve_3d"); }    do { // convert the 'basis_curve' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->basis_curve, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to offset_curve_3d to be a `curve`")); }
    } while(0);
    do { // convert the 'distance' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->distance, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to offset_curve_3d to be a `length_measure`")); }
    } while(0);
    do { // convert the 'self_intersect' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->self_intersect, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to offset_curve_3d to be a `LOGICAL`")); }
    } while(0);
    do { // convert the 'ref_direction' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->ref_direction, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to offset_curve_3d to be a `direction`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<offset_surface>(const DB& db, const LIST& params, offset_surface* in)
{
	size_t base = GenericFill(db,params,static_cast<surface*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to offset_surface"); }    do { // convert the 'basis_surface' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->basis_surface, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to offset_surface to be a `surface`")); }
    } while(0);
    do { // convert the 'distance' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->distance, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to offset_surface to be a `length_measure`")); }
    } while(0);
    do { // convert the 'self_intersect' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->self_intersect, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to offset_surface to be a `LOGICAL`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<one_direction_repeat_factor>(const DB& db, const LIST& params, one_direction_repeat_factor* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to one_direction_repeat_factor"); }    do { // convert the 'repeat_factor' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::one_direction_repeat_factor,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->repeat_factor, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to one_direction_repeat_factor to be a `vector`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<open_shell>(const DB& db, const LIST& params, open_shell* in)
{
	size_t base = GenericFill(db,params,static_cast<connected_face_set*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to open_shell"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<ordinal_date>(const DB& db, const LIST& params, ordinal_date* in)
{
	size_t base = GenericFill(db,params,static_cast<date*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to ordinal_date"); }    do { // convert the 'day_component' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->day_component, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to ordinal_date to be a `day_in_year_number`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<projection_directed_callout>(const DB& db, const LIST& params, projection_directed_callout* in)
{
	size_t base = GenericFill(db,params,static_cast<draughting_callout*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to projection_directed_callout"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<ordinate_dimension>(const DB& db, const LIST& params, ordinate_dimension* in)
{
	size_t base = GenericFill(db,params,static_cast<projection_directed_callout*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to ordinate_dimension"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<organizational_address>(const DB& db, const LIST& params, organizational_address* in)
{
	size_t base = GenericFill(db,params,static_cast<address*>(in));
	if (params.GetSize() < 14) { throw STEP::TypeError("expected 14 arguments to organizational_address"); }    do { // convert the 'organizations' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->organizations, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 12 to organizational_address to be a `SET [1:?] OF organization`")); }
    } while(0);
    do { // convert the 'description' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->description, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 13 to organizational_address to be a `text`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<oriented_closed_shell>(const DB& db, const LIST& params, oriented_closed_shell* in)
{
	size_t base = GenericFill(db,params,static_cast<closed_shell*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to oriented_closed_shell"); }    do { // convert the 'closed_shell_element' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->closed_shell_element, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to oriented_closed_shell to be a `closed_shell`")); }
    } while(0);
    do { // convert the 'orientation' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->orientation, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to oriented_closed_shell to be a `BOOLEAN`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<oriented_edge>(const DB& db, const LIST& params, oriented_edge* in)
{
	size_t base = GenericFill(db,params,static_cast<edge*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to oriented_edge"); }    do { // convert the 'edge_element' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->edge_element, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to oriented_edge to be a `edge`")); }
    } while(0);
    do { // convert the 'orientation' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->orientation, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to oriented_edge to be a `BOOLEAN`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<oriented_face>(const DB& db, const LIST& params, oriented_face* in)
{
	size_t base = GenericFill(db,params,static_cast<face*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to oriented_face"); }    do { // convert the 'face_element' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->face_element, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to oriented_face to be a `face`")); }
    } while(0);
    do { // convert the 'orientation' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->orientation, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to oriented_face to be a `BOOLEAN`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<oriented_open_shell>(const DB& db, const LIST& params, oriented_open_shell* in)
{
	size_t base = GenericFill(db,params,static_cast<open_shell*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to oriented_open_shell"); }    do { // convert the 'open_shell_element' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->open_shell_element, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to oriented_open_shell to be a `open_shell`")); }
    } while(0);
    do { // convert the 'orientation' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->orientation, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to oriented_open_shell to be a `BOOLEAN`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<path>(const DB& db, const LIST& params, path* in)
{
	size_t base = GenericFill(db,params,static_cast<topological_representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to path"); }    do { // convert the 'edge_list' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::path,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->edge_list, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to path to be a `LIST [1:?] OF oriented_edge`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<oriented_path>(const DB& db, const LIST& params, oriented_path* in)
{
	size_t base = GenericFill(db,params,static_cast<path*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to oriented_path"); }    do { // convert the 'path_element' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->path_element, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to oriented_path to be a `path`")); }
    } while(0);
    do { // convert the 'orientation' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->orientation, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to oriented_path to be a `BOOLEAN`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<oriented_surface>(const DB& db, const LIST& params, oriented_surface* in)
{
	size_t base = GenericFill(db,params,static_cast<surface*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to oriented_surface"); }    do { // convert the 'orientation' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->orientation, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to oriented_surface to be a `BOOLEAN`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<outer_boundary_curve>(const DB& db, const LIST& params, outer_boundary_curve* in)
{
	size_t base = GenericFill(db,params,static_cast<boundary_curve*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to outer_boundary_curve"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<package_product_concept_feature>(const DB& db, const LIST& params, package_product_concept_feature* in)
{
	size_t base = GenericFill(db,params,static_cast<product_concept_feature*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to package_product_concept_feature"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<parabola>(const DB& db, const LIST& params, parabola* in)
{
	size_t base = GenericFill(db,params,static_cast<conic*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to parabola"); }    do { // convert the 'focal_dist' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->focal_dist, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to parabola to be a `length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<parallel_offset>(const DB& db, const LIST& params, parallel_offset* in)
{
	size_t base = GenericFill(db,params,static_cast<derived_shape_aspect*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to parallel_offset"); }    do { // convert the 'offset' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->offset, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to parallel_offset to be a `measure_with_unit`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<parallelism_tolerance>(const DB& db, const LIST& params, parallelism_tolerance* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_tolerance_with_datum_reference*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to parallelism_tolerance"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<parametric_representation_context>(const DB& db, const LIST& params, parametric_representation_context* in)
{
	size_t base = GenericFill(db,params,static_cast<representation_context*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to parametric_representation_context"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<partial_document_with_structured_text_representation_assignment>(const DB& db, const LIST& params, partial_document_with_structured_text_representation_assignment* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<pcurve>(const DB& db, const LIST& params, pcurve* in)
{
	size_t base = GenericFill(db,params,static_cast<curve*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to pcurve"); }    do { // convert the 'basis_surface' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->basis_surface, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to pcurve to be a `surface`")); }
    } while(0);
    do { // convert the 'reference_to_curve' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->reference_to_curve, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to pcurve to be a `definitional_representation`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<percentage_laminate_definition>(const DB& db, const LIST& params, percentage_laminate_definition* in)
{
	size_t base = GenericFill(db,params,static_cast<product_definition*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to percentage_laminate_definition"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<zone_structural_makeup>(const DB& db, const LIST& params, zone_structural_makeup* in)
{
	size_t base = GenericFill(db,params,static_cast<laminate_table*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to zone_structural_makeup"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<percentage_laminate_table>(const DB& db, const LIST& params, percentage_laminate_table* in)
{
	size_t base = GenericFill(db,params,static_cast<zone_structural_makeup*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to percentage_laminate_table"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<percentage_ply_definition>(const DB& db, const LIST& params, percentage_ply_definition* in)
{
	size_t base = GenericFill(db,params,static_cast<product_definition*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to percentage_ply_definition"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<perpendicular_to>(const DB& db, const LIST& params, perpendicular_to* in)
{
	size_t base = GenericFill(db,params,static_cast<derived_shape_aspect*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to perpendicular_to"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<perpendicularity_tolerance>(const DB& db, const LIST& params, perpendicularity_tolerance* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_tolerance_with_datum_reference*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to perpendicularity_tolerance"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<person_and_organization_address>(const DB& db, const LIST& params, person_and_organization_address* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<personal_address>(const DB& db, const LIST& params, personal_address* in)
{
	size_t base = GenericFill(db,params,static_cast<address*>(in));
	if (params.GetSize() < 14) { throw STEP::TypeError("expected 14 arguments to personal_address"); }    do { // convert the 'people' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->people, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 12 to personal_address to be a `SET [1:?] OF person`")); }
    } while(0);
    do { // convert the 'description' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->description, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 13 to personal_address to be a `text`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<physical_breakdown_context>(const DB& db, const LIST& params, physical_breakdown_context* in)
{
	size_t base = GenericFill(db,params,static_cast<breakdown_context*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to physical_breakdown_context"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<physical_element_usage>(const DB& db, const LIST& params, physical_element_usage* in)
{
	size_t base = GenericFill(db,params,static_cast<breakdown_element_usage*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to physical_element_usage"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<presentation_view>(const DB& db, const LIST& params, presentation_view* in)
{
	size_t base = GenericFill(db,params,static_cast<presentation_representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to presentation_view"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<picture_representation>(const DB& db, const LIST& params, picture_representation* in)
{
	size_t base = GenericFill(db,params,static_cast<presentation_view*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to picture_representation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<placed_datum_target_feature>(const DB& db, const LIST& params, placed_datum_target_feature* in)
{
	size_t base = GenericFill(db,params,static_cast<datum_target*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to placed_datum_target_feature"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<placed_feature>(const DB& db, const LIST& params, placed_feature* in)
{
	size_t base = GenericFill(db,params,static_cast<shape_aspect*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to placed_feature"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<planar_extent>(const DB& db, const LIST& params, planar_extent* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_representation_item*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to planar_extent"); }    do { // convert the 'size_in_x' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::planar_extent,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->size_in_x, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to planar_extent to be a `length_measure`")); }
    } while(0);
    do { // convert the 'size_in_y' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::planar_extent,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->size_in_y, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to planar_extent to be a `length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<planar_box>(const DB& db, const LIST& params, planar_box* in)
{
	size_t base = GenericFill(db,params,static_cast<planar_extent*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to planar_box"); }    do { // convert the 'placement' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->placement, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to planar_box to be a `axis2_placement`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<plane>(const DB& db, const LIST& params, plane* in)
{
	size_t base = GenericFill(db,params,static_cast<elementary_surface*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to plane"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<plane_angle_measure_with_unit>(const DB& db, const LIST& params, plane_angle_measure_with_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<measure_with_unit*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to plane_angle_measure_with_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<plane_angle_unit>(const DB& db, const LIST& params, plane_angle_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<named_unit*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to plane_angle_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<ply_laminate_definition>(const DB& db, const LIST& params, ply_laminate_definition* in)
{
	size_t base = GenericFill(db,params,static_cast<product_definition*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to ply_laminate_definition"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<ply_laminate_sequence_definition>(const DB& db, const LIST& params, ply_laminate_sequence_definition* in)
{
	size_t base = GenericFill(db,params,static_cast<product_definition*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to ply_laminate_sequence_definition"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<ply_laminate_table>(const DB& db, const LIST& params, ply_laminate_table* in)
{
	size_t base = GenericFill(db,params,static_cast<part_laminate_table*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to ply_laminate_table"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<point_and_vector>(const DB& db, const LIST& params, point_and_vector* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<point_on_curve>(const DB& db, const LIST& params, point_on_curve* in)
{
	size_t base = GenericFill(db,params,static_cast<point*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to point_on_curve"); }    do { // convert the 'basis_curve' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->basis_curve, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to point_on_curve to be a `curve`")); }
    } while(0);
    do { // convert the 'point_parameter' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->point_parameter, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to point_on_curve to be a `parameter_value`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<point_on_surface>(const DB& db, const LIST& params, point_on_surface* in)
{
	size_t base = GenericFill(db,params,static_cast<point*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to point_on_surface"); }    do { // convert the 'basis_surface' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->basis_surface, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to point_on_surface to be a `surface`")); }
    } while(0);
    do { // convert the 'point_parameter_u' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->point_parameter_u, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to point_on_surface to be a `parameter_value`")); }
    } while(0);
    do { // convert the 'point_parameter_v' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->point_parameter_v, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to point_on_surface to be a `parameter_value`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<point_path>(const DB& db, const LIST& params, point_path* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<point_replica>(const DB& db, const LIST& params, point_replica* in)
{
	size_t base = GenericFill(db,params,static_cast<point*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to point_replica"); }    do { // convert the 'parent_pt' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->parent_pt, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to point_replica to be a `point`")); }
    } while(0);
    do { // convert the 'transformation' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->transformation, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to point_replica to be a `cartesian_transformation_operator`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<point_style>(const DB& db, const LIST& params, point_style* in)
{
	size_t base = GenericFill(db,params,static_cast<founded_item*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to point_style"); }    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to point_style to be a `label`")); }
    } while(0);
    do { // convert the 'marker' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->marker, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to point_style to be a `marker_select`")); }
    } while(0);
    do { // convert the 'marker_size' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->marker_size, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to point_style to be a `size_select`")); }
    } while(0);
    do { // convert the 'marker_colour' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->marker_colour, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to point_style to be a `colour`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<polar_complex_number_literal>(const DB& db, const LIST& params, polar_complex_number_literal* in)
{
	size_t base = GenericFill(db,params,static_cast<generic_literal*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to polar_complex_number_literal"); }    do { // convert the 'radius' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::polar_complex_number_literal,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->radius, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to polar_complex_number_literal to be a `REAL`")); }
    } while(0);
    do { // convert the 'angle' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::polar_complex_number_literal,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->angle, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to polar_complex_number_literal to be a `REAL`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<poly_loop>(const DB& db, const LIST& params, poly_loop* in)
{
	size_t base = 0;
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to poly_loop"); }    do { // convert the 'polygon' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->polygon, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to poly_loop to be a `LIST [3:?] OF cartesian_point`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<polyline>(const DB& db, const LIST& params, polyline* in)
{
	size_t base = GenericFill(db,params,static_cast<bounded_curve*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to polyline"); }    do { // convert the 'points' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->points, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to polyline to be a `LIST [2:?] OF cartesian_point`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<position_tolerance>(const DB& db, const LIST& params, position_tolerance* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_tolerance*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to position_tolerance"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<positioned_sketch>(const DB& db, const LIST& params, positioned_sketch* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_representation_item*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to positioned_sketch"); }    do { // convert the 'sketch_basis' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->sketch_basis, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to positioned_sketch to be a `sketch_basis_select`")); }
    } while(0);
    do { // convert the 'auxiliary_elements' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->auxiliary_elements, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to positioned_sketch to be a `SET [0:?] OF auxiliary_geometric_representation_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<power_measure_with_unit>(const DB& db, const LIST& params, power_measure_with_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<measure_with_unit*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to power_measure_with_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<power_unit>(const DB& db, const LIST& params, power_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<derived_unit*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to power_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<pre_defined_symbol>(const DB& db, const LIST& params, pre_defined_symbol* in)
{
	size_t base = GenericFill(db,params,static_cast<pre_defined_item*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to pre_defined_symbol"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<pre_defined_dimension_symbol>(const DB& db, const LIST& params, pre_defined_dimension_symbol* in)
{
	size_t base = GenericFill(db,params,static_cast<pre_defined_symbol*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to pre_defined_dimension_symbol"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<pre_defined_geometrical_tolerance_symbol>(const DB& db, const LIST& params, pre_defined_geometrical_tolerance_symbol* in)
{
	size_t base = GenericFill(db,params,static_cast<pre_defined_symbol*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to pre_defined_geometrical_tolerance_symbol"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<pre_defined_marker>(const DB& db, const LIST& params, pre_defined_marker* in)
{
	size_t base = GenericFill(db,params,static_cast<pre_defined_item*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to pre_defined_marker"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<pre_defined_point_marker_symbol>(const DB& db, const LIST& params, pre_defined_point_marker_symbol* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<pre_defined_surface_condition_symbol>(const DB& db, const LIST& params, pre_defined_surface_condition_symbol* in)
{
	size_t base = GenericFill(db,params,static_cast<pre_defined_symbol*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to pre_defined_surface_condition_symbol"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<pre_defined_surface_side_style>(const DB& db, const LIST& params, pre_defined_surface_side_style* in)
{
	size_t base = GenericFill(db,params,static_cast<pre_defined_item*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to pre_defined_surface_side_style"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<pre_defined_terminator_symbol>(const DB& db, const LIST& params, pre_defined_terminator_symbol* in)
{
	size_t base = GenericFill(db,params,static_cast<pre_defined_symbol*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to pre_defined_terminator_symbol"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<pre_defined_tile>(const DB& db, const LIST& params, pre_defined_tile* in)
{
	size_t base = GenericFill(db,params,static_cast<pre_defined_item*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to pre_defined_tile"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<predefined_picture_representation_item>(const DB& db, const LIST& params, predefined_picture_representation_item* in)
{
	size_t base = GenericFill(db,params,static_cast<picture_representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to predefined_picture_representation_item"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<presentation_style_assignment>(const DB& db, const LIST& params, presentation_style_assignment* in)
{
	size_t base = GenericFill(db,params,static_cast<founded_item*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to presentation_style_assignment"); }    do { // convert the 'styles' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::presentation_style_assignment,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->styles, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to presentation_style_assignment to be a `SET [1:?] OF presentation_style_select`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<presentation_style_by_context>(const DB& db, const LIST& params, presentation_style_by_context* in)
{
	size_t base = GenericFill(db,params,static_cast<presentation_style_assignment*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to presentation_style_by_context"); }    do { // convert the 'style_context' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->style_context, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to presentation_style_by_context to be a `style_context_select`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<pressure_measure_with_unit>(const DB& db, const LIST& params, pressure_measure_with_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<measure_with_unit*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to pressure_measure_with_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<pressure_unit>(const DB& db, const LIST& params, pressure_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<derived_unit*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to pressure_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<procedural_representation>(const DB& db, const LIST& params, procedural_representation* in)
{
	size_t base = GenericFill(db,params,static_cast<representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to procedural_representation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<procedural_representation_sequence>(const DB& db, const LIST& params, procedural_representation_sequence* in)
{
	size_t base = GenericFill(db,params,static_cast<representation_item*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to procedural_representation_sequence"); }    do { // convert the 'elements' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->elements, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to procedural_representation_sequence to be a `LIST [1:?] OF representation_item`")); }
    } while(0);
    do { // convert the 'suppressed_items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->suppressed_items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to procedural_representation_sequence to be a `SET [0:?] OF representation_item`")); }
    } while(0);
    do { // convert the 'rationale' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->rationale, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to procedural_representation_sequence to be a `text`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<procedural_shape_representation>(const DB& db, const LIST& params, procedural_shape_representation* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<procedural_shape_representation_sequence>(const DB& db, const LIST& params, procedural_shape_representation_sequence* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<product_category>(const DB& db, const LIST& params, product_category* in)
{
	size_t base = 0;
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to product_category"); }    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::product_category,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to product_category to be a `label`")); }
    } while(0);
    do { // convert the 'description' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::product_category,2>::aux_is_derived[1]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->description, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to product_category to be a `text`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<product_class>(const DB& db, const LIST& params, product_class* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<product_concept_context>(const DB& db, const LIST& params, product_concept_context* in)
{
	size_t base = GenericFill(db,params,static_cast<application_context_element*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to product_concept_context"); }    do { // convert the 'market_segment_type' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->market_segment_type, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to product_concept_context to be a `label`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<product_concept_feature_category_usage>(const DB& db, const LIST& params, product_concept_feature_category_usage* in)
{
	size_t base = GenericFill(db,params,static_cast<group_assignment*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to product_concept_feature_category_usage"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to product_concept_feature_category_usage to be a `SET [1:?] OF category_usage_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<product_definition_element_relationship>(const DB& db, const LIST& params, product_definition_element_relationship* in)
{
	size_t base = GenericFill(db,params,static_cast<group*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to product_definition_element_relationship"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<product_definition_formation>(const DB& db, const LIST& params, product_definition_formation* in)
{
	size_t base = 0;
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to product_definition_formation"); }    do { // convert the 'id' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::product_definition_formation,3>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->id, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to product_definition_formation to be a `identifier`")); }
    } while(0);
    do { // convert the 'description' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::product_definition_formation,3>::aux_is_derived[1]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->description, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to product_definition_formation to be a `text`")); }
    } while(0);
    do { // convert the 'of_product' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::product_definition_formation,3>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->of_product, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to product_definition_formation to be a `product`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<product_definition_formation_with_specified_source>(const DB& db, const LIST& params, product_definition_formation_with_specified_source* in)
{
	size_t base = GenericFill(db,params,static_cast<product_definition_formation*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to product_definition_formation_with_specified_source"); }    do { // convert the 'make_or_buy' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->make_or_buy, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to product_definition_formation_with_specified_source to be a `source`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<product_definition_group_assignment>(const DB& db, const LIST& params, product_definition_group_assignment* in)
{
	size_t base = GenericFill(db,params,static_cast<group_assignment*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to product_definition_group_assignment"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to product_definition_group_assignment to be a `SET [1:1] OF product_definition_or_product_definition_relationship`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<product_definition_shape>(const DB& db, const LIST& params, product_definition_shape* in)
{
	size_t base = GenericFill(db,params,static_cast<property_definition*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to product_definition_shape"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<product_definition_with_associated_documents>(const DB& db, const LIST& params, product_definition_with_associated_documents* in)
{
	size_t base = GenericFill(db,params,static_cast<product_definition*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to product_definition_with_associated_documents"); }    do { // convert the 'documentation_ids' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->documentation_ids, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to product_definition_with_associated_documents to be a `SET [1:?] OF document`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<product_identification>(const DB& db, const LIST& params, product_identification* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<product_material_composition_relationship>(const DB& db, const LIST& params, product_material_composition_relationship* in)
{
	size_t base = GenericFill(db,params,static_cast<product_definition_relationship*>(in));
	if (params.GetSize() < 9) { throw STEP::TypeError("expected 9 arguments to product_material_composition_relationship"); }    do { // convert the 'class' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->class_, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to product_material_composition_relationship to be a `label`")); }
    } while(0);
    do { // convert the 'constituent_amount' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->constituent_amount, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to product_material_composition_relationship to be a `SET [1:?] OF characterized_product_composition_value`")); }
    } while(0);
    do { // convert the 'composition_basis' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->composition_basis, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to product_material_composition_relationship to be a `label`")); }
    } while(0);
    do { // convert the 'determination_method' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->determination_method, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 8 to product_material_composition_relationship to be a `text`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<product_related_product_category>(const DB& db, const LIST& params, product_related_product_category* in)
{
	size_t base = GenericFill(db,params,static_cast<product_category*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to product_related_product_category"); }    do { // convert the 'products' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->products, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to product_related_product_category to be a `SET [1:?] OF product`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<product_specification>(const DB& db, const LIST& params, product_specification* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<tolerance_zone_definition>(const DB& db, const LIST& params, tolerance_zone_definition* in)
{
	size_t base = 0;
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to tolerance_zone_definition"); }    do { // convert the 'zone' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::tolerance_zone_definition,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->zone, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to tolerance_zone_definition to be a `tolerance_zone`")); }
    } while(0);
    do { // convert the 'boundaries' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::tolerance_zone_definition,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->boundaries, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to tolerance_zone_definition to be a `SET [1:?] OF shape_aspect`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<projected_zone_definition>(const DB& db, const LIST& params, projected_zone_definition* in)
{
	size_t base = GenericFill(db,params,static_cast<tolerance_zone_definition*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to projected_zone_definition"); }    do { // convert the 'projection_end' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->projection_end, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to projected_zone_definition to be a `shape_aspect`")); }
    } while(0);
    do { // convert the 'projected_length' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->projected_length, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to projected_zone_definition to be a `measure_with_unit`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<projection_curve>(const DB& db, const LIST& params, projection_curve* in)
{
	size_t base = GenericFill(db,params,static_cast<annotation_curve_occurrence*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to projection_curve"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<promissory_usage_occurrence>(const DB& db, const LIST& params, promissory_usage_occurrence* in)
{
	size_t base = GenericFill(db,params,static_cast<assembly_component_usage*>(in));
	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to promissory_usage_occurrence"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<qualified_representation_item>(const DB& db, const LIST& params, qualified_representation_item* in)
{
	size_t base = GenericFill(db,params,static_cast<representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to qualified_representation_item"); }    do { // convert the 'qualifiers' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->qualifiers, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to qualified_representation_item to be a `SET [1:?] OF value_qualifier`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<qualitative_uncertainty>(const DB& db, const LIST& params, qualitative_uncertainty* in)
{
	size_t base = GenericFill(db,params,static_cast<uncertainty_qualifier*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to qualitative_uncertainty"); }    do { // convert the 'uncertainty_value' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->uncertainty_value, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to qualitative_uncertainty to be a `text`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<quantified_assembly_component_usage>(const DB& db, const LIST& params, quantified_assembly_component_usage* in)
{
	size_t base = GenericFill(db,params,static_cast<assembly_component_usage*>(in));
	if (params.GetSize() < 7) { throw STEP::TypeError("expected 7 arguments to quantified_assembly_component_usage"); }    do { // convert the 'quantity' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->quantity, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to quantified_assembly_component_usage to be a `measure_with_unit`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<quasi_uniform_curve>(const DB& db, const LIST& params, quasi_uniform_curve* in)
{
	size_t base = GenericFill(db,params,static_cast<b_spline_curve*>(in));
	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to quasi_uniform_curve"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<quasi_uniform_surface>(const DB& db, const LIST& params, quasi_uniform_surface* in)
{
	size_t base = GenericFill(db,params,static_cast<b_spline_surface*>(in));
	if (params.GetSize() < 7) { throw STEP::TypeError("expected 7 arguments to quasi_uniform_surface"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<radioactivity_measure_with_unit>(const DB& db, const LIST& params, radioactivity_measure_with_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<measure_with_unit*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to radioactivity_measure_with_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<radioactivity_unit>(const DB& db, const LIST& params, radioactivity_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<derived_unit*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to radioactivity_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<radius_dimension>(const DB& db, const LIST& params, radius_dimension* in)
{
	size_t base = GenericFill(db,params,static_cast<dimension_curve_directed_callout*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to radius_dimension"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<range_characteristic>(const DB& db, const LIST& params, range_characteristic* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<ratio_unit>(const DB& db, const LIST& params, ratio_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<named_unit*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to ratio_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<rational_b_spline_curve>(const DB& db, const LIST& params, rational_b_spline_curve* in)
{
	size_t base = GenericFill(db,params,static_cast<b_spline_curve*>(in));
	if (params.GetSize() < 7) { throw STEP::TypeError("expected 7 arguments to rational_b_spline_curve"); }    do { // convert the 'weights_data' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->weights_data, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to rational_b_spline_curve to be a `LIST [2:?] OF REAL`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<rational_b_spline_surface>(const DB& db, const LIST& params, rational_b_spline_surface* in)
{
	size_t base = GenericFill(db,params,static_cast<b_spline_surface*>(in));
	if (params.GetSize() < 7) { throw STEP::TypeError("expected 7 arguments to rational_b_spline_surface"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<rational_representation_item>(const DB& db, const LIST& params, rational_representation_item* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<real_literal>(const DB& db, const LIST& params, real_literal* in)
{
	size_t base = GenericFill(db,params,static_cast<literal_number*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to real_literal"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<real_representation_item>(const DB& db, const LIST& params, real_representation_item* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<rectangular_composite_surface>(const DB& db, const LIST& params, rectangular_composite_surface* in)
{
	size_t base = GenericFill(db,params,static_cast<bounded_surface*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to rectangular_composite_surface"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<rectangular_trimmed_surface>(const DB& db, const LIST& params, rectangular_trimmed_surface* in)
{
	size_t base = GenericFill(db,params,static_cast<bounded_surface*>(in));
	if (params.GetSize() < 8) { throw STEP::TypeError("expected 8 arguments to rectangular_trimmed_surface"); }    do { // convert the 'basis_surface' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->basis_surface, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to rectangular_trimmed_surface to be a `surface`")); }
    } while(0);
    do { // convert the 'u1' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->u1, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to rectangular_trimmed_surface to be a `parameter_value`")); }
    } while(0);
    do { // convert the 'u2' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->u2, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to rectangular_trimmed_surface to be a `parameter_value`")); }
    } while(0);
    do { // convert the 'v1' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->v1, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to rectangular_trimmed_surface to be a `parameter_value`")); }
    } while(0);
    do { // convert the 'v2' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->v2, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to rectangular_trimmed_surface to be a `parameter_value`")); }
    } while(0);
    do { // convert the 'usense' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->usense, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to rectangular_trimmed_surface to be a `BOOLEAN`")); }
    } while(0);
    do { // convert the 'vsense' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->vsense, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to rectangular_trimmed_surface to be a `BOOLEAN`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<referenced_modified_datum>(const DB& db, const LIST& params, referenced_modified_datum* in)
{
	size_t base = GenericFill(db,params,static_cast<datum_reference*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to referenced_modified_datum"); }    do { // convert the 'modifier' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->modifier, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to referenced_modified_datum to be a `limit_condition`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<relative_event_occurrence>(const DB& db, const LIST& params, relative_event_occurrence* in)
{
	size_t base = GenericFill(db,params,static_cast<event_occurrence*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to relative_event_occurrence"); }    do { // convert the 'base_event' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->base_event, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to relative_event_occurrence to be a `event_occurrence`")); }
    } while(0);
    do { // convert the 'offset' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->offset, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to relative_event_occurrence to be a `time_measure_with_unit`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<rep_item_group>(const DB& db, const LIST& params, rep_item_group* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<reparametrised_composite_curve_segment>(const DB& db, const LIST& params, reparametrised_composite_curve_segment* in)
{
	size_t base = GenericFill(db,params,static_cast<composite_curve_segment*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to reparametrised_composite_curve_segment"); }    do { // convert the 'param_length' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->param_length, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to reparametrised_composite_curve_segment to be a `parameter_value`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<representation_relationship_with_transformation>(const DB& db, const LIST& params, representation_relationship_with_transformation* in)
{
	size_t base = GenericFill(db,params,static_cast<representation_relationship*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to representation_relationship_with_transformation"); }    do { // convert the 'transformation_operator' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->transformation_operator, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to representation_relationship_with_transformation to be a `transformation`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<requirement_assigned_object>(const DB& db, const LIST& params, requirement_assigned_object* in)
{
	size_t base = GenericFill(db,params,static_cast<group_assignment*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to requirement_assigned_object"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to requirement_assigned_object to be a `SET [1:1] OF requirement_assigned_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<requirement_assignment>(const DB& db, const LIST& params, requirement_assignment* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<requirement_source>(const DB& db, const LIST& params, requirement_source* in)
{
	size_t base = GenericFill(db,params,static_cast<group*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to requirement_source"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<requirement_view_definition_relationship>(const DB& db, const LIST& params, requirement_view_definition_relationship* in)
{
	size_t base = GenericFill(db,params,static_cast<product_definition_relationship*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to requirement_view_definition_relationship"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<resistance_measure_with_unit>(const DB& db, const LIST& params, resistance_measure_with_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<measure_with_unit*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to resistance_measure_with_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<resistance_unit>(const DB& db, const LIST& params, resistance_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<derived_unit*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to resistance_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<revolved_area_solid>(const DB& db, const LIST& params, revolved_area_solid* in)
{
	size_t base = GenericFill(db,params,static_cast<swept_area_solid*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to revolved_area_solid"); }    do { // convert the 'axis' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->axis, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to revolved_area_solid to be a `axis1_placement`")); }
    } while(0);
    do { // convert the 'angle' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->angle, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to revolved_area_solid to be a `plane_angle_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<revolved_face_solid>(const DB& db, const LIST& params, revolved_face_solid* in)
{
	size_t base = GenericFill(db,params,static_cast<swept_face_solid*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to revolved_face_solid"); }    do { // convert the 'axis' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::revolved_face_solid,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->axis, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to revolved_face_solid to be a `axis1_placement`")); }
    } while(0);
    do { // convert the 'angle' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::revolved_face_solid,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->angle, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to revolved_face_solid to be a `plane_angle_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<revolved_face_solid_with_trim_conditions>(const DB& db, const LIST& params, revolved_face_solid_with_trim_conditions* in)
{
	size_t base = GenericFill(db,params,static_cast<revolved_face_solid*>(in));
	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to revolved_face_solid_with_trim_conditions"); }    do { // convert the 'first_trim_condition' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->first_trim_condition, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to revolved_face_solid_with_trim_conditions to be a `trim_condition_select`")); }
    } while(0);
    do { // convert the 'second_trim_condition' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->second_trim_condition, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to revolved_face_solid_with_trim_conditions to be a `trim_condition_select`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<right_angular_wedge>(const DB& db, const LIST& params, right_angular_wedge* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_representation_item*>(in));
	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to right_angular_wedge"); }    do { // convert the 'position' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->position, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to right_angular_wedge to be a `axis2_placement_3d`")); }
    } while(0);
    do { // convert the 'x' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->x, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to right_angular_wedge to be a `positive_length_measure`")); }
    } while(0);
    do { // convert the 'y' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->y, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to right_angular_wedge to be a `positive_length_measure`")); }
    } while(0);
    do { // convert the 'z' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->z, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to right_angular_wedge to be a `positive_length_measure`")); }
    } while(0);
    do { // convert the 'ltx' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->ltx, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to right_angular_wedge to be a `length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<right_circular_cone>(const DB& db, const LIST& params, right_circular_cone* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_representation_item*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to right_circular_cone"); }    do { // convert the 'position' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->position, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to right_circular_cone to be a `axis1_placement`")); }
    } while(0);
    do { // convert the 'height' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->height, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to right_circular_cone to be a `positive_length_measure`")); }
    } while(0);
    do { // convert the 'radius' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->radius, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to right_circular_cone to be a `length_measure`")); }
    } while(0);
    do { // convert the 'semi_angle' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->semi_angle, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to right_circular_cone to be a `plane_angle_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<right_circular_cylinder>(const DB& db, const LIST& params, right_circular_cylinder* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_representation_item*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to right_circular_cylinder"); }    do { // convert the 'position' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->position, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to right_circular_cylinder to be a `axis1_placement`")); }
    } while(0);
    do { // convert the 'height' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->height, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to right_circular_cylinder to be a `positive_length_measure`")); }
    } while(0);
    do { // convert the 'radius' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->radius, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to right_circular_cylinder to be a `positive_length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<right_to_usage_association>(const DB& db, const LIST& params, right_to_usage_association* in)
{
	size_t base = GenericFill(db,params,static_cast<action_method_relationship*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to right_to_usage_association"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<roundness_tolerance>(const DB& db, const LIST& params, roundness_tolerance* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_tolerance*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to roundness_tolerance"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<row_representation_item>(const DB& db, const LIST& params, row_representation_item* in)
{
	size_t base = GenericFill(db,params,static_cast<compound_representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to row_representation_item"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<row_value>(const DB& db, const LIST& params, row_value* in)
{
	size_t base = GenericFill(db,params,static_cast<compound_representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to row_value"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<row_variable>(const DB& db, const LIST& params, row_variable* in)
{
	size_t base = GenericFill(db,params,static_cast<abstract_variable*>(in));
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<rule_action>(const DB& db, const LIST& params, rule_action* in)
{
	size_t base = GenericFill(db,params,static_cast<action*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to rule_action"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<rule_condition>(const DB& db, const LIST& params, rule_condition* in)
{
	size_t base = GenericFill(db,params,static_cast<atomic_formula*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to rule_condition"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<rule_set>(const DB& db, const LIST& params, rule_set* in)
{
	size_t base = GenericFill(db,params,static_cast<rule_software_definition*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to rule_set"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<rule_set_group>(const DB& db, const LIST& params, rule_set_group* in)
{
	size_t base = GenericFill(db,params,static_cast<rule_software_definition*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to rule_set_group"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<rule_superseded_assignment>(const DB& db, const LIST& params, rule_superseded_assignment* in)
{
	size_t base = GenericFill(db,params,static_cast<action_assignment*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to rule_superseded_assignment"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to rule_superseded_assignment to be a `SET [1:?] OF rule_superseded_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<rule_supersedence>(const DB& db, const LIST& params, rule_supersedence* in)
{
	size_t base = GenericFill(db,params,static_cast<rule_action*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to rule_supersedence"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<surface_curve_swept_area_solid>(const DB& db, const LIST& params, surface_curve_swept_area_solid* in)
{
	size_t base = GenericFill(db,params,static_cast<swept_area_solid*>(in));
	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to surface_curve_swept_area_solid"); }    do { // convert the 'directrix' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::surface_curve_swept_area_solid,4>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->directrix, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to surface_curve_swept_area_solid to be a `curve`")); }
    } while(0);
    do { // convert the 'start_param' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::surface_curve_swept_area_solid,4>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->start_param, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to surface_curve_swept_area_solid to be a `REAL`")); }
    } while(0);
    do { // convert the 'end_param' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::surface_curve_swept_area_solid,4>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->end_param, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to surface_curve_swept_area_solid to be a `REAL`")); }
    } while(0);
    do { // convert the 'reference_surface' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::surface_curve_swept_area_solid,4>::aux_is_derived[3]=true; break; }
        try { GenericConvert( in->reference_surface, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to surface_curve_swept_area_solid to be a `surface`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<ruled_surface_swept_area_solid>(const DB& db, const LIST& params, ruled_surface_swept_area_solid* in)
{
	size_t base = GenericFill(db,params,static_cast<surface_curve_swept_area_solid*>(in));
	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to ruled_surface_swept_area_solid"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<runout_zone_definition>(const DB& db, const LIST& params, runout_zone_definition* in)
{
	size_t base = GenericFill(db,params,static_cast<tolerance_zone_definition*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to runout_zone_definition"); }    do { // convert the 'orientation' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->orientation, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to runout_zone_definition to be a `runout_zone_orientation`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<runout_zone_orientation>(const DB& db, const LIST& params, runout_zone_orientation* in)
{
	size_t base = 0;
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to runout_zone_orientation"); }    do { // convert the 'angle' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::runout_zone_orientation,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->angle, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to runout_zone_orientation to be a `measure_with_unit`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<runout_zone_orientation_reference_direction>(const DB& db, const LIST& params, runout_zone_orientation_reference_direction* in)
{
	size_t base = GenericFill(db,params,static_cast<runout_zone_orientation*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to runout_zone_orientation_reference_direction"); }    do { // convert the 'orientation_defining_relationship' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->orientation_defining_relationship, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to runout_zone_orientation_reference_direction to be a `shape_aspect_relationship`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<satisfied_requirement>(const DB& db, const LIST& params, satisfied_requirement* in)
{
	size_t base = GenericFill(db,params,static_cast<group_assignment*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to satisfied_requirement"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to satisfied_requirement to be a `SET [1:1] OF product_definition`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<satisfies_requirement>(const DB& db, const LIST& params, satisfies_requirement* in)
{
	size_t base = GenericFill(db,params,static_cast<group*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to satisfies_requirement"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<satisfying_item>(const DB& db, const LIST& params, satisfying_item* in)
{
	size_t base = GenericFill(db,params,static_cast<group_assignment*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to satisfying_item"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to satisfying_item to be a `SET [1:1] OF requirement_satisfaction_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<scalar_variable>(const DB& db, const LIST& params, scalar_variable* in)
{
	size_t base = GenericFill(db,params,static_cast<abstract_variable*>(in));
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<scattering_parameter>(const DB& db, const LIST& params, scattering_parameter* in)
{
	size_t base = GenericFill(db,params,static_cast<polar_complex_number_literal*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to scattering_parameter"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<sculptured_solid>(const DB& db, const LIST& params, sculptured_solid* in)
{
	size_t base = GenericFill(db,params,static_cast<modified_solid*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to sculptured_solid"); }    do { // convert the 'sculpturing_element' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->sculpturing_element, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to sculptured_solid to be a `generalized_surface_select`")); }
    } while(0);
    do { // convert the 'positive_side' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->positive_side, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to sculptured_solid to be a `BOOLEAN`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<seam_curve>(const DB& db, const LIST& params, seam_curve* in)
{
	size_t base = GenericFill(db,params,static_cast<surface_curve*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to seam_curve"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<serial_numbered_effectivity>(const DB& db, const LIST& params, serial_numbered_effectivity* in)
{
	size_t base = GenericFill(db,params,static_cast<effectivity*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to serial_numbered_effectivity"); }    do { // convert the 'effectivity_start_id' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->effectivity_start_id, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to serial_numbered_effectivity to be a `identifier`")); }
    } while(0);
    do { // convert the 'effectivity_end_id' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->effectivity_end_id, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to serial_numbered_effectivity to be a `identifier`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<shape_aspect_associativity>(const DB& db, const LIST& params, shape_aspect_associativity* in)
{
	size_t base = GenericFill(db,params,static_cast<shape_aspect_relationship*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to shape_aspect_associativity"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<shape_aspect_deriving_relationship>(const DB& db, const LIST& params, shape_aspect_deriving_relationship* in)
{
	size_t base = GenericFill(db,params,static_cast<shape_aspect_relationship*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to shape_aspect_deriving_relationship"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<shape_definition_representation>(const DB& db, const LIST& params, shape_definition_representation* in)
{
	size_t base = GenericFill(db,params,static_cast<property_definition_representation*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to shape_definition_representation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<shape_dimension_representation>(const DB& db, const LIST& params, shape_dimension_representation* in)
{
	size_t base = GenericFill(db,params,static_cast<shape_representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to shape_dimension_representation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<shape_feature_definition>(const DB& db, const LIST& params, shape_feature_definition* in)
{
	size_t base = GenericFill(db,params,static_cast<characterized_object*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to shape_feature_definition"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<shape_representation_with_parameters>(const DB& db, const LIST& params, shape_representation_with_parameters* in)
{
	size_t base = GenericFill(db,params,static_cast<shape_representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to shape_representation_with_parameters"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<shell_based_surface_model>(const DB& db, const LIST& params, shell_based_surface_model* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to shell_based_surface_model"); }    do { // convert the 'sbsm_boundary' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->sbsm_boundary, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to shell_based_surface_model to be a `SET [1:?] OF shell`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<shell_based_wireframe_model>(const DB& db, const LIST& params, shell_based_wireframe_model* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to shell_based_wireframe_model"); }    do { // convert the 'sbwm_boundary' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->sbwm_boundary, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to shell_based_wireframe_model to be a `SET [1:?] OF shell`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<shell_based_wireframe_shape_representation>(const DB& db, const LIST& params, shell_based_wireframe_shape_representation* in)
{
	size_t base = GenericFill(db,params,static_cast<shape_representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to shell_based_wireframe_shape_representation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<si_absorbed_dose_unit>(const DB& db, const LIST& params, si_absorbed_dose_unit* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<si_capacitance_unit>(const DB& db, const LIST& params, si_capacitance_unit* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<si_conductance_unit>(const DB& db, const LIST& params, si_conductance_unit* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<si_dose_equivalent_unit>(const DB& db, const LIST& params, si_dose_equivalent_unit* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<si_electric_charge_unit>(const DB& db, const LIST& params, si_electric_charge_unit* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<si_electric_potential_unit>(const DB& db, const LIST& params, si_electric_potential_unit* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<si_energy_unit>(const DB& db, const LIST& params, si_energy_unit* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<si_force_unit>(const DB& db, const LIST& params, si_force_unit* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<si_frequency_unit>(const DB& db, const LIST& params, si_frequency_unit* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<si_illuminance_unit>(const DB& db, const LIST& params, si_illuminance_unit* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<si_inductance_unit>(const DB& db, const LIST& params, si_inductance_unit* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<si_magnetic_flux_density_unit>(const DB& db, const LIST& params, si_magnetic_flux_density_unit* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<si_magnetic_flux_unit>(const DB& db, const LIST& params, si_magnetic_flux_unit* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<si_power_unit>(const DB& db, const LIST& params, si_power_unit* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<si_pressure_unit>(const DB& db, const LIST& params, si_pressure_unit* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<si_radioactivity_unit>(const DB& db, const LIST& params, si_radioactivity_unit* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<si_resistance_unit>(const DB& db, const LIST& params, si_resistance_unit* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<si_unit>(const DB& db, const LIST& params, si_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<named_unit*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to si_unit"); }    do { // convert the 'prefix' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->prefix, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to si_unit to be a `si_prefix`")); }
    } while(0);
    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to si_unit to be a `si_unit_name`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<simple_boolean_expression>(const DB& db, const LIST& params, simple_boolean_expression* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<simple_numeric_expression>(const DB& db, const LIST& params, simple_numeric_expression* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<slash_expression>(const DB& db, const LIST& params, slash_expression* in)
{
	size_t base = GenericFill(db,params,static_cast<binary_numeric_expression*>(in));
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<smeared_material_definition>(const DB& db, const LIST& params, smeared_material_definition* in)
{
	size_t base = GenericFill(db,params,static_cast<zone_structural_makeup*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to smeared_material_definition"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<solid_angle_measure_with_unit>(const DB& db, const LIST& params, solid_angle_measure_with_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<measure_with_unit*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to solid_angle_measure_with_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<solid_angle_unit>(const DB& db, const LIST& params, solid_angle_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<named_unit*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to solid_angle_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<solid_curve_font>(const DB& db, const LIST& params, solid_curve_font* in)
{
	size_t base = GenericFill(db,params,static_cast<pre_defined_curve_font*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to solid_curve_font"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<solid_replica>(const DB& db, const LIST& params, solid_replica* in)
{
	size_t base = GenericFill(db,params,static_cast<solid_model*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to solid_replica"); }    do { // convert the 'parent_solid' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->parent_solid, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to solid_replica to be a `solid_model`")); }
    } while(0);
    do { // convert the 'transformation' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->transformation, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to solid_replica to be a `cartesian_transformation_operator_3d`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<solid_with_chamfered_edges>(const DB& db, const LIST& params, solid_with_chamfered_edges* in)
{
	size_t base = GenericFill(db,params,static_cast<edge_blended_solid*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to solid_with_chamfered_edges"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<solid_with_angle_based_chamfer>(const DB& db, const LIST& params, solid_with_angle_based_chamfer* in)
{
	size_t base = GenericFill(db,params,static_cast<solid_with_chamfered_edges*>(in));
	if (params.GetSize() < 7) { throw STEP::TypeError("expected 7 arguments to solid_with_angle_based_chamfer"); }    do { // convert the 'offset_distance' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->offset_distance, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to solid_with_angle_based_chamfer to be a `positive_length_measure`")); }
    } while(0);
    do { // convert the 'left_offset' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->left_offset, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to solid_with_angle_based_chamfer to be a `BOOLEAN`")); }
    } while(0);
    do { // convert the 'offset_angle' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->offset_angle, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to solid_with_angle_based_chamfer to be a `positive_plane_angle_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<solid_with_shape_element_pattern>(const DB& db, const LIST& params, solid_with_shape_element_pattern* in)
{
	size_t base = GenericFill(db,params,static_cast<modified_solid_with_placed_configuration*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to solid_with_shape_element_pattern"); }    do { // convert the 'replicated_element' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::solid_with_shape_element_pattern,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->replicated_element, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to solid_with_shape_element_pattern to be a `modified_solid_with_placed_configuration`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<solid_with_circular_pattern>(const DB& db, const LIST& params, solid_with_circular_pattern* in)
{
	size_t base = GenericFill(db,params,static_cast<solid_with_shape_element_pattern*>(in));
	if (params.GetSize() < 9) { throw STEP::TypeError("expected 9 arguments to solid_with_circular_pattern"); }    do { // convert the 'replicate_count' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::solid_with_circular_pattern,4>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->replicate_count, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to solid_with_circular_pattern to be a `positive_integer`")); }
    } while(0);
    do { // convert the 'angular_spacing' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::solid_with_circular_pattern,4>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->angular_spacing, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to solid_with_circular_pattern to be a `plane_angle_measure`")); }
    } while(0);
    do { // convert the 'radial_alignment' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::solid_with_circular_pattern,4>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->radial_alignment, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to solid_with_circular_pattern to be a `BOOLEAN`")); }
    } while(0);
    do { // convert the 'reference_point' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::solid_with_circular_pattern,4>::aux_is_derived[3]=true; break; }
        try { GenericConvert( in->reference_point, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 8 to solid_with_circular_pattern to be a `point`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<solid_with_depression>(const DB& db, const LIST& params, solid_with_depression* in)
{
	size_t base = GenericFill(db,params,static_cast<modified_solid_with_placed_configuration*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to solid_with_depression"); }    do { // convert the 'depth' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::solid_with_depression,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->depth, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to solid_with_depression to be a `positive_length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<solid_with_pocket>(const DB& db, const LIST& params, solid_with_pocket* in)
{
	size_t base = GenericFill(db,params,static_cast<solid_with_depression*>(in));
	if (params.GetSize() < 7) { throw STEP::TypeError("expected 7 arguments to solid_with_pocket"); }    do { // convert the 'floor_blend_radius' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::solid_with_pocket,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->floor_blend_radius, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to solid_with_pocket to be a `non_negative_length_measure`")); }
    } while(0);
    do { // convert the 'draft_angle' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::solid_with_pocket,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->draft_angle, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to solid_with_pocket to be a `plane_angle_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<solid_with_circular_pocket>(const DB& db, const LIST& params, solid_with_circular_pocket* in)
{
	size_t base = GenericFill(db,params,static_cast<solid_with_pocket*>(in));
	if (params.GetSize() < 8) { throw STEP::TypeError("expected 8 arguments to solid_with_circular_pocket"); }    do { // convert the 'pocket_radius' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->pocket_radius, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to solid_with_circular_pocket to be a `positive_length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<solid_with_protrusion>(const DB& db, const LIST& params, solid_with_protrusion* in)
{
	size_t base = GenericFill(db,params,static_cast<modified_solid_with_placed_configuration*>(in));
	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to solid_with_protrusion"); }    do { // convert the 'protrusion_height' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::solid_with_protrusion,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->protrusion_height, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to solid_with_protrusion to be a `positive_length_measure`")); }
    } while(0);
    do { // convert the 'protrusion_draft_angle' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::solid_with_protrusion,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->protrusion_draft_angle, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to solid_with_protrusion to be a `plane_angle_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<solid_with_circular_protrusion>(const DB& db, const LIST& params, solid_with_circular_protrusion* in)
{
	size_t base = GenericFill(db,params,static_cast<solid_with_protrusion*>(in));
	if (params.GetSize() < 7) { throw STEP::TypeError("expected 7 arguments to solid_with_circular_protrusion"); }    do { // convert the 'protrusion_radius' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->protrusion_radius, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to solid_with_circular_protrusion to be a `positive_length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<solid_with_hole>(const DB& db, const LIST& params, solid_with_hole* in)
{
	size_t base = GenericFill(db,params,static_cast<solid_with_depression*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to solid_with_hole"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<solid_with_stepped_round_hole>(const DB& db, const LIST& params, solid_with_stepped_round_hole* in)
{
	size_t base = GenericFill(db,params,static_cast<solid_with_hole*>(in));
	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to solid_with_stepped_round_hole"); }    do { // convert the 'segments' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::solid_with_stepped_round_hole,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->segments, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to solid_with_stepped_round_hole to be a `positive_integer`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<solid_with_conical_bottom_round_hole>(const DB& db, const LIST& params, solid_with_conical_bottom_round_hole* in)
{
	size_t base = GenericFill(db,params,static_cast<solid_with_stepped_round_hole*>(in));
	if (params.GetSize() < 8) { throw STEP::TypeError("expected 8 arguments to solid_with_conical_bottom_round_hole"); }    do { // convert the 'semi_apex_angle' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->semi_apex_angle, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to solid_with_conical_bottom_round_hole to be a `positive_plane_angle_measure`")); }
    } while(0);
    do { // convert the 'tip_radius' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->tip_radius, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to solid_with_conical_bottom_round_hole to be a `non_negative_length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<solid_with_constant_radius_edge_blend>(const DB& db, const LIST& params, solid_with_constant_radius_edge_blend* in)
{
	size_t base = GenericFill(db,params,static_cast<edge_blended_solid*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to solid_with_constant_radius_edge_blend"); }    do { // convert the 'radius' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->radius, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to solid_with_constant_radius_edge_blend to be a `positive_length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<solid_with_slot>(const DB& db, const LIST& params, solid_with_slot* in)
{
	size_t base = GenericFill(db,params,static_cast<solid_with_depression*>(in));
	if (params.GetSize() < 7) { throw STEP::TypeError("expected 7 arguments to solid_with_slot"); }    do { // convert the 'slot_width' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::solid_with_slot,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->slot_width, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to solid_with_slot to be a `positive_length_measure`")); }
    } while(0);
    do { // convert the 'closed_ends' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::solid_with_slot,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->closed_ends, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to solid_with_slot to be a `LIST [2:2] OF LOGICAL`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<solid_with_curved_slot>(const DB& db, const LIST& params, solid_with_curved_slot* in)
{
	size_t base = GenericFill(db,params,static_cast<solid_with_slot*>(in));
	if (params.GetSize() < 8) { throw STEP::TypeError("expected 8 arguments to solid_with_curved_slot"); }    do { // convert the 'slot_centreline' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->slot_centreline, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to solid_with_curved_slot to be a `bounded_curve`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<solid_with_double_offset_chamfer>(const DB& db, const LIST& params, solid_with_double_offset_chamfer* in)
{
	size_t base = GenericFill(db,params,static_cast<solid_with_chamfered_edges*>(in));
	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to solid_with_double_offset_chamfer"); }    do { // convert the 'left_offset_distance' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->left_offset_distance, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to solid_with_double_offset_chamfer to be a `positive_length_measure`")); }
    } while(0);
    do { // convert the 'right_offset_distance' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->right_offset_distance, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to solid_with_double_offset_chamfer to be a `positive_length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<solid_with_flat_bottom_round_hole>(const DB& db, const LIST& params, solid_with_flat_bottom_round_hole* in)
{
	size_t base = GenericFill(db,params,static_cast<solid_with_stepped_round_hole*>(in));
	if (params.GetSize() < 7) { throw STEP::TypeError("expected 7 arguments to solid_with_flat_bottom_round_hole"); }    do { // convert the 'fillet_radius' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->fillet_radius, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to solid_with_flat_bottom_round_hole to be a `non_negative_length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<solid_with_general_pocket>(const DB& db, const LIST& params, solid_with_general_pocket* in)
{
	size_t base = GenericFill(db,params,static_cast<solid_with_pocket*>(in));
	if (params.GetSize() < 9) { throw STEP::TypeError("expected 9 arguments to solid_with_general_pocket"); }    do { // convert the 'profile' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->profile, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to solid_with_general_pocket to be a `positioned_sketch`")); }
    } while(0);
    do { // convert the 'reference_point' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->reference_point, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 8 to solid_with_general_pocket to be a `point`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<solid_with_general_protrusion>(const DB& db, const LIST& params, solid_with_general_protrusion* in)
{
	size_t base = GenericFill(db,params,static_cast<solid_with_protrusion*>(in));
	if (params.GetSize() < 8) { throw STEP::TypeError("expected 8 arguments to solid_with_general_protrusion"); }    do { // convert the 'profile' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->profile, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to solid_with_general_protrusion to be a `positioned_sketch`")); }
    } while(0);
    do { // convert the 'reference_point' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->reference_point, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to solid_with_general_protrusion to be a `point`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<solid_with_groove>(const DB& db, const LIST& params, solid_with_groove* in)
{
	size_t base = GenericFill(db,params,static_cast<solid_with_depression*>(in));
	if (params.GetSize() < 10) { throw STEP::TypeError("expected 10 arguments to solid_with_groove"); }    do { // convert the 'groove_radius' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->groove_radius, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to solid_with_groove to be a `positive_length_measure`")); }
    } while(0);
    do { // convert the 'groove_width' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->groove_width, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to solid_with_groove to be a `positive_length_measure`")); }
    } while(0);
    do { // convert the 'draft_angle' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->draft_angle, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to solid_with_groove to be a `plane_angle_measure`")); }
    } while(0);
    do { // convert the 'floor_fillet_radius' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->floor_fillet_radius, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 8 to solid_with_groove to be a `non_negative_length_measure`")); }
    } while(0);
    do { // convert the 'external_groove' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->external_groove, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 9 to solid_with_groove to be a `BOOLEAN`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<solid_with_incomplete_circular_pattern>(const DB& db, const LIST& params, solid_with_incomplete_circular_pattern* in)
{
	size_t base = GenericFill(db,params,static_cast<solid_with_circular_pattern*>(in));
	if (params.GetSize() < 10) { throw STEP::TypeError("expected 10 arguments to solid_with_incomplete_circular_pattern"); }    do { // convert the 'omitted_instances' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->omitted_instances, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 9 to solid_with_incomplete_circular_pattern to be a `SET [1:?] OF positive_integer`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<solid_with_rectangular_pattern>(const DB& db, const LIST& params, solid_with_rectangular_pattern* in)
{
	size_t base = GenericFill(db,params,static_cast<solid_with_shape_element_pattern*>(in));
	if (params.GetSize() < 9) { throw STEP::TypeError("expected 9 arguments to solid_with_rectangular_pattern"); }    do { // convert the 'row_count' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::solid_with_rectangular_pattern,4>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->row_count, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to solid_with_rectangular_pattern to be a `positive_integer`")); }
    } while(0);
    do { // convert the 'column_count' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::solid_with_rectangular_pattern,4>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->column_count, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to solid_with_rectangular_pattern to be a `positive_integer`")); }
    } while(0);
    do { // convert the 'row_spacing' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::solid_with_rectangular_pattern,4>::aux_is_derived[2]=true; break; }
        try { GenericConvert( in->row_spacing, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to solid_with_rectangular_pattern to be a `length_measure`")); }
    } while(0);
    do { // convert the 'column_spacing' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::solid_with_rectangular_pattern,4>::aux_is_derived[3]=true; break; }
        try { GenericConvert( in->column_spacing, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 8 to solid_with_rectangular_pattern to be a `length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<solid_with_incomplete_rectangular_pattern>(const DB& db, const LIST& params, solid_with_incomplete_rectangular_pattern* in)
{
	size_t base = GenericFill(db,params,static_cast<solid_with_rectangular_pattern*>(in));
	if (params.GetSize() < 9) { throw STEP::TypeError("expected 9 arguments to solid_with_incomplete_rectangular_pattern"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<solid_with_rectangular_pocket>(const DB& db, const LIST& params, solid_with_rectangular_pocket* in)
{
	size_t base = GenericFill(db,params,static_cast<solid_with_pocket*>(in));
	if (params.GetSize() < 10) { throw STEP::TypeError("expected 10 arguments to solid_with_rectangular_pocket"); }    do { // convert the 'pocket_length' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->pocket_length, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to solid_with_rectangular_pocket to be a `positive_length_measure`")); }
    } while(0);
    do { // convert the 'pocket_width' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->pocket_width, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 8 to solid_with_rectangular_pocket to be a `positive_length_measure`")); }
    } while(0);
    do { // convert the 'corner_radius' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->corner_radius, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 9 to solid_with_rectangular_pocket to be a `non_negative_length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<solid_with_rectangular_protrusion>(const DB& db, const LIST& params, solid_with_rectangular_protrusion* in)
{
	size_t base = GenericFill(db,params,static_cast<solid_with_protrusion*>(in));
	if (params.GetSize() < 9) { throw STEP::TypeError("expected 9 arguments to solid_with_rectangular_protrusion"); }    do { // convert the 'protrusion_length' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->protrusion_length, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to solid_with_rectangular_protrusion to be a `positive_length_measure`")); }
    } while(0);
    do { // convert the 'protrusion_width' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->protrusion_width, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to solid_with_rectangular_protrusion to be a `positive_length_measure`")); }
    } while(0);
    do { // convert the 'protrusion_corner_radius' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->protrusion_corner_radius, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 8 to solid_with_rectangular_protrusion to be a `non_negative_length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<solid_with_single_offset_chamfer>(const DB& db, const LIST& params, solid_with_single_offset_chamfer* in)
{
	size_t base = GenericFill(db,params,static_cast<solid_with_chamfered_edges*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to solid_with_single_offset_chamfer"); }    do { // convert the 'offset_distance' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->offset_distance, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to solid_with_single_offset_chamfer to be a `positive_length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<solid_with_spherical_bottom_round_hole>(const DB& db, const LIST& params, solid_with_spherical_bottom_round_hole* in)
{
	size_t base = GenericFill(db,params,static_cast<solid_with_stepped_round_hole*>(in));
	if (params.GetSize() < 7) { throw STEP::TypeError("expected 7 arguments to solid_with_spherical_bottom_round_hole"); }    do { // convert the 'sphere_radius' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->sphere_radius, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to solid_with_spherical_bottom_round_hole to be a `positive_length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<solid_with_stepped_round_hole_and_conical_transitions>(const DB& db, const LIST& params, solid_with_stepped_round_hole_and_conical_transitions* in)
{
	size_t base = GenericFill(db,params,static_cast<solid_with_stepped_round_hole*>(in));
	if (params.GetSize() < 7) { throw STEP::TypeError("expected 7 arguments to solid_with_stepped_round_hole_and_conical_transitions"); }    do { // convert the 'conical_transitions' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->conical_transitions, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to solid_with_stepped_round_hole_and_conical_transitions to be a `SET [1:?] OF conical_stepped_hole_transition`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<solid_with_straight_slot>(const DB& db, const LIST& params, solid_with_straight_slot* in)
{
	size_t base = GenericFill(db,params,static_cast<solid_with_slot*>(in));
	if (params.GetSize() < 8) { throw STEP::TypeError("expected 8 arguments to solid_with_straight_slot"); }    do { // convert the 'slot_length' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->slot_length, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to solid_with_straight_slot to be a `positive_length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<solid_with_tee_section_slot>(const DB& db, const LIST& params, solid_with_tee_section_slot* in)
{
	size_t base = GenericFill(db,params,static_cast<solid_with_slot*>(in));
	if (params.GetSize() < 9) { throw STEP::TypeError("expected 9 arguments to solid_with_tee_section_slot"); }    do { // convert the 'tee_section_width' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->tee_section_width, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to solid_with_tee_section_slot to be a `positive_length_measure`")); }
    } while(0);
    do { // convert the 'collar_depth' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->collar_depth, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 8 to solid_with_tee_section_slot to be a `positive_length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<solid_with_through_depression>(const DB& db, const LIST& params, solid_with_through_depression* in)
{
	size_t base = GenericFill(db,params,static_cast<solid_with_depression*>(in));
	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to solid_with_through_depression"); }    do { // convert the 'exit_faces' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->exit_faces, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to solid_with_through_depression to be a `SET [1:?] OF face_surface`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<solid_with_trapezoidal_section_slot>(const DB& db, const LIST& params, solid_with_trapezoidal_section_slot* in)
{
	size_t base = GenericFill(db,params,static_cast<solid_with_slot*>(in));
	if (params.GetSize() < 9) { throw STEP::TypeError("expected 9 arguments to solid_with_trapezoidal_section_slot"); }    do { // convert the 'draft_angle' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->draft_angle, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to solid_with_trapezoidal_section_slot to be a `plane_angle_measure`")); }
    } while(0);
    do { // convert the 'floor_fillet_radius' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->floor_fillet_radius, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 8 to solid_with_trapezoidal_section_slot to be a `non_negative_length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<solid_with_variable_radius_edge_blend>(const DB& db, const LIST& params, solid_with_variable_radius_edge_blend* in)
{
	size_t base = 0;
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to solid_with_variable_radius_edge_blend"); }    do { // convert the 'point_list' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->point_list, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to solid_with_variable_radius_edge_blend to be a `LIST [2:?] OF point`")); }
    } while(0);
    do { // convert the 'radius_list' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->radius_list, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to solid_with_variable_radius_edge_blend to be a `LIST [2:?] OF positive_length_measure`")); }
    } while(0);
    do { // convert the 'edge_function_list' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->edge_function_list, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to solid_with_variable_radius_edge_blend to be a `LIST [1:?] OF blend_radius_variation_type`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<source_for_requirement>(const DB& db, const LIST& params, source_for_requirement* in)
{
	size_t base = GenericFill(db,params,static_cast<group_assignment*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to source_for_requirement"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to source_for_requirement to be a `SET [1:1] OF requirement_source_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<sourced_requirement>(const DB& db, const LIST& params, sourced_requirement* in)
{
	size_t base = GenericFill(db,params,static_cast<group_assignment*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to sourced_requirement"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to sourced_requirement to be a `SET [1:1] OF product_definition`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<specification_definition>(const DB& db, const LIST& params, specification_definition* in)
{
	size_t base = GenericFill(db,params,static_cast<product_definition*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to specification_definition"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<specified_higher_usage_occurrence>(const DB& db, const LIST& params, specified_higher_usage_occurrence* in)
{
	size_t base = GenericFill(db,params,static_cast<assembly_component_usage*>(in));
	if (params.GetSize() < 8) { throw STEP::TypeError("expected 8 arguments to specified_higher_usage_occurrence"); }    do { // convert the 'upper_usage' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->upper_usage, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to specified_higher_usage_occurrence to be a `assembly_component_usage`")); }
    } while(0);
    do { // convert the 'next_usage' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->next_usage, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to specified_higher_usage_occurrence to be a `next_assembly_usage_occurrence`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<sphere>(const DB& db, const LIST& params, sphere* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_representation_item*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to sphere"); }    do { // convert the 'radius' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->radius, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to sphere to be a `positive_length_measure`")); }
    } while(0);
    do { // convert the 'centre' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->centre, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to sphere to be a `point`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<spherical_surface>(const DB& db, const LIST& params, spherical_surface* in)
{
	size_t base = GenericFill(db,params,static_cast<elementary_surface*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to spherical_surface"); }    do { // convert the 'radius' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->radius, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to spherical_surface to be a `positive_length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<start_request>(const DB& db, const LIST& params, start_request* in)
{
	size_t base = GenericFill(db,params,static_cast<action_request_assignment*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to start_request"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to start_request to be a `SET [1:?] OF start_request_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<start_work>(const DB& db, const LIST& params, start_work* in)
{
	size_t base = GenericFill(db,params,static_cast<action_assignment*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to start_work"); }    do { // convert the 'items' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->items, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to start_work to be a `SET [1:?] OF work_item`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<straightness_tolerance>(const DB& db, const LIST& params, straightness_tolerance* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_tolerance*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to straightness_tolerance"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<structured_dimension_callout>(const DB& db, const LIST& params, structured_dimension_callout* in)
{
	size_t base = GenericFill(db,params,static_cast<draughting_callout*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to structured_dimension_callout"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<structured_text_composition>(const DB& db, const LIST& params, structured_text_composition* in)
{
	size_t base = GenericFill(db,params,static_cast<compound_representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to structured_text_composition"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<structured_text_representation>(const DB& db, const LIST& params, structured_text_representation* in)
{
	size_t base = GenericFill(db,params,static_cast<representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to structured_text_representation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<subedge>(const DB& db, const LIST& params, subedge* in)
{
	size_t base = GenericFill(db,params,static_cast<edge*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to subedge"); }    do { // convert the 'parent_edge' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->parent_edge, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to subedge to be a `edge`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<subface>(const DB& db, const LIST& params, subface* in)
{
	size_t base = GenericFill(db,params,static_cast<face*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to subface"); }    do { // convert the 'parent_face' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->parent_face, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to subface to be a `face`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<supplied_part_relationship>(const DB& db, const LIST& params, supplied_part_relationship* in)
{
	size_t base = GenericFill(db,params,static_cast<product_definition_relationship*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to supplied_part_relationship"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<surface_condition_callout>(const DB& db, const LIST& params, surface_condition_callout* in)
{
	size_t base = GenericFill(db,params,static_cast<draughting_callout*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to surface_condition_callout"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<swept_surface>(const DB& db, const LIST& params, swept_surface* in)
{
	size_t base = GenericFill(db,params,static_cast<surface*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to swept_surface"); }    do { // convert the 'swept_curve' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::swept_surface,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->swept_curve, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to swept_surface to be a `curve`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<surface_of_linear_extrusion>(const DB& db, const LIST& params, surface_of_linear_extrusion* in)
{
	size_t base = GenericFill(db,params,static_cast<swept_surface*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to surface_of_linear_extrusion"); }    do { // convert the 'extrusion_axis' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->extrusion_axis, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to surface_of_linear_extrusion to be a `vector`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<surface_of_revolution>(const DB& db, const LIST& params, surface_of_revolution* in)
{
	size_t base = GenericFill(db,params,static_cast<swept_surface*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to surface_of_revolution"); }    do { // convert the 'axis_position' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->axis_position, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to surface_of_revolution to be a `axis1_placement`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<surface_patch>(const DB& db, const LIST& params, surface_patch* in)
{
	size_t base = GenericFill(db,params,static_cast<founded_item*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to surface_patch"); }    do { // convert the 'parent_surface' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->parent_surface, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to surface_patch to be a `bounded_surface`")); }
    } while(0);
    do { // convert the 'u_transition' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->u_transition, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to surface_patch to be a `transition_code`")); }
    } while(0);
    do { // convert the 'v_transition' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->v_transition, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to surface_patch to be a `transition_code`")); }
    } while(0);
    do { // convert the 'u_sense' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->u_sense, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to surface_patch to be a `BOOLEAN`")); }
    } while(0);
    do { // convert the 'v_sense' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->v_sense, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to surface_patch to be a `BOOLEAN`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<surface_profile_tolerance>(const DB& db, const LIST& params, surface_profile_tolerance* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_tolerance*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to surface_profile_tolerance"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<surface_replica>(const DB& db, const LIST& params, surface_replica* in)
{
	size_t base = GenericFill(db,params,static_cast<surface*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to surface_replica"); }    do { // convert the 'parent_surface' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->parent_surface, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to surface_replica to be a `surface`")); }
    } while(0);
    do { // convert the 'transformation' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->transformation, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to surface_replica to be a `cartesian_transformation_operator_3d`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<surface_side_style>(const DB& db, const LIST& params, surface_side_style* in)
{
	size_t base = GenericFill(db,params,static_cast<founded_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to surface_side_style"); }    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to surface_side_style to be a `label`")); }
    } while(0);
    do { // convert the 'styles' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->styles, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to surface_side_style to be a `SET [1:7] OF surface_style_element_select`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<surface_style_boundary>(const DB& db, const LIST& params, surface_style_boundary* in)
{
	size_t base = GenericFill(db,params,static_cast<founded_item*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to surface_style_boundary"); }    do { // convert the 'style_of_boundary' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->style_of_boundary, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to surface_style_boundary to be a `curve_or_render`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<surface_style_control_grid>(const DB& db, const LIST& params, surface_style_control_grid* in)
{
	size_t base = GenericFill(db,params,static_cast<founded_item*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to surface_style_control_grid"); }    do { // convert the 'style_of_control_grid' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->style_of_control_grid, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to surface_style_control_grid to be a `curve_or_render`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<surface_style_fill_area>(const DB& db, const LIST& params, surface_style_fill_area* in)
{
	size_t base = GenericFill(db,params,static_cast<founded_item*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to surface_style_fill_area"); }    do { // convert the 'fill_area' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->fill_area, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to surface_style_fill_area to be a `fill_area_style`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<surface_style_parameter_line>(const DB& db, const LIST& params, surface_style_parameter_line* in)
{
	size_t base = GenericFill(db,params,static_cast<founded_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to surface_style_parameter_line"); }    do { // convert the 'style_of_parameter_lines' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->style_of_parameter_lines, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to surface_style_parameter_line to be a `curve_or_render`")); }
    } while(0);
    do { // convert the 'direction_counts' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->direction_counts, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to surface_style_parameter_line to be a `SET [1:2] OF direction_count_select`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<surface_style_reflectance_ambient>(const DB& db, const LIST& params, surface_style_reflectance_ambient* in)
{
	size_t base = 0;
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to surface_style_reflectance_ambient"); }    do { // convert the 'ambient_reflectance' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::surface_style_reflectance_ambient,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->ambient_reflectance, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to surface_style_reflectance_ambient to be a `REAL`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<surface_style_reflectance_ambient_diffuse>(const DB& db, const LIST& params, surface_style_reflectance_ambient_diffuse* in)
{
	size_t base = GenericFill(db,params,static_cast<surface_style_reflectance_ambient*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to surface_style_reflectance_ambient_diffuse"); }    do { // convert the 'diffuse_reflectance' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::surface_style_reflectance_ambient_diffuse,1>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->diffuse_reflectance, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to surface_style_reflectance_ambient_diffuse to be a `REAL`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<surface_style_reflectance_ambient_diffuse_specular>(const DB& db, const LIST& params, surface_style_reflectance_ambient_diffuse_specular* in)
{
	size_t base = GenericFill(db,params,static_cast<surface_style_reflectance_ambient_diffuse*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to surface_style_reflectance_ambient_diffuse_specular"); }    do { // convert the 'specular_reflectance' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->specular_reflectance, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to surface_style_reflectance_ambient_diffuse_specular to be a `REAL`")); }
    } while(0);
    do { // convert the 'specular_exponent' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->specular_exponent, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to surface_style_reflectance_ambient_diffuse_specular to be a `REAL`")); }
    } while(0);
    do { // convert the 'specular_colour' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->specular_colour, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to surface_style_reflectance_ambient_diffuse_specular to be a `colour`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<surface_style_rendering>(const DB& db, const LIST& params, surface_style_rendering* in)
{
	size_t base = 0;
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to surface_style_rendering"); }    do { // convert the 'rendering_method' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::surface_style_rendering,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->rendering_method, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to surface_style_rendering to be a `shading_surface_method`")); }
    } while(0);
    do { // convert the 'surface_colour' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::surface_style_rendering,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->surface_colour, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to surface_style_rendering to be a `colour`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<surface_style_rendering_with_properties>(const DB& db, const LIST& params, surface_style_rendering_with_properties* in)
{
	size_t base = GenericFill(db,params,static_cast<surface_style_rendering*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to surface_style_rendering_with_properties"); }    do { // convert the 'properties' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->properties, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to surface_style_rendering_with_properties to be a `SET [1:2] OF rendering_properties_select`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<surface_style_segmentation_curve>(const DB& db, const LIST& params, surface_style_segmentation_curve* in)
{
	size_t base = GenericFill(db,params,static_cast<founded_item*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to surface_style_segmentation_curve"); }    do { // convert the 'style_of_segmentation_curve' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->style_of_segmentation_curve, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to surface_style_segmentation_curve to be a `curve_or_render`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<surface_style_silhouette>(const DB& db, const LIST& params, surface_style_silhouette* in)
{
	size_t base = GenericFill(db,params,static_cast<founded_item*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to surface_style_silhouette"); }    do { // convert the 'style_of_silhouette' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->style_of_silhouette, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to surface_style_silhouette to be a `curve_or_render`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<surface_style_usage>(const DB& db, const LIST& params, surface_style_usage* in)
{
	size_t base = GenericFill(db,params,static_cast<founded_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to surface_style_usage"); }    do { // convert the 'side' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->side, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to surface_style_usage to be a `surface_side`")); }
    } while(0);
    do { // convert the 'style' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->style, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to surface_style_usage to be a `surface_side_style_select`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<surface_texture_representation>(const DB& db, const LIST& params, surface_texture_representation* in)
{
	size_t base = GenericFill(db,params,static_cast<representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to surface_texture_representation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<surfaced_open_shell>(const DB& db, const LIST& params, surfaced_open_shell* in)
{
	size_t base = GenericFill(db,params,static_cast<open_shell*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to surfaced_open_shell"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<swept_disk_solid>(const DB& db, const LIST& params, swept_disk_solid* in)
{
	size_t base = GenericFill(db,params,static_cast<solid_model*>(in));
	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to swept_disk_solid"); }    do { // convert the 'directrix' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->directrix, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to swept_disk_solid to be a `curve`")); }
    } while(0);
    do { // convert the 'radius' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->radius, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to swept_disk_solid to be a `positive_length_measure`")); }
    } while(0);
    do { // convert the 'inner_radius' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->inner_radius, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to swept_disk_solid to be a `positive_length_measure`")); }
    } while(0);
    do { // convert the 'start_param' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->start_param, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to swept_disk_solid to be a `REAL`")); }
    } while(0);
    do { // convert the 'end_param' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->end_param, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to swept_disk_solid to be a `REAL`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<symbol>(const DB& db, const LIST& params, symbol* in)
{
	size_t base = GenericFill(db,params,static_cast<representation_item*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to symbol"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<symbol_representation_map>(const DB& db, const LIST& params, symbol_representation_map* in)
{
	size_t base = GenericFill(db,params,static_cast<representation_map*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to symbol_representation_map"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<symbol_style>(const DB& db, const LIST& params, symbol_style* in)
{
	size_t base = GenericFill(db,params,static_cast<founded_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to symbol_style"); }    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to symbol_style to be a `label`")); }
    } while(0);
    do { // convert the 'style_of_symbol' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->style_of_symbol, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to symbol_style to be a `symbol_style_select`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<symbol_target>(const DB& db, const LIST& params, symbol_target* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_representation_item*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to symbol_target"); }    do { // convert the 'placement' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->placement, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to symbol_target to be a `axis2_placement`")); }
    } while(0);
    do { // convert the 'x_scale' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->x_scale, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to symbol_target to be a `positive_ratio_measure`")); }
    } while(0);
    do { // convert the 'y_scale' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->y_scale, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to symbol_target to be a `positive_ratio_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<symmetric_shape_aspect>(const DB& db, const LIST& params, symmetric_shape_aspect* in)
{
	size_t base = GenericFill(db,params,static_cast<shape_aspect*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to symmetric_shape_aspect"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<symmetry_tolerance>(const DB& db, const LIST& params, symmetry_tolerance* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_tolerance_with_datum_reference*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to symmetry_tolerance"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<table_representation_item>(const DB& db, const LIST& params, table_representation_item* in)
{
	size_t base = GenericFill(db,params,static_cast<compound_representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to table_representation_item"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<tactile_appearance_representation>(const DB& db, const LIST& params, tactile_appearance_representation* in)
{
	size_t base = GenericFill(db,params,static_cast<representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to tactile_appearance_representation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<tagged_text_format>(const DB& db, const LIST& params, tagged_text_format* in)
{
	size_t base = GenericFill(db,params,static_cast<representation_context*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to tagged_text_format"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<tagged_text_item>(const DB& db, const LIST& params, tagged_text_item* in)
{
	size_t base = GenericFill(db,params,static_cast<descriptive_representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to tagged_text_item"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<tangent>(const DB& db, const LIST& params, tangent* in)
{
	size_t base = GenericFill(db,params,static_cast<derived_shape_aspect*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to tangent"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<text_literal_with_associated_curves>(const DB& db, const LIST& params, text_literal_with_associated_curves* in)
{
	size_t base = GenericFill(db,params,static_cast<text_literal*>(in));
	if (params.GetSize() < 7) { throw STEP::TypeError("expected 7 arguments to text_literal_with_associated_curves"); }    do { // convert the 'associated_curves' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->associated_curves, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to text_literal_with_associated_curves to be a `SET [1:?] OF curve`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<text_literal_with_blanking_box>(const DB& db, const LIST& params, text_literal_with_blanking_box* in)
{
	size_t base = GenericFill(db,params,static_cast<text_literal*>(in));
	if (params.GetSize() < 7) { throw STEP::TypeError("expected 7 arguments to text_literal_with_blanking_box"); }    do { // convert the 'blanking' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->blanking, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to text_literal_with_blanking_box to be a `planar_box`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<text_literal_with_extent>(const DB& db, const LIST& params, text_literal_with_extent* in)
{
	size_t base = GenericFill(db,params,static_cast<text_literal*>(in));
	if (params.GetSize() < 7) { throw STEP::TypeError("expected 7 arguments to text_literal_with_extent"); }    do { // convert the 'extent' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->extent, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to text_literal_with_extent to be a `planar_extent`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<text_string_representation>(const DB& db, const LIST& params, text_string_representation* in)
{
	size_t base = GenericFill(db,params,static_cast<representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to text_string_representation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<text_style>(const DB& db, const LIST& params, text_style* in)
{
	size_t base = GenericFill(db,params,static_cast<founded_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to text_style"); }    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::text_style,2>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to text_style to be a `label`")); }
    } while(0);
    do { // convert the 'character_appearance' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::text_style,2>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->character_appearance, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to text_style to be a `character_style_select`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<text_style_with_box_characteristics>(const DB& db, const LIST& params, text_style_with_box_characteristics* in)
{
	size_t base = GenericFill(db,params,static_cast<text_style*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to text_style_with_box_characteristics"); }    do { // convert the 'characteristics' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->characteristics, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to text_style_with_box_characteristics to be a `SET [1:4] OF box_characteristic_select`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<text_style_with_mirror>(const DB& db, const LIST& params, text_style_with_mirror* in)
{
	size_t base = GenericFill(db,params,static_cast<text_style*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to text_style_with_mirror"); }    do { // convert the 'mirror_placement' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->mirror_placement, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to text_style_with_mirror to be a `axis2_placement`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<text_style_with_spacing>(const DB& db, const LIST& params, text_style_with_spacing* in)
{
	size_t base = GenericFill(db,params,static_cast<text_style*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to text_style_with_spacing"); }    do { // convert the 'character_spacing' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->character_spacing, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to text_style_with_spacing to be a `character_spacing_select`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<thermal_resistance_measure_with_unit>(const DB& db, const LIST& params, thermal_resistance_measure_with_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<measure_with_unit*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to thermal_resistance_measure_with_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<thermal_resistance_unit>(const DB& db, const LIST& params, thermal_resistance_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<derived_unit*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to thermal_resistance_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<thermodynamic_temperature_measure_with_unit>(const DB& db, const LIST& params, thermodynamic_temperature_measure_with_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<measure_with_unit*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to thermodynamic_temperature_measure_with_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<thermodynamic_temperature_unit>(const DB& db, const LIST& params, thermodynamic_temperature_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<named_unit*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to thermodynamic_temperature_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<thickened_face_solid>(const DB& db, const LIST& params, thickened_face_solid* in)
{
	size_t base = GenericFill(db,params,static_cast<solid_model*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to thickened_face_solid"); }    do { // convert the 'base_element' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->base_element, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to thickened_face_solid to be a `generalized_surface_select`")); }
    } while(0);
    do { // convert the 'offset1' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->offset1, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to thickened_face_solid to be a `length_measure`")); }
    } while(0);
    do { // convert the 'offset2' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->offset2, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to thickened_face_solid to be a `length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<thickness_laminate_definition>(const DB& db, const LIST& params, thickness_laminate_definition* in)
{
	size_t base = GenericFill(db,params,static_cast<product_definition*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to thickness_laminate_definition"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<thickness_laminate_table>(const DB& db, const LIST& params, thickness_laminate_table* in)
{
	size_t base = GenericFill(db,params,static_cast<zone_structural_makeup*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to thickness_laminate_table"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<time_interval>(const DB& db, const LIST& params, time_interval* in)
{
	size_t base = 0;
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to time_interval"); }    do { // convert the 'id' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::time_interval,3>::aux_is_derived[0]=true; break; }
        try { GenericConvert( in->id, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to time_interval to be a `identifier`")); }
    } while(0);
    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::time_interval,3>::aux_is_derived[1]=true; break; }
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to time_interval to be a `label`")); }
    } while(0);
    do { // convert the 'description' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const ISDERIVED*>(&*arg)) { in->ObjectHelper<Assimp::StepFile::time_interval,3>::aux_is_derived[2]=true; break; }
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->description, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to time_interval to be a `text`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<time_interval_based_effectivity>(const DB& db, const LIST& params, time_interval_based_effectivity* in)
{
	size_t base = GenericFill(db,params,static_cast<effectivity*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to time_interval_based_effectivity"); }    do { // convert the 'effectivity_period' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->effectivity_period, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to time_interval_based_effectivity to be a `time_interval`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<time_interval_with_bounds>(const DB& db, const LIST& params, time_interval_with_bounds* in)
{
	size_t base = GenericFill(db,params,static_cast<time_interval*>(in));
	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to time_interval_with_bounds"); }    do { // convert the 'primary_bound' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->primary_bound, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to time_interval_with_bounds to be a `date_time_or_event_occurrence`")); }
    } while(0);
    do { // convert the 'secondary_bound' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->secondary_bound, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to time_interval_with_bounds to be a `date_time_or_event_occurrence`")); }
    } while(0);
    do { // convert the 'duration' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->duration, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to time_interval_with_bounds to be a `time_measure_with_unit`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<time_measure_with_unit>(const DB& db, const LIST& params, time_measure_with_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<measure_with_unit*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to time_measure_with_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<time_unit>(const DB& db, const LIST& params, time_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<named_unit*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to time_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<tolerance_zone>(const DB& db, const LIST& params, tolerance_zone* in)
{
	size_t base = GenericFill(db,params,static_cast<shape_aspect*>(in));
	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to tolerance_zone"); }    do { // convert the 'defining_tolerance' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->defining_tolerance, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to tolerance_zone to be a `SET [1:?] OF geometric_tolerance`")); }
    } while(0);
    do { // convert the 'form' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->form, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to tolerance_zone to be a `tolerance_zone_form`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<torus>(const DB& db, const LIST& params, torus* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_representation_item*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to torus"); }    do { // convert the 'position' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->position, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to torus to be a `axis1_placement`")); }
    } while(0);
    do { // convert the 'major_radius' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->major_radius, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to torus to be a `positive_length_measure`")); }
    } while(0);
    do { // convert the 'minor_radius' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->minor_radius, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to torus to be a `positive_length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<total_runout_tolerance>(const DB& db, const LIST& params, total_runout_tolerance* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_tolerance_with_datum_reference*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to total_runout_tolerance"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<track_blended_solid>(const DB& db, const LIST& params, track_blended_solid* in)
{
	size_t base = GenericFill(db,params,static_cast<edge_blended_solid*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to track_blended_solid"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<track_blended_solid_with_end_conditions>(const DB& db, const LIST& params, track_blended_solid_with_end_conditions* in)
{
	size_t base = GenericFill(db,params,static_cast<track_blended_solid*>(in));
	if (params.GetSize() < 5) { throw STEP::TypeError("expected 5 arguments to track_blended_solid_with_end_conditions"); }    do { // convert the 'end_conditions' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->end_conditions, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to track_blended_solid_with_end_conditions to be a `LIST [2:2] OF blend_end_condition_select`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<trimmed_curve>(const DB& db, const LIST& params, trimmed_curve* in)
{
	size_t base = GenericFill(db,params,static_cast<bounded_curve*>(in));
	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to trimmed_curve"); }    do { // convert the 'basis_curve' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->basis_curve, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to trimmed_curve to be a `curve`")); }
    } while(0);
    do { // convert the 'trim_1' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->trim_1, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to trimmed_curve to be a `SET [1:2] OF trimming_select`")); }
    } while(0);
    do { // convert the 'trim_2' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->trim_2, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to trimmed_curve to be a `SET [1:2] OF trimming_select`")); }
    } while(0);
    do { // convert the 'sense_agreement' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->sense_agreement, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to trimmed_curve to be a `BOOLEAN`")); }
    } while(0);
    do { // convert the 'master_representation' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->master_representation, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to trimmed_curve to be a `trimming_preference`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<two_direction_repeat_factor>(const DB& db, const LIST& params, two_direction_repeat_factor* in)
{
	size_t base = GenericFill(db,params,static_cast<one_direction_repeat_factor*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to two_direction_repeat_factor"); }    do { // convert the 'second_repeat_factor' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->second_repeat_factor, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to two_direction_repeat_factor to be a `vector`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<unary_generic_expression>(const DB& db, const LIST& params, unary_generic_expression* in)
{
	size_t base = GenericFill(db,params,static_cast<generic_expression*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to unary_generic_expression"); }    do { // convert the 'operand' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->operand, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to unary_generic_expression to be a `generic_expression`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<unary_numeric_expression>(const DB& db, const LIST& params, unary_numeric_expression* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<uncertainty_assigned_representation>(const DB& db, const LIST& params, uncertainty_assigned_representation* in)
{
	size_t base = GenericFill(db,params,static_cast<representation*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to uncertainty_assigned_representation"); }    do { // convert the 'uncertainty' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->uncertainty, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to uncertainty_assigned_representation to be a `SET [1:?] OF uncertainty_measure_with_unit`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<uncertainty_measure_with_unit>(const DB& db, const LIST& params, uncertainty_measure_with_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<measure_with_unit*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to uncertainty_measure_with_unit"); }    do { // convert the 'name' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->name, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to uncertainty_measure_with_unit to be a `label`")); }
    } while(0);
    do { // convert the 'description' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->description, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to uncertainty_measure_with_unit to be a `text`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<uniform_curve>(const DB& db, const LIST& params, uniform_curve* in)
{
	size_t base = GenericFill(db,params,static_cast<b_spline_curve*>(in));
	if (params.GetSize() < 6) { throw STEP::TypeError("expected 6 arguments to uniform_curve"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<uniform_resource_identifier>(const DB& db, const LIST& params, uniform_resource_identifier* in)
{
	size_t base = GenericFill(db,params,static_cast<descriptive_representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to uniform_resource_identifier"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<uniform_surface>(const DB& db, const LIST& params, uniform_surface* in)
{
	size_t base = GenericFill(db,params,static_cast<b_spline_surface*>(in));
	if (params.GetSize() < 7) { throw STEP::TypeError("expected 7 arguments to uniform_surface"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<usage_association>(const DB& db, const LIST& params, usage_association* in)
{
	size_t base = GenericFill(db,params,static_cast<action_method_relationship*>(in));
	if (params.GetSize() < 4) { throw STEP::TypeError("expected 4 arguments to usage_association"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<user_defined_curve_font>(const DB& db, const LIST& params, user_defined_curve_font* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<user_defined_marker>(const DB& db, const LIST& params, user_defined_marker* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<user_defined_terminator_symbol>(const DB& db, const LIST& params, user_defined_terminator_symbol* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<user_selected_shape_elements>(const DB& db, const LIST& params, user_selected_shape_elements* in)
{
	size_t base = GenericFill(db,params,static_cast<user_selected_elements*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to user_selected_shape_elements"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<value_range>(const DB& db, const LIST& params, value_range* in)
{
	size_t base = GenericFill(db,params,static_cast<compound_representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to value_range"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<value_representation_item>(const DB& db, const LIST& params, value_representation_item* in)
{
	size_t base = GenericFill(db,params,static_cast<representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to value_representation_item"); }    do { // convert the 'value_component' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->value_component, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to value_representation_item to be a `measure_value`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<variable_semantics>(const DB& db, const LIST& params, variable_semantics* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<variational_representation_item>(const DB& db, const LIST& params, variational_representation_item* in)
{
	size_t base = GenericFill(db,params,static_cast<representation_item*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to variational_representation_item"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<vector>(const DB& db, const LIST& params, vector* in)
{
	size_t base = GenericFill(db,params,static_cast<geometric_representation_item*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to vector"); }    do { // convert the 'orientation' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->orientation, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to vector to be a `direction`")); }
    } while(0);
    do { // convert the 'magnitude' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->magnitude, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to vector to be a `length_measure`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<vector_style>(const DB& db, const LIST& params, vector_style* in)
{
	size_t base = 0;
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<velocity_measure_with_unit>(const DB& db, const LIST& params, velocity_measure_with_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<measure_with_unit*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to velocity_measure_with_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<velocity_unit>(const DB& db, const LIST& params, velocity_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<derived_unit*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to velocity_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<vertex>(const DB& db, const LIST& params, vertex* in)
{
	size_t base = GenericFill(db,params,static_cast<topological_representation_item*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to vertex"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<vertex_loop>(const DB& db, const LIST& params, vertex_loop* in)
{
	size_t base = GenericFill(db,params,static_cast<loop*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to vertex_loop"); }    do { // convert the 'loop_vertex' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->loop_vertex, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to vertex_loop to be a `vertex`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<vertex_point>(const DB& db, const LIST& params, vertex_point* in)
{
	size_t base = 0;
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to vertex_point"); }    do { // convert the 'vertex_geometry' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->vertex_geometry, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to vertex_point to be a `point`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<vertex_shell>(const DB& db, const LIST& params, vertex_shell* in)
{
	size_t base = GenericFill(db,params,static_cast<topological_representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to vertex_shell"); }    do { // convert the 'vertex_shell_extent' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->vertex_shell_extent, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to vertex_shell to be a `vertex_loop`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<view_volume>(const DB& db, const LIST& params, view_volume* in)
{
	size_t base = GenericFill(db,params,static_cast<founded_item*>(in));
	if (params.GetSize() < 9) { throw STEP::TypeError("expected 9 arguments to view_volume"); }    do { // convert the 'projection_type' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->projection_type, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 0 to view_volume to be a `central_or_parallel`")); }
    } while(0);
    do { // convert the 'projection_point' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->projection_point, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to view_volume to be a `cartesian_point`")); }
    } while(0);
    do { // convert the 'view_plane_distance' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->view_plane_distance, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to view_volume to be a `length_measure`")); }
    } while(0);
    do { // convert the 'front_plane_distance' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->front_plane_distance, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 3 to view_volume to be a `length_measure`")); }
    } while(0);
    do { // convert the 'front_plane_clipping' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->front_plane_clipping, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 4 to view_volume to be a `BOOLEAN`")); }
    } while(0);
    do { // convert the 'back_plane_distance' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->back_plane_distance, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 5 to view_volume to be a `length_measure`")); }
    } while(0);
    do { // convert the 'back_plane_clipping' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->back_plane_clipping, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 6 to view_volume to be a `BOOLEAN`")); }
    } while(0);
    do { // convert the 'view_volume_sides_clipping' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->view_volume_sides_clipping, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 7 to view_volume to be a `BOOLEAN`")); }
    } while(0);
    do { // convert the 'view_window' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->view_window, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 8 to view_volume to be a `planar_box`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<visual_appearance_representation>(const DB& db, const LIST& params, visual_appearance_representation* in)
{
	size_t base = GenericFill(db,params,static_cast<representation*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to visual_appearance_representation"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<volume_measure_with_unit>(const DB& db, const LIST& params, volume_measure_with_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<measure_with_unit*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to volume_measure_with_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<volume_unit>(const DB& db, const LIST& params, volume_unit* in)
{
	size_t base = GenericFill(db,params,static_cast<derived_unit*>(in));
	if (params.GetSize() < 1) { throw STEP::TypeError("expected 1 arguments to volume_unit"); }	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<week_of_year_and_day_date>(const DB& db, const LIST& params, week_of_year_and_day_date* in)
{
	size_t base = GenericFill(db,params,static_cast<date*>(in));
	if (params.GetSize() < 3) { throw STEP::TypeError("expected 3 arguments to week_of_year_and_day_date"); }    do { // convert the 'week_component' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->week_component, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to week_of_year_and_day_date to be a `week_in_year_number`")); }
    } while(0);
    do { // convert the 'day_component' argument
        std::shared_ptr<const DataType> arg = params[base++];
        if (dynamic_cast<const UNSET*>(&*arg)) break;
        try { GenericConvert( in->day_component, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 2 to week_of_year_and_day_date to be a `day_in_week_number`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<wire_shell>(const DB& db, const LIST& params, wire_shell* in)
{
	size_t base = GenericFill(db,params,static_cast<topological_representation_item*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to wire_shell"); }    do { // convert the 'wire_shell_extent' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->wire_shell_extent, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to wire_shell to be a `SET [1:?] OF loop`")); }
    } while(0);
	return base;
}
// -----------------------------------------------------------------------------------------------------------
template <> size_t GenericFill<year_month>(const DB& db, const LIST& params, year_month* in)
{
	size_t base = GenericFill(db,params,static_cast<date*>(in));
	if (params.GetSize() < 2) { throw STEP::TypeError("expected 2 arguments to year_month"); }    do { // convert the 'month_component' argument
        std::shared_ptr<const DataType> arg = params[base++];
        try { GenericConvert( in->month_component, arg, db ); break; } 
        catch (const TypeError& t) { throw TypeError(t.what() + std::string(" - expected argument 1 to year_month to be a `month_in_year_number`")); }
    } while(0);
	return base;
}

} // ! STEP
} // ! Assimp

#endif
